thanksgiving_jsonp([0], [function(module, exports, __webpack_require__) {
    var global = __webpack_require__(2),
        core = __webpack_require__(18),
        hide = __webpack_require__(11),
        redefine = __webpack_require__(12),
        ctx = __webpack_require__(19),
        $export = function(type, name, source) {
            var key, own, out, exp, IS_FORCED = type & $export.F,
                IS_GLOBAL = type & $export.G,
                IS_STATIC = type & $export.S,
                IS_PROTO = type & $export.P,
                IS_BIND = type & $export.B,
                target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {}).prototype,
                exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
                expProto = exports.prototype || (exports.prototype = {});
            for (key in IS_GLOBAL && (source = name), source) out = ((own = !IS_FORCED && target && void 0 !== target[key]) ? target : source)[key], exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && "function" == typeof out ? ctx(Function.call, out) : out, target && redefine(target, key, out, type & $export.U), exports[key] != out && hide(exports, key, exp), IS_PROTO && expProto[key] != out && (expProto[key] = out)
        };
    global.core = core, $export.F = 1, $export.G = 2, $export.S = 4, $export.P = 8, $export.B = 16, $export.W = 32, $export.U = 64, $export.R = 128, module.exports = $export
}, function(module, exports, __webpack_require__) {
    var isObject = __webpack_require__(4);
    module.exports = function(it) {
        if (!isObject(it)) throw TypeError(it + " is not an object!");
        return it
    }
}, function(module, exports) {
    var global = module.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
    "number" == typeof __g && (__g = global)
}, function(module, exports) {
    module.exports = function(exec) {
        try {
            return !!exec()
        } catch (e) {
            return !0
        }
    }
}, function(module, exports) {
    module.exports = function(it) {
        return "object" == typeof it ? null !== it : "function" == typeof it
    }
}, function(module, exports, __webpack_require__) {
    var store = __webpack_require__(48)("wks"),
        uid = __webpack_require__(33),
        Symbol = __webpack_require__(2).Symbol,
        USE_SYMBOL = "function" == typeof Symbol;
    (module.exports = function(name) {
        return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)("Symbol." + name))
    }).store = store
}, function(module, exports, __webpack_require__) {
    var toInteger = __webpack_require__(21),
        min = Math.min;
    module.exports = function(it) {
        return it > 0 ? min(toInteger(it), 9007199254740991) : 0
    }
}, function(module, exports, __webpack_require__) {
    module.exports = !__webpack_require__(3)(function() {
        return 7 != Object.defineProperty({}, "a", {
            get: function() {
                return 7
            }
        }).a
    })
}, function(module, exports, __webpack_require__) {
    var anObject = __webpack_require__(1),
        IE8_DOM_DEFINE = __webpack_require__(97),
        toPrimitive = __webpack_require__(23),
        dP = Object.defineProperty;
    exports.f = __webpack_require__(7) ? Object.defineProperty : function(O, P, Attributes) {
        if (anObject(O), P = toPrimitive(P, !0), anObject(Attributes), IE8_DOM_DEFINE) try {
            return dP(O, P, Attributes)
        } catch (e) {}
        if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported!");
        return "value" in Attributes && (O[P] = Attributes.value), O
    }
}, function(module, exports, __webpack_require__) {
    var defined = __webpack_require__(24);
    module.exports = function(it) {
        return Object(defined(it))
    }
}, function(module, exports) {
    module.exports = function(it) {
        if ("function" != typeof it) throw TypeError(it + " is not a function!");
        return it
    }
}, function(module, exports, __webpack_require__) {
    var dP = __webpack_require__(8),
        createDesc = __webpack_require__(32);
    module.exports = __webpack_require__(7) ? function(object, key, value) {
        return dP.f(object, key, createDesc(1, value))
    } : function(object, key, value) {
        return object[key] = value, object
    }
}, function(module, exports, __webpack_require__) {
    var global = __webpack_require__(2),
        hide = __webpack_require__(11),
        has = __webpack_require__(14),
        SRC = __webpack_require__(33)("src"),
        $toString = __webpack_require__(138),
        TPL = ("" + $toString).split("toString");
    __webpack_require__(18).inspectSource = function(it) {
        return $toString.call(it)
    }, (module.exports = function(O, key, val, safe) {
        var isFunction = "function" == typeof val;
        isFunction && (has(val, "name") || hide(val, "name", key)), O[key] !== val && (isFunction && (has(val, SRC) || hide(val, SRC, O[key] ? "" + O[key] : TPL.join(String(key)))), O === global ? O[key] = val : safe ? O[key] ? O[key] = val : hide(O, key, val) : (delete O[key], hide(O, key, val)))
    })(Function.prototype, "toString", function() {
        return "function" == typeof this && this[SRC] || $toString.call(this)
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        fails = __webpack_require__(3),
        defined = __webpack_require__(24),
        quot = /"/g,
        createHTML = function(string, tag, attribute, value) {
            var S = String(defined(string)),
                p1 = "<" + tag;
            return "" !== attribute && (p1 += " " + attribute + '="' + String(value).replace(quot, "&quot;") + '"'), p1 + ">" + S + "</" + tag + ">"
        };
    module.exports = function(NAME, exec) {
        var O = {};
        O[NAME] = exec(createHTML), $export($export.P + $export.F * fails(function() {
            var test = "" [NAME]('"');
            return test !== test.toLowerCase() || test.split('"').length > 3
        }), "String", O)
    }
}, function(module, exports) {
    var hasOwnProperty = {}.hasOwnProperty;
    module.exports = function(it, key) {
        return hasOwnProperty.call(it, key)
    }
}, function(module, exports, __webpack_require__) {
    var IObject = __webpack_require__(49),
        defined = __webpack_require__(24);
    module.exports = function(it) {
        return IObject(defined(it))
    }
}, function(module, exports, __webpack_require__) {
    var pIE = __webpack_require__(50),
        createDesc = __webpack_require__(32),
        toIObject = __webpack_require__(15),
        toPrimitive = __webpack_require__(23),
        has = __webpack_require__(14),
        IE8_DOM_DEFINE = __webpack_require__(97),
        gOPD = Object.getOwnPropertyDescriptor;
    exports.f = __webpack_require__(7) ? gOPD : function(O, P) {
        if (O = toIObject(O), P = toPrimitive(P, !0), IE8_DOM_DEFINE) try {
            return gOPD(O, P)
        } catch (e) {}
        if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P])
    }
}, function(module, exports, __webpack_require__) {
    var has = __webpack_require__(14),
        toObject = __webpack_require__(9),
        IE_PROTO = __webpack_require__(72)("IE_PROTO"),
        ObjectProto = Object.prototype;
    module.exports = Object.getPrototypeOf || function(O) {
        return O = toObject(O), has(O, IE_PROTO) ? O[IE_PROTO] : "function" == typeof O.constructor && O instanceof O.constructor ? O.constructor.prototype : O instanceof Object ? ObjectProto : null
    }
}, function(module, exports) {
    var core = module.exports = {
        version: "2.6.9"
    };
    "number" == typeof __e && (__e = core)
}, function(module, exports, __webpack_require__) {
    var aFunction = __webpack_require__(10);
    module.exports = function(fn, that, length) {
        if (aFunction(fn), void 0 === that) return fn;
        switch (length) {
            case 1:
                return function(a) {
                    return fn.call(that, a)
                };
            case 2:
                return function(a, b) {
                    return fn.call(that, a, b)
                };
            case 3:
                return function(a, b, c) {
                    return fn.call(that, a, b, c)
                }
        }
        return function() {
            return fn.apply(that, arguments)
        }
    }
}, function(module, exports) {
    var toString = {}.toString;
    module.exports = function(it) {
        return toString.call(it).slice(8, -1)
    }
}, function(module, exports) {
    var ceil = Math.ceil,
        floor = Math.floor;
    module.exports = function(it) {
        return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it)
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var fails = __webpack_require__(3);
    module.exports = function(method, arg) {
        return !!method && fails(function() {
            arg ? method.call(null, function() {}, 1) : method.call(null)
        })
    }
}, function(module, exports, __webpack_require__) {
    var isObject = __webpack_require__(4);
    module.exports = function(it, S) {
        if (!isObject(it)) return it;
        var fn, val;
        if (S && "function" == typeof(fn = it.toString) && !isObject(val = fn.call(it))) return val;
        if ("function" == typeof(fn = it.valueOf) && !isObject(val = fn.call(it))) return val;
        if (!S && "function" == typeof(fn = it.toString) && !isObject(val = fn.call(it))) return val;
        throw TypeError("Can't convert object to primitive value")
    }
}, function(module, exports) {
    module.exports = function(it) {
        if (void 0 == it) throw TypeError("Can't call method on  " + it);
        return it
    }
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        core = __webpack_require__(18),
        fails = __webpack_require__(3);
    module.exports = function(KEY, exec) {
        var fn = (core.Object || {})[KEY] || Object[KEY],
            exp = {};
        exp[KEY] = exec(fn), $export($export.S + $export.F * fails(function() {
            fn(1)
        }), "Object", exp)
    }
}, function(module, exports, __webpack_require__) {
    var ctx = __webpack_require__(19),
        IObject = __webpack_require__(49),
        toObject = __webpack_require__(9),
        toLength = __webpack_require__(6),
        asc = __webpack_require__(88);
    module.exports = function(TYPE, $create) {
        var IS_MAP = 1 == TYPE,
            IS_FILTER = 2 == TYPE,
            IS_SOME = 3 == TYPE,
            IS_EVERY = 4 == TYPE,
            IS_FIND_INDEX = 6 == TYPE,
            NO_HOLES = 5 == TYPE || IS_FIND_INDEX,
            create = $create || asc;
        return function($this, callbackfn, that) {
            for (var val, res, O = toObject($this), self = IObject(O), f = ctx(callbackfn, that, 3), length = toLength(self.length), index = 0, result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : void 0; length > index; index++)
                if ((NO_HOLES || index in self) && (res = f(val = self[index], index, O), TYPE))
                    if (IS_MAP) result[index] = res;
                    else if (res) switch (TYPE) {
                case 3:
                    return !0;
                case 5:
                    return val;
                case 6:
                    return index;
                case 2:
                    result.push(val)
            } else if (IS_EVERY) return !1;
            return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result
        }
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    if (__webpack_require__(7)) {
        var LIBRARY = __webpack_require__(29),
            global = __webpack_require__(2),
            fails = __webpack_require__(3),
            $export = __webpack_require__(0),
            $typed = __webpack_require__(65),
            $buffer = __webpack_require__(96),
            ctx = __webpack_require__(19),
            anInstance = __webpack_require__(39),
            propertyDesc = __webpack_require__(32),
            hide = __webpack_require__(11),
            redefineAll = __webpack_require__(41),
            toInteger = __webpack_require__(21),
            toLength = __webpack_require__(6),
            toIndex = __webpack_require__(125),
            toAbsoluteIndex = __webpack_require__(35),
            toPrimitive = __webpack_require__(23),
            has = __webpack_require__(14),
            classof = __webpack_require__(45),
            isObject = __webpack_require__(4),
            toObject = __webpack_require__(9),
            isArrayIter = __webpack_require__(85),
            create = __webpack_require__(36),
            getPrototypeOf = __webpack_require__(17),
            gOPN = __webpack_require__(37).f,
            getIterFn = __webpack_require__(87),
            uid = __webpack_require__(33),
            wks = __webpack_require__(5),
            createArrayMethod = __webpack_require__(26),
            createArrayIncludes = __webpack_require__(55),
            speciesConstructor = __webpack_require__(52),
            ArrayIterators = __webpack_require__(90),
            Iterators = __webpack_require__(47),
            $iterDetect = __webpack_require__(60),
            setSpecies = __webpack_require__(38),
            arrayFill = __webpack_require__(89),
            arrayCopyWithin = __webpack_require__(114),
            $DP = __webpack_require__(8),
            $GOPD = __webpack_require__(16),
            dP = $DP.f,
            gOPD = $GOPD.f,
            RangeError = global.RangeError,
            TypeError = global.TypeError,
            Uint8Array = global.Uint8Array,
            ArrayProto = Array.prototype,
            $ArrayBuffer = $buffer.ArrayBuffer,
            $DataView = $buffer.DataView,
            arrayForEach = createArrayMethod(0),
            arrayFilter = createArrayMethod(2),
            arraySome = createArrayMethod(3),
            arrayEvery = createArrayMethod(4),
            arrayFind = createArrayMethod(5),
            arrayFindIndex = createArrayMethod(6),
            arrayIncludes = createArrayIncludes(!0),
            arrayIndexOf = createArrayIncludes(!1),
            arrayValues = ArrayIterators.values,
            arrayKeys = ArrayIterators.keys,
            arrayEntries = ArrayIterators.entries,
            arrayLastIndexOf = ArrayProto.lastIndexOf,
            arrayReduce = ArrayProto.reduce,
            arrayReduceRight = ArrayProto.reduceRight,
            arrayJoin = ArrayProto.join,
            arraySort = ArrayProto.sort,
            arraySlice = ArrayProto.slice,
            arrayToString = ArrayProto.toString,
            arrayToLocaleString = ArrayProto.toLocaleString,
            ITERATOR = wks("iterator"),
            TAG = wks("toStringTag"),
            TYPED_CONSTRUCTOR = uid("typed_constructor"),
            DEF_CONSTRUCTOR = uid("def_constructor"),
            ALL_CONSTRUCTORS = $typed.CONSTR,
            TYPED_ARRAY = $typed.TYPED,
            VIEW = $typed.VIEW,
            $map = createArrayMethod(1, function(O, length) {
                return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length)
            }),
            LITTLE_ENDIAN = fails(function() {
                return 1 === new Uint8Array(new Uint16Array([1]).buffer)[0]
            }),
            FORCED_SET = !!Uint8Array && !!Uint8Array.prototype.set && fails(function() {
                new Uint8Array(1).set({})
            }),
            toOffset = function(it, BYTES) {
                var offset = toInteger(it);
                if (offset < 0 || offset % BYTES) throw RangeError("Wrong offset!");
                return offset
            },
            validate = function(it) {
                if (isObject(it) && TYPED_ARRAY in it) return it;
                throw TypeError(it + " is not a typed array!")
            },
            allocate = function(C, length) {
                if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) throw TypeError("It is not a typed array constructor!");
                return new C(length)
            },
            speciesFromList = function(O, list) {
                return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list)
            },
            fromList = function(C, list) {
                for (var index = 0, length = list.length, result = allocate(C, length); length > index;) result[index] = list[index++];
                return result
            },
            addGetter = function(it, key, internal) {
                dP(it, key, {
                    get: function() {
                        return this._d[internal]
                    }
                })
            },
            $from = function(source) {
                var i, length, values, result, step, iterator, O = toObject(source),
                    aLen = arguments.length,
                    mapfn = aLen > 1 ? arguments[1] : void 0,
                    mapping = void 0 !== mapfn,
                    iterFn = getIterFn(O);
                if (void 0 != iterFn && !isArrayIter(iterFn)) {
                    for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) values.push(step.value);
                    O = values
                }
                for (mapping && aLen > 2 && (mapfn = ctx(mapfn, arguments[2], 2)), i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) result[i] = mapping ? mapfn(O[i], i) : O[i];
                return result
            },
            $of = function() {
                for (var index = 0, length = arguments.length, result = allocate(this, length); length > index;) result[index] = arguments[index++];
                return result
            },
            TO_LOCALE_BUG = !!Uint8Array && fails(function() {
                arrayToLocaleString.call(new Uint8Array(1))
            }),
            $toLocaleString = function() {
                return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments)
            },
            proto = {
                copyWithin: function(target, start) {
                    return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : void 0)
                },
                every: function(callbackfn) {
                    return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0)
                },
                fill: function(value) {
                    return arrayFill.apply(validate(this), arguments)
                },
                filter: function(callbackfn) {
                    return speciesFromList(this, arrayFilter(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0))
                },
                find: function(predicate) {
                    return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : void 0)
                },
                findIndex: function(predicate) {
                    return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : void 0)
                },
                forEach: function(callbackfn) {
                    arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0)
                },
                indexOf: function(searchElement) {
                    return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : void 0)
                },
                includes: function(searchElement) {
                    return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : void 0)
                },
                join: function(separator) {
                    return arrayJoin.apply(validate(this), arguments)
                },
                lastIndexOf: function(searchElement) {
                    return arrayLastIndexOf.apply(validate(this), arguments)
                },
                map: function(mapfn) {
                    return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : void 0)
                },
                reduce: function(callbackfn) {
                    return arrayReduce.apply(validate(this), arguments)
                },
                reduceRight: function(callbackfn) {
                    return arrayReduceRight.apply(validate(this), arguments)
                },
                reverse: function() {
                    for (var value, length = validate(this).length, middle = Math.floor(length / 2), index = 0; index < middle;) value = this[index], this[index++] = this[--length], this[length] = value;
                    return this
                },
                some: function(callbackfn) {
                    return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0)
                },
                sort: function(comparefn) {
                    return arraySort.call(validate(this), comparefn)
                },
                subarray: function(begin, end) {
                    var O = validate(this),
                        length = O.length,
                        $begin = toAbsoluteIndex(begin, length);
                    return new(speciesConstructor(O, O[DEF_CONSTRUCTOR]))(O.buffer, O.byteOffset + $begin * O.BYTES_PER_ELEMENT, toLength((void 0 === end ? length : toAbsoluteIndex(end, length)) - $begin))
                }
            },
            $slice = function(start, end) {
                return speciesFromList(this, arraySlice.call(validate(this), start, end))
            },
            $set = function(arrayLike) {
                validate(this);
                var offset = toOffset(arguments[1], 1),
                    length = this.length,
                    src = toObject(arrayLike),
                    len = toLength(src.length),
                    index = 0;
                if (len + offset > length) throw RangeError("Wrong length!");
                for (; index < len;) this[offset + index] = src[index++]
            },
            $iterators = {
                entries: function() {
                    return arrayEntries.call(validate(this))
                },
                keys: function() {
                    return arrayKeys.call(validate(this))
                },
                values: function() {
                    return arrayValues.call(validate(this))
                }
            },
            isTAIndex = function(target, key) {
                return isObject(target) && target[TYPED_ARRAY] && "symbol" != typeof key && key in target && String(+key) == String(key)
            },
            $getDesc = function(target, key) {
                return isTAIndex(target, key = toPrimitive(key, !0)) ? propertyDesc(2, target[key]) : gOPD(target, key)
            },
            $setDesc = function(target, key, desc) {
                return !(isTAIndex(target, key = toPrimitive(key, !0)) && isObject(desc) && has(desc, "value")) || has(desc, "get") || has(desc, "set") || desc.configurable || has(desc, "writable") && !desc.writable || has(desc, "enumerable") && !desc.enumerable ? dP(target, key, desc) : (target[key] = desc.value, target)
            };
        ALL_CONSTRUCTORS || ($GOPD.f = $getDesc, $DP.f = $setDesc), $export($export.S + $export.F * !ALL_CONSTRUCTORS, "Object", {
            getOwnPropertyDescriptor: $getDesc,
            defineProperty: $setDesc
        }), fails(function() {
            arrayToString.call({})
        }) && (arrayToString = arrayToLocaleString = function() {
            return arrayJoin.call(this)
        });
        var $TypedArrayPrototype$ = redefineAll({}, proto);
        redefineAll($TypedArrayPrototype$, $iterators), hide($TypedArrayPrototype$, ITERATOR, $iterators.values), redefineAll($TypedArrayPrototype$, {
            slice: $slice,
            set: $set,
            constructor: function() {},
            toString: arrayToString,
            toLocaleString: $toLocaleString
        }), addGetter($TypedArrayPrototype$, "buffer", "b"), addGetter($TypedArrayPrototype$, "byteOffset", "o"), addGetter($TypedArrayPrototype$, "byteLength", "l"), addGetter($TypedArrayPrototype$, "length", "e"), dP($TypedArrayPrototype$, TAG, {
            get: function() {
                return this[TYPED_ARRAY]
            }
        }), module.exports = function(KEY, BYTES, wrapper, CLAMPED) {
            var NAME = KEY + ((CLAMPED = !!CLAMPED) ? "Clamped" : "") + "Array",
                GETTER = "get" + KEY,
                SETTER = "set" + KEY,
                TypedArray = global[NAME],
                Base = TypedArray || {},
                TAC = TypedArray && getPrototypeOf(TypedArray),
                FORCED = !TypedArray || !$typed.ABV,
                O = {},
                TypedArrayPrototype = TypedArray && TypedArray.prototype,
                addElement = function(that, index) {
                    dP(that, index, {
                        get: function() {
                            return function(that, index) {
                                var data = that._d;
                                return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN)
                            }(this, index)
                        },
                        set: function(value) {
                            return function(that, index, value) {
                                var data = that._d;
                                CLAMPED && (value = (value = Math.round(value)) < 0 ? 0 : value > 255 ? 255 : 255 & value), data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN)
                            }(this, index, value)
                        },
                        enumerable: !0
                    })
                };
            FORCED ? (TypedArray = wrapper(function(that, data, $offset, $length) {
                anInstance(that, TypedArray, NAME, "_d");
                var buffer, byteLength, length, klass, index = 0,
                    offset = 0;
                if (isObject(data)) {
                    if (!(data instanceof $ArrayBuffer || "ArrayBuffer" == (klass = classof(data)) || "SharedArrayBuffer" == klass)) return TYPED_ARRAY in data ? fromList(TypedArray, data) : $from.call(TypedArray, data);
                    buffer = data, offset = toOffset($offset, BYTES);
                    var $len = data.byteLength;
                    if (void 0 === $length) {
                        if ($len % BYTES) throw RangeError("Wrong length!");
                        if ((byteLength = $len - offset) < 0) throw RangeError("Wrong length!")
                    } else if ((byteLength = toLength($length) * BYTES) + offset > $len) throw RangeError("Wrong length!");
                    length = byteLength / BYTES
                } else length = toIndex(data), buffer = new $ArrayBuffer(byteLength = length * BYTES);
                for (hide(that, "_d", {
                        b: buffer,
                        o: offset,
                        l: byteLength,
                        e: length,
                        v: new $DataView(buffer)
                    }); index < length;) addElement(that, index++)
            }), TypedArrayPrototype = TypedArray.prototype = create($TypedArrayPrototype$), hide(TypedArrayPrototype, "constructor", TypedArray)) : fails(function() {
                TypedArray(1)
            }) && fails(function() {
                new TypedArray(-1)
            }) && $iterDetect(function(iter) {
                new TypedArray, new TypedArray(null), new TypedArray(1.5), new TypedArray(iter)
            }, !0) || (TypedArray = wrapper(function(that, data, $offset, $length) {
                var klass;
                return anInstance(that, TypedArray, NAME), isObject(data) ? data instanceof $ArrayBuffer || "ArrayBuffer" == (klass = classof(data)) || "SharedArrayBuffer" == klass ? void 0 !== $length ? new Base(data, toOffset($offset, BYTES), $length) : void 0 !== $offset ? new Base(data, toOffset($offset, BYTES)) : new Base(data) : TYPED_ARRAY in data ? fromList(TypedArray, data) : $from.call(TypedArray, data) : new Base(toIndex(data))
            }), arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function(key) {
                key in TypedArray || hide(TypedArray, key, Base[key])
            }), TypedArray.prototype = TypedArrayPrototype, LIBRARY || (TypedArrayPrototype.constructor = TypedArray));
            var $nativeIterator = TypedArrayPrototype[ITERATOR],
                CORRECT_ITER_NAME = !!$nativeIterator && ("values" == $nativeIterator.name || void 0 == $nativeIterator.name),
                $iterator = $iterators.values;
            hide(TypedArray, TYPED_CONSTRUCTOR, !0), hide(TypedArrayPrototype, TYPED_ARRAY, NAME), hide(TypedArrayPrototype, VIEW, !0), hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray), (CLAMPED ? new TypedArray(1)[TAG] == NAME : TAG in TypedArrayPrototype) || dP(TypedArrayPrototype, TAG, {
                get: function() {
                    return NAME
                }
            }), O[NAME] = TypedArray, $export($export.G + $export.W + $export.F * (TypedArray != Base), O), $export($export.S, NAME, {
                BYTES_PER_ELEMENT: BYTES
            }), $export($export.S + $export.F * fails(function() {
                Base.of.call(TypedArray, 1)
            }), NAME, {
                from: $from,
                of: $of
            }), "BYTES_PER_ELEMENT" in TypedArrayPrototype || hide(TypedArrayPrototype, "BYTES_PER_ELEMENT", BYTES), $export($export.P, NAME, proto), setSpecies(NAME), $export($export.P + $export.F * FORCED_SET, NAME, {
                set: $set
            }), $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators), LIBRARY || TypedArrayPrototype.toString == arrayToString || (TypedArrayPrototype.toString = arrayToString), $export($export.P + $export.F * fails(function() {
                new TypedArray(1).slice()
            }), NAME, {
                slice: $slice
            }), $export($export.P + $export.F * (fails(function() {
                return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString()
            }) || !fails(function() {
                TypedArrayPrototype.toLocaleString.call([1, 2])
            })), NAME, {
                toLocaleString: $toLocaleString
            }), Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator, LIBRARY || CORRECT_ITER_NAME || hide(TypedArrayPrototype, ITERATOR, $iterator)
        }
    } else module.exports = function() {}
}, function(module, exports, __webpack_require__) {
    var Map = __webpack_require__(120),
        $export = __webpack_require__(0),
        shared = __webpack_require__(48)("metadata"),
        store = shared.store || (shared.store = new(__webpack_require__(123))),
        getOrCreateMetadataMap = function(target, targetKey, create) {
            var targetMetadata = store.get(target);
            if (!targetMetadata) {
                if (!create) return;
                store.set(target, targetMetadata = new Map)
            }
            var keyMetadata = targetMetadata.get(targetKey);
            if (!keyMetadata) {
                if (!create) return;
                targetMetadata.set(targetKey, keyMetadata = new Map)
            }
            return keyMetadata
        };
    module.exports = {
        store: store,
        map: getOrCreateMetadataMap,
        has: function(MetadataKey, O, P) {
            var metadataMap = getOrCreateMetadataMap(O, P, !1);
            return void 0 !== metadataMap && metadataMap.has(MetadataKey)
        },
        get: function(MetadataKey, O, P) {
            var metadataMap = getOrCreateMetadataMap(O, P, !1);
            return void 0 === metadataMap ? void 0 : metadataMap.get(MetadataKey)
        },
        set: function(MetadataKey, MetadataValue, O, P) {
            getOrCreateMetadataMap(O, P, !0).set(MetadataKey, MetadataValue)
        },
        keys: function(target, targetKey) {
            var metadataMap = getOrCreateMetadataMap(target, targetKey, !1),
                keys = [];
            return metadataMap && metadataMap.forEach(function(_, key) {
                keys.push(key)
            }), keys
        },
        key: function(it) {
            return void 0 === it || "symbol" == typeof it ? it : String(it)
        },
        exp: function(O) {
            $export($export.S, "Reflect", O)
        }
    }
}, function(module, exports) {
    module.exports = !1
}, function(module, exports, __webpack_require__) {
    var META = __webpack_require__(33)("meta"),
        isObject = __webpack_require__(4),
        has = __webpack_require__(14),
        setDesc = __webpack_require__(8).f,
        id = 0,
        isExtensible = Object.isExtensible || function() {
            return !0
        },
        FREEZE = !__webpack_require__(3)(function() {
            return isExtensible(Object.preventExtensions({}))
        }),
        setMeta = function(it) {
            setDesc(it, META, {
                value: {
                    i: "O" + ++id,
                    w: {}
                }
            })
        },
        meta = module.exports = {
            KEY: META,
            NEED: !1,
            fastKey: function(it, create) {
                if (!isObject(it)) return "symbol" == typeof it ? it : ("string" == typeof it ? "S" : "P") + it;
                if (!has(it, META)) {
                    if (!isExtensible(it)) return "F";
                    if (!create) return "E";
                    setMeta(it)
                }
                return it[META].i
            },
            getWeak: function(it, create) {
                if (!has(it, META)) {
                    if (!isExtensible(it)) return !0;
                    if (!create) return !1;
                    setMeta(it)
                }
                return it[META].w
            },
            onFreeze: function(it) {
                return FREEZE && meta.NEED && isExtensible(it) && !has(it, META) && setMeta(it), it
            }
        }
}, function(module, exports, __webpack_require__) {
    var UNSCOPABLES = __webpack_require__(5)("unscopables"),
        ArrayProto = Array.prototype;
    void 0 == ArrayProto[UNSCOPABLES] && __webpack_require__(11)(ArrayProto, UNSCOPABLES, {}), module.exports = function(key) {
        ArrayProto[UNSCOPABLES][key] = !0
    }
}, function(module, exports) {
    module.exports = function(bitmap, value) {
        return {
            enumerable: !(1 & bitmap),
            configurable: !(2 & bitmap),
            writable: !(4 & bitmap),
            value: value
        }
    }
}, function(module, exports) {
    var id = 0,
        px = Math.random();
    module.exports = function(key) {
        return "Symbol(".concat(void 0 === key ? "" : key, ")_", (++id + px).toString(36))
    }
}, function(module, exports, __webpack_require__) {
    var $keys = __webpack_require__(99),
        enumBugKeys = __webpack_require__(73);
    module.exports = Object.keys || function(O) {
        return $keys(O, enumBugKeys)
    }
}, function(module, exports, __webpack_require__) {
    var toInteger = __webpack_require__(21),
        max = Math.max,
        min = Math.min;
    module.exports = function(index, length) {
        return (index = toInteger(index)) < 0 ? max(index + length, 0) : min(index, length)
    }
}, function(module, exports, __webpack_require__) {
    var anObject = __webpack_require__(1),
        dPs = __webpack_require__(100),
        enumBugKeys = __webpack_require__(73),
        IE_PROTO = __webpack_require__(72)("IE_PROTO"),
        Empty = function() {},
        createDict = function() {
            var iframeDocument, iframe = __webpack_require__(70)("iframe"),
                i = enumBugKeys.length;
            for (iframe.style.display = "none", __webpack_require__(74).appendChild(iframe), iframe.src = "javascript:", (iframeDocument = iframe.contentWindow.document).open(), iframeDocument.write("<script>document.F=Object<\/script>"), iframeDocument.close(), createDict = iframeDocument.F; i--;) delete createDict.prototype[enumBugKeys[i]];
            return createDict()
        };
    module.exports = Object.create || function(O, Properties) {
        var result;
        return null !== O ? (Empty.prototype = anObject(O), result = new Empty, Empty.prototype = null, result[IE_PROTO] = O) : result = createDict(), void 0 === Properties ? result : dPs(result, Properties)
    }
}, function(module, exports, __webpack_require__) {
    var $keys = __webpack_require__(99),
        hiddenKeys = __webpack_require__(73).concat("length", "prototype");
    exports.f = Object.getOwnPropertyNames || function(O) {
        return $keys(O, hiddenKeys)
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var global = __webpack_require__(2),
        dP = __webpack_require__(8),
        DESCRIPTORS = __webpack_require__(7),
        SPECIES = __webpack_require__(5)("species");
    module.exports = function(KEY) {
        var C = global[KEY];
        DESCRIPTORS && C && !C[SPECIES] && dP.f(C, SPECIES, {
            configurable: !0,
            get: function() {
                return this
            }
        })
    }
}, function(module, exports) {
    module.exports = function(it, Constructor, name, forbiddenField) {
        if (!(it instanceof Constructor) || void 0 !== forbiddenField && forbiddenField in it) throw TypeError(name + ": incorrect invocation!");
        return it
    }
}, function(module, exports, __webpack_require__) {
    var ctx = __webpack_require__(19),
        call = __webpack_require__(112),
        isArrayIter = __webpack_require__(85),
        anObject = __webpack_require__(1),
        toLength = __webpack_require__(6),
        getIterFn = __webpack_require__(87),
        BREAK = {},
        RETURN = {};
    (exports = module.exports = function(iterable, entries, fn, that, ITERATOR) {
        var length, step, iterator, result, iterFn = ITERATOR ? function() {
                return iterable
            } : getIterFn(iterable),
            f = ctx(fn, that, entries ? 2 : 1),
            index = 0;
        if ("function" != typeof iterFn) throw TypeError(iterable + " is not iterable!");
        if (isArrayIter(iterFn)) {
            for (length = toLength(iterable.length); length > index; index++)
                if ((result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index])) === BREAK || result === RETURN) return result
        } else
            for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;)
                if ((result = call(iterator, f, step.value, entries)) === BREAK || result === RETURN) return result
    }).BREAK = BREAK, exports.RETURN = RETURN
}, function(module, exports, __webpack_require__) {
    var redefine = __webpack_require__(12);
    module.exports = function(target, src, safe) {
        for (var key in src) redefine(target, key, src[key], safe);
        return target
    }
}, function(module, exports, __webpack_require__) {
    var isObject = __webpack_require__(4);
    module.exports = function(it, TYPE) {
        if (!isObject(it) || it._t !== TYPE) throw TypeError("Incompatible receiver, " + TYPE + " required!");
        return it
    }
}, function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_RESULT__;
    (function() {
        var root = this,
            previousUnderscore = root._,
            ArrayProto = Array.prototype,
            ObjProto = Object.prototype,
            FuncProto = Function.prototype,
            push = ArrayProto.push,
            slice = ArrayProto.slice,
            toString = ObjProto.toString,
            hasOwnProperty = ObjProto.hasOwnProperty,
            nativeIsArray = Array.isArray,
            nativeKeys = Object.keys,
            nativeBind = FuncProto.bind,
            nativeCreate = Object.create,
            Ctor = function() {},
            _ = function(obj) {
                return obj instanceof _ ? obj : this instanceof _ ? void(this._wrapped = obj) : new _(obj)
            };
        void 0 !== module && module.exports && (exports = module.exports = _), exports._ = _, _.VERSION = "1.8.3";
        var optimizeCb = function(func, context, argCount) {
                if (void 0 === context) return func;
                switch (null == argCount ? 3 : argCount) {
                    case 1:
                        return function(value) {
                            return func.call(context, value)
                        };
                    case 2:
                        return function(value, other) {
                            return func.call(context, value, other)
                        };
                    case 3:
                        return function(value, index, collection) {
                            return func.call(context, value, index, collection)
                        };
                    case 4:
                        return function(accumulator, value, index, collection) {
                            return func.call(context, accumulator, value, index, collection)
                        }
                }
                return function() {
                    return func.apply(context, arguments)
                }
            },
            cb = function(value, context, argCount) {
                return null == value ? _.identity : _.isFunction(value) ? optimizeCb(value, context, argCount) : _.isObject(value) ? _.matcher(value) : _.property(value)
            };
        _.iteratee = function(value, context) {
            return cb(value, context, 1 / 0)
        };
        var createAssigner = function(keysFunc, undefinedOnly) {
                return function(obj) {
                    var length = arguments.length;
                    if (length < 2 || null == obj) return obj;
                    for (var index = 1; index < length; index++)
                        for (var source = arguments[index], keys = keysFunc(source), l = keys.length, i = 0; i < l; i++) {
                            var key = keys[i];
                            undefinedOnly && void 0 !== obj[key] || (obj[key] = source[key])
                        }
                    return obj
                }
            },
            baseCreate = function(prototype) {
                if (!_.isObject(prototype)) return {};
                if (nativeCreate) return nativeCreate(prototype);
                Ctor.prototype = prototype;
                var result = new Ctor;
                return Ctor.prototype = null, result
            },
            property = function(key) {
                return function(obj) {
                    return null == obj ? void 0 : obj[key]
                }
            },
            MAX_ARRAY_INDEX = Math.pow(2, 53) - 1,
            getLength = property("length"),
            isArrayLike = function(collection) {
                var length = getLength(collection);
                return "number" == typeof length && length >= 0 && length <= MAX_ARRAY_INDEX
            };

        function createReduce(dir) {
            return function(obj, iteratee, memo, context) {
                iteratee = optimizeCb(iteratee, context, 4);
                var keys = !isArrayLike(obj) && _.keys(obj),
                    length = (keys || obj).length,
                    index = dir > 0 ? 0 : length - 1;
                return arguments.length < 3 && (memo = obj[keys ? keys[index] : index], index += dir),
                    function(obj, iteratee, memo, keys, index, length) {
                        for (; index >= 0 && index < length; index += dir) {
                            var currentKey = keys ? keys[index] : index;
                            memo = iteratee(memo, obj[currentKey], currentKey, obj)
                        }
                        return memo
                    }(obj, iteratee, memo, keys, index, length)
            }
        }
        _.each = _.forEach = function(obj, iteratee, context) {
            var i, length;
            if (iteratee = optimizeCb(iteratee, context), isArrayLike(obj))
                for (i = 0, length = obj.length; i < length; i++) iteratee(obj[i], i, obj);
            else {
                var keys = _.keys(obj);
                for (i = 0, length = keys.length; i < length; i++) iteratee(obj[keys[i]], keys[i], obj)
            }
            return obj
        }, _.map = _.collect = function(obj, iteratee, context) {
            iteratee = cb(iteratee, context);
            for (var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length, results = Array(length), index = 0; index < length; index++) {
                var currentKey = keys ? keys[index] : index;
                results[index] = iteratee(obj[currentKey], currentKey, obj)
            }
            return results
        }, _.reduce = _.foldl = _.inject = createReduce(1), _.reduceRight = _.foldr = createReduce(-1), _.find = _.detect = function(obj, predicate, context) {
            var key;
            if (void 0 !== (key = isArrayLike(obj) ? _.findIndex(obj, predicate, context) : _.findKey(obj, predicate, context)) && -1 !== key) return obj[key]
        }, _.filter = _.select = function(obj, predicate, context) {
            var results = [];
            return predicate = cb(predicate, context), _.each(obj, function(value, index, list) {
                predicate(value, index, list) && results.push(value)
            }), results
        }, _.reject = function(obj, predicate, context) {
            return _.filter(obj, _.negate(cb(predicate)), context)
        }, _.every = _.all = function(obj, predicate, context) {
            predicate = cb(predicate, context);
            for (var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length, index = 0; index < length; index++) {
                var currentKey = keys ? keys[index] : index;
                if (!predicate(obj[currentKey], currentKey, obj)) return !1
            }
            return !0
        }, _.some = _.any = function(obj, predicate, context) {
            predicate = cb(predicate, context);
            for (var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length, index = 0; index < length; index++) {
                var currentKey = keys ? keys[index] : index;
                if (predicate(obj[currentKey], currentKey, obj)) return !0
            }
            return !1
        }, _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
            return isArrayLike(obj) || (obj = _.values(obj)), ("number" != typeof fromIndex || guard) && (fromIndex = 0), _.indexOf(obj, item, fromIndex) >= 0
        }, _.invoke = function(obj, method) {
            var args = slice.call(arguments, 2),
                isFunc = _.isFunction(method);
            return _.map(obj, function(value) {
                var func = isFunc ? method : value[method];
                return null == func ? func : func.apply(value, args)
            })
        }, _.pluck = function(obj, key) {
            return _.map(obj, _.property(key))
        }, _.where = function(obj, attrs) {
            return _.filter(obj, _.matcher(attrs))
        }, _.findWhere = function(obj, attrs) {
            return _.find(obj, _.matcher(attrs))
        }, _.max = function(obj, iteratee, context) {
            var value, computed, result = -1 / 0,
                lastComputed = -1 / 0;
            if (null == iteratee && null != obj)
                for (var i = 0, length = (obj = isArrayLike(obj) ? obj : _.values(obj)).length; i < length; i++)(value = obj[i]) > result && (result = value);
            else iteratee = cb(iteratee, context), _.each(obj, function(value, index, list) {
                ((computed = iteratee(value, index, list)) > lastComputed || computed === -1 / 0 && result === -1 / 0) && (result = value, lastComputed = computed)
            });
            return result
        }, _.min = function(obj, iteratee, context) {
            var value, computed, result = 1 / 0,
                lastComputed = 1 / 0;
            if (null == iteratee && null != obj)
                for (var i = 0, length = (obj = isArrayLike(obj) ? obj : _.values(obj)).length; i < length; i++)(value = obj[i]) < result && (result = value);
            else iteratee = cb(iteratee, context), _.each(obj, function(value, index, list) {
                ((computed = iteratee(value, index, list)) < lastComputed || computed === 1 / 0 && result === 1 / 0) && (result = value, lastComputed = computed)
            });
            return result
        }, _.shuffle = function(obj) {
            for (var rand, set = isArrayLike(obj) ? obj : _.values(obj), length = set.length, shuffled = Array(length), index = 0; index < length; index++)(rand = _.random(0, index)) !== index && (shuffled[index] = shuffled[rand]), shuffled[rand] = set[index];
            return shuffled
        }, _.sample = function(obj, n, guard) {
            return null == n || guard ? (isArrayLike(obj) || (obj = _.values(obj)), obj[_.random(obj.length - 1)]) : _.shuffle(obj).slice(0, Math.max(0, n))
        }, _.sortBy = function(obj, iteratee, context) {
            return iteratee = cb(iteratee, context), _.pluck(_.map(obj, function(value, index, list) {
                return {
                    value: value,
                    index: index,
                    criteria: iteratee(value, index, list)
                }
            }).sort(function(left, right) {
                var a = left.criteria,
                    b = right.criteria;
                if (a !== b) {
                    if (a > b || void 0 === a) return 1;
                    if (a < b || void 0 === b) return -1
                }
                return left.index - right.index
            }), "value")
        };
        var group = function(behavior) {
            return function(obj, iteratee, context) {
                var result = {};
                return iteratee = cb(iteratee, context), _.each(obj, function(value, index) {
                    var key = iteratee(value, index, obj);
                    behavior(result, value, key)
                }), result
            }
        };
        _.groupBy = group(function(result, value, key) {
            _.has(result, key) ? result[key].push(value) : result[key] = [value]
        }), _.indexBy = group(function(result, value, key) {
            result[key] = value
        }), _.countBy = group(function(result, value, key) {
            _.has(result, key) ? result[key]++ : result[key] = 1
        }), _.toArray = function(obj) {
            return obj ? _.isArray(obj) ? slice.call(obj) : isArrayLike(obj) ? _.map(obj, _.identity) : _.values(obj) : []
        }, _.size = function(obj) {
            return null == obj ? 0 : isArrayLike(obj) ? obj.length : _.keys(obj).length
        }, _.partition = function(obj, predicate, context) {
            predicate = cb(predicate, context);
            var pass = [],
                fail = [];
            return _.each(obj, function(value, key, obj) {
                (predicate(value, key, obj) ? pass : fail).push(value)
            }), [pass, fail]
        }, _.first = _.head = _.take = function(array, n, guard) {
            if (null != array) return null == n || guard ? array[0] : _.initial(array, array.length - n)
        }, _.initial = function(array, n, guard) {
            return slice.call(array, 0, Math.max(0, array.length - (null == n || guard ? 1 : n)))
        }, _.last = function(array, n, guard) {
            if (null != array) return null == n || guard ? array[array.length - 1] : _.rest(array, Math.max(0, array.length - n))
        }, _.rest = _.tail = _.drop = function(array, n, guard) {
            return slice.call(array, null == n || guard ? 1 : n)
        }, _.compact = function(array) {
            return _.filter(array, _.identity)
        };
        var flatten = function(input, shallow, strict, startIndex) {
            for (var output = [], idx = 0, i = startIndex || 0, length = getLength(input); i < length; i++) {
                var value = input[i];
                if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
                    shallow || (value = flatten(value, shallow, strict));
                    var j = 0,
                        len = value.length;
                    for (output.length += len; j < len;) output[idx++] = value[j++]
                } else strict || (output[idx++] = value)
            }
            return output
        };

        function createPredicateIndexFinder(dir) {
            return function(array, predicate, context) {
                predicate = cb(predicate, context);
                for (var length = getLength(array), index = dir > 0 ? 0 : length - 1; index >= 0 && index < length; index += dir)
                    if (predicate(array[index], index, array)) return index;
                return -1
            }
        }

        function createIndexFinder(dir, predicateFind, sortedIndex) {
            return function(array, item, idx) {
                var i = 0,
                    length = getLength(array);
                if ("number" == typeof idx) dir > 0 ? i = idx >= 0 ? idx : Math.max(idx + length, i) : length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
                else if (sortedIndex && idx && length) return array[idx = sortedIndex(array, item)] === item ? idx : -1;
                if (item != item) return (idx = predicateFind(slice.call(array, i, length), _.isNaN)) >= 0 ? idx + i : -1;
                for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir)
                    if (array[idx] === item) return idx;
                return -1
            }
        }
        _.flatten = function(array, shallow) {
            return flatten(array, shallow, !1)
        }, _.without = function(array) {
            return _.difference(array, slice.call(arguments, 1))
        }, _.uniq = _.unique = function(array, isSorted, iteratee, context) {
            _.isBoolean(isSorted) || (context = iteratee, iteratee = isSorted, isSorted = !1), null != iteratee && (iteratee = cb(iteratee, context));
            for (var result = [], seen = [], i = 0, length = getLength(array); i < length; i++) {
                var value = array[i],
                    computed = iteratee ? iteratee(value, i, array) : value;
                isSorted ? (i && seen === computed || result.push(value), seen = computed) : iteratee ? _.contains(seen, computed) || (seen.push(computed), result.push(value)) : _.contains(result, value) || result.push(value)
            }
            return result
        }, _.union = function() {
            return _.uniq(flatten(arguments, !0, !0))
        }, _.intersection = function(array) {
            for (var result = [], argsLength = arguments.length, i = 0, length = getLength(array); i < length; i++) {
                var item = array[i];
                if (!_.contains(result, item)) {
                    for (var j = 1; j < argsLength && _.contains(arguments[j], item); j++);
                    j === argsLength && result.push(item)
                }
            }
            return result
        }, _.difference = function(array) {
            var rest = flatten(arguments, !0, !0, 1);
            return _.filter(array, function(value) {
                return !_.contains(rest, value)
            })
        }, _.zip = function() {
            return _.unzip(arguments)
        }, _.unzip = function(array) {
            for (var length = array && _.max(array, getLength).length || 0, result = Array(length), index = 0; index < length; index++) result[index] = _.pluck(array, index);
            return result
        }, _.object = function(list, values) {
            for (var result = {}, i = 0, length = getLength(list); i < length; i++) values ? result[list[i]] = values[i] : result[list[i][0]] = list[i][1];
            return result
        }, _.findIndex = createPredicateIndexFinder(1), _.findLastIndex = createPredicateIndexFinder(-1), _.sortedIndex = function(array, obj, iteratee, context) {
            for (var value = (iteratee = cb(iteratee, context, 1))(obj), low = 0, high = getLength(array); low < high;) {
                var mid = Math.floor((low + high) / 2);
                iteratee(array[mid]) < value ? low = mid + 1 : high = mid
            }
            return low
        }, _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex), _.lastIndexOf = createIndexFinder(-1, _.findLastIndex), _.range = function(start, stop, step) {
            null == stop && (stop = start || 0, start = 0), step = step || 1;
            for (var length = Math.max(Math.ceil((stop - start) / step), 0), range = Array(length), idx = 0; idx < length; idx++, start += step) range[idx] = start;
            return range
        };
        var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
            if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
            var self = baseCreate(sourceFunc.prototype),
                result = sourceFunc.apply(self, args);
            return _.isObject(result) ? result : self
        };
        _.bind = function(func, context) {
            if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
            if (!_.isFunction(func)) throw new TypeError("Bind must be called on a function");
            var args = slice.call(arguments, 2),
                bound = function() {
                    return executeBound(func, bound, context, this, args.concat(slice.call(arguments)))
                };
            return bound
        }, _.partial = function(func) {
            var boundArgs = slice.call(arguments, 1),
                bound = function() {
                    for (var position = 0, length = boundArgs.length, args = Array(length), i = 0; i < length; i++) args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
                    for (; position < arguments.length;) args.push(arguments[position++]);
                    return executeBound(func, bound, this, this, args)
                };
            return bound
        }, _.bindAll = function(obj) {
            var i, key, length = arguments.length;
            if (length <= 1) throw new Error("bindAll must be passed function names");
            for (i = 1; i < length; i++) obj[key = arguments[i]] = _.bind(obj[key], obj);
            return obj
        }, _.memoize = function(func, hasher) {
            var memoize = function(key) {
                var cache = memoize.cache,
                    address = "" + (hasher ? hasher.apply(this, arguments) : key);
                return _.has(cache, address) || (cache[address] = func.apply(this, arguments)), cache[address]
            };
            return memoize.cache = {}, memoize
        }, _.delay = function(func, wait) {
            var args = slice.call(arguments, 2);
            return setTimeout(function() {
                return func.apply(null, args)
            }, wait)
        }, _.defer = _.partial(_.delay, _, 1), _.throttle = function(func, wait, options) {
            var context, args, result, timeout = null,
                previous = 0;
            options || (options = {});
            var later = function() {
                previous = !1 === options.leading ? 0 : _.now(), timeout = null, result = func.apply(context, args), timeout || (context = args = null)
            };
            return function() {
                var now = _.now();
                previous || !1 !== options.leading || (previous = now);
                var remaining = wait - (now - previous);
                return context = this, args = arguments, remaining <= 0 || remaining > wait ? (timeout && (clearTimeout(timeout), timeout = null), previous = now, result = func.apply(context, args), timeout || (context = args = null)) : timeout || !1 === options.trailing || (timeout = setTimeout(later, remaining)), result
            }
        }, _.debounce = function(func, wait, immediate) {
            var timeout, args, context, timestamp, result, later = function() {
                var last = _.now() - timestamp;
                last < wait && last >= 0 ? timeout = setTimeout(later, wait - last) : (timeout = null, immediate || (result = func.apply(context, args), timeout || (context = args = null)))
            };
            return function() {
                context = this, args = arguments, timestamp = _.now();
                var callNow = immediate && !timeout;
                return timeout || (timeout = setTimeout(later, wait)), callNow && (result = func.apply(context, args), context = args = null), result
            }
        }, _.wrap = function(func, wrapper) {
            return _.partial(wrapper, func)
        }, _.negate = function(predicate) {
            return function() {
                return !predicate.apply(this, arguments)
            }
        }, _.compose = function() {
            var args = arguments,
                start = args.length - 1;
            return function() {
                for (var i = start, result = args[start].apply(this, arguments); i--;) result = args[i].call(this, result);
                return result
            }
        }, _.after = function(times, func) {
            return function() {
                if (--times < 1) return func.apply(this, arguments)
            }
        }, _.before = function(times, func) {
            var memo;
            return function() {
                return --times > 0 && (memo = func.apply(this, arguments)), times <= 1 && (func = null), memo
            }
        }, _.once = _.partial(_.before, 2);
        var hasEnumBug = !{
                toString: null
            }.propertyIsEnumerable("toString"),
            nonEnumerableProps = ["valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"];

        function collectNonEnumProps(obj, keys) {
            var nonEnumIdx = nonEnumerableProps.length,
                constructor = obj.constructor,
                proto = _.isFunction(constructor) && constructor.prototype || ObjProto,
                prop = "constructor";
            for (_.has(obj, prop) && !_.contains(keys, prop) && keys.push(prop); nonEnumIdx--;)(prop = nonEnumerableProps[nonEnumIdx]) in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop) && keys.push(prop)
        }
        _.keys = function(obj) {
            if (!_.isObject(obj)) return [];
            if (nativeKeys) return nativeKeys(obj);
            var keys = [];
            for (var key in obj) _.has(obj, key) && keys.push(key);
            return hasEnumBug && collectNonEnumProps(obj, keys), keys
        }, _.allKeys = function(obj) {
            if (!_.isObject(obj)) return [];
            var keys = [];
            for (var key in obj) keys.push(key);
            return hasEnumBug && collectNonEnumProps(obj, keys), keys
        }, _.values = function(obj) {
            for (var keys = _.keys(obj), length = keys.length, values = Array(length), i = 0; i < length; i++) values[i] = obj[keys[i]];
            return values
        }, _.mapObject = function(obj, iteratee, context) {
            iteratee = cb(iteratee, context);
            for (var currentKey, keys = _.keys(obj), length = keys.length, results = {}, index = 0; index < length; index++) results[currentKey = keys[index]] = iteratee(obj[currentKey], currentKey, obj);
            return results
        }, _.pairs = function(obj) {
            for (var keys = _.keys(obj), length = keys.length, pairs = Array(length), i = 0; i < length; i++) pairs[i] = [keys[i], obj[keys[i]]];
            return pairs
        }, _.invert = function(obj) {
            for (var result = {}, keys = _.keys(obj), i = 0, length = keys.length; i < length; i++) result[obj[keys[i]]] = keys[i];
            return result
        }, _.functions = _.methods = function(obj) {
            var names = [];
            for (var key in obj) _.isFunction(obj[key]) && names.push(key);
            return names.sort()
        }, _.extend = createAssigner(_.allKeys), _.extendOwn = _.assign = createAssigner(_.keys), _.findKey = function(obj, predicate, context) {
            predicate = cb(predicate, context);
            for (var key, keys = _.keys(obj), i = 0, length = keys.length; i < length; i++)
                if (predicate(obj[key = keys[i]], key, obj)) return key
        }, _.pick = function(object, oiteratee, context) {
            var iteratee, keys, result = {},
                obj = object;
            if (null == obj) return result;
            _.isFunction(oiteratee) ? (keys = _.allKeys(obj), iteratee = optimizeCb(oiteratee, context)) : (keys = flatten(arguments, !1, !1, 1), iteratee = function(value, key, obj) {
                return key in obj
            }, obj = Object(obj));
            for (var i = 0, length = keys.length; i < length; i++) {
                var key = keys[i],
                    value = obj[key];
                iteratee(value, key, obj) && (result[key] = value)
            }
            return result
        }, _.omit = function(obj, iteratee, context) {
            if (_.isFunction(iteratee)) iteratee = _.negate(iteratee);
            else {
                var keys = _.map(flatten(arguments, !1, !1, 1), String);
                iteratee = function(value, key) {
                    return !_.contains(keys, key)
                }
            }
            return _.pick(obj, iteratee, context)
        }, _.defaults = createAssigner(_.allKeys, !0), _.create = function(prototype, props) {
            var result = baseCreate(prototype);
            return props && _.extendOwn(result, props), result
        }, _.clone = function(obj) {
            return _.isObject(obj) ? _.isArray(obj) ? obj.slice() : _.extend({}, obj) : obj
        }, _.tap = function(obj, interceptor) {
            return interceptor(obj), obj
        }, _.isMatch = function(object, attrs) {
            var keys = _.keys(attrs),
                length = keys.length;
            if (null == object) return !length;
            for (var obj = Object(object), i = 0; i < length; i++) {
                var key = keys[i];
                if (attrs[key] !== obj[key] || !(key in obj)) return !1
            }
            return !0
        };
        var eq = function(a, b, aStack, bStack) {
            if (a === b) return 0 !== a || 1 / a == 1 / b;
            if (null == a || null == b) return a === b;
            a instanceof _ && (a = a._wrapped), b instanceof _ && (b = b._wrapped);
            var className = toString.call(a);
            if (className !== toString.call(b)) return !1;
            switch (className) {
                case "[object RegExp]":
                case "[object String]":
                    return "" + a == "" + b;
                case "[object Number]":
                    return +a != +a ? +b != +b : 0 == +a ? 1 / +a == 1 / b : +a == +b;
                case "[object Date]":
                case "[object Boolean]":
                    return +a == +b
            }
            var areArrays = "[object Array]" === className;
            if (!areArrays) {
                if ("object" != typeof a || "object" != typeof b) return !1;
                var aCtor = a.constructor,
                    bCtor = b.constructor;
                if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor) && "constructor" in a && "constructor" in b) return !1
            }
            aStack = aStack || [], bStack = bStack || [];
            for (var length = aStack.length; length--;)
                if (aStack[length] === a) return bStack[length] === b;
            if (aStack.push(a), bStack.push(b), areArrays) {
                if ((length = a.length) !== b.length) return !1;
                for (; length--;)
                    if (!eq(a[length], b[length], aStack, bStack)) return !1
            } else {
                var key, keys = _.keys(a);
                if (length = keys.length, _.keys(b).length !== length) return !1;
                for (; length--;)
                    if (key = keys[length], !_.has(b, key) || !eq(a[key], b[key], aStack, bStack)) return !1
            }
            return aStack.pop(), bStack.pop(), !0
        };
        _.isEqual = function(a, b) {
            return eq(a, b)
        }, _.isEmpty = function(obj) {
            return null == obj || (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj)) ? 0 === obj.length : 0 === _.keys(obj).length)
        }, _.isElement = function(obj) {
            return !(!obj || 1 !== obj.nodeType)
        }, _.isArray = nativeIsArray || function(obj) {
            return "[object Array]" === toString.call(obj)
        }, _.isObject = function(obj) {
            var type = typeof obj;
            return "function" === type || "object" === type && !!obj
        }, _.each(["Arguments", "Function", "String", "Number", "Date", "RegExp", "Error"], function(name) {
            _["is" + name] = function(obj) {
                return toString.call(obj) === "[object " + name + "]"
            }
        }), _.isArguments(arguments) || (_.isArguments = function(obj) {
            return _.has(obj, "callee")
        }), "function" != typeof /./ && "object" != typeof Int8Array && (_.isFunction = function(obj) {
            return "function" == typeof obj || !1
        }), _.isFinite = function(obj) {
            return isFinite(obj) && !isNaN(parseFloat(obj))
        }, _.isNaN = function(obj) {
            return _.isNumber(obj) && obj !== +obj
        }, _.isBoolean = function(obj) {
            return !0 === obj || !1 === obj || "[object Boolean]" === toString.call(obj)
        }, _.isNull = function(obj) {
            return null === obj
        }, _.isUndefined = function(obj) {
            return void 0 === obj
        }, _.has = function(obj, key) {
            return null != obj && hasOwnProperty.call(obj, key)
        }, _.noConflict = function() {
            return root._ = previousUnderscore, this
        }, _.identity = function(value) {
            return value
        }, _.constant = function(value) {
            return function() {
                return value
            }
        }, _.noop = function() {}, _.property = property, _.propertyOf = function(obj) {
            return null == obj ? function() {} : function(key) {
                return obj[key]
            }
        }, _.matcher = _.matches = function(attrs) {
            return attrs = _.extendOwn({}, attrs),
                function(obj) {
                    return _.isMatch(obj, attrs)
                }
        }, _.times = function(n, iteratee, context) {
            var accum = Array(Math.max(0, n));
            iteratee = optimizeCb(iteratee, context, 1);
            for (var i = 0; i < n; i++) accum[i] = iteratee(i);
            return accum
        }, _.random = function(min, max) {
            return null == max && (max = min, min = 0), min + Math.floor(Math.random() * (max - min + 1))
        }, _.now = Date.now || function() {
            return (new Date).getTime()
        };
        var escapeMap = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#x27;",
                "`": "&#x60;"
            },
            unescapeMap = _.invert(escapeMap),
            createEscaper = function(map) {
                var escaper = function(match) {
                        return map[match]
                    },
                    source = "(?:" + _.keys(map).join("|") + ")",
                    testRegexp = RegExp(source),
                    replaceRegexp = RegExp(source, "g");
                return function(string) {
                    return string = null == string ? "" : "" + string, testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string
                }
            };
        _.escape = createEscaper(escapeMap), _.unescape = createEscaper(unescapeMap), _.result = function(object, property, fallback) {
            var value = null == object ? void 0 : object[property];
            return void 0 === value && (value = fallback), _.isFunction(value) ? value.call(object) : value
        };
        var idCounter = 0;
        _.uniqueId = function(prefix) {
            var id = ++idCounter + "";
            return prefix ? prefix + id : id
        }, _.templateSettings = {
            evaluate: /<%([\s\S]+?)%>/g,
            interpolate: /<%=([\s\S]+?)%>/g,
            escape: /<%-([\s\S]+?)%>/g
        };
        var noMatch = /(.)^/,
            escapes = {
                "'": "'",
                "\\": "\\",
                "\r": "r",
                "\n": "n",
                "\u2028": "u2028",
                "\u2029": "u2029"
            },
            escaper = /\\|'|\r|\n|\u2028|\u2029/g,
            escapeChar = function(match) {
                return "\\" + escapes[match]
            };
        _.template = function(text, settings, oldSettings) {
            !settings && oldSettings && (settings = oldSettings), settings = _.defaults({}, settings, _.templateSettings);
            var matcher = RegExp([(settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source].join("|") + "|$", "g"),
                index = 0,
                source = "__p+='";
            text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
                return source += text.slice(index, offset).replace(escaper, escapeChar), index = offset + match.length, escape ? source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'" : interpolate ? source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'" : evaluate && (source += "';\n" + evaluate + "\n__p+='"), match
            }), source += "';\n", settings.variable || (source = "with(obj||{}){\n" + source + "}\n"), source = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
            try {
                var render = new Function(settings.variable || "obj", "_", source)
            } catch (e) {
                throw e.source = source, e
            }
            var template = function(data) {
                    return render.call(this, data, _)
                },
                argument = settings.variable || "obj";
            return template.source = "function(" + argument + "){\n" + source + "}", template
        }, _.chain = function(obj) {
            var instance = _(obj);
            return instance._chain = !0, instance
        };
        var result = function(instance, obj) {
            return instance._chain ? _(obj).chain() : obj
        };
        _.mixin = function(obj) {
            _.each(_.functions(obj), function(name) {
                var func = _[name] = obj[name];
                _.prototype[name] = function() {
                    var args = [this._wrapped];
                    return push.apply(args, arguments), result(this, func.apply(_, args))
                }
            })
        }, _.mixin(_), _.each(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(name) {
            var method = ArrayProto[name];
            _.prototype[name] = function() {
                var obj = this._wrapped;
                return method.apply(obj, arguments), "shift" !== name && "splice" !== name || 0 !== obj.length || delete obj[0], result(this, obj)
            }
        }), _.each(["concat", "join", "slice"], function(name) {
            var method = ArrayProto[name];
            _.prototype[name] = function() {
                return result(this, method.apply(this._wrapped, arguments))
            }
        }), _.prototype.value = function() {
            return this._wrapped
        }, _.prototype.valueOf = _.prototype.toJSON = _.prototype.value, _.prototype.toString = function() {
            return "" + this._wrapped
        }, void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
            return _
        }.apply(exports, [])) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)
    }).call(this)
}, function(module, exports, __webpack_require__) {
    var def = __webpack_require__(8).f,
        has = __webpack_require__(14),
        TAG = __webpack_require__(5)("toStringTag");
    module.exports = function(it, tag, stat) {
        it && !has(it = stat ? it : it.prototype, TAG) && def(it, TAG, {
            configurable: !0,
            value: tag
        })
    }
}, function(module, exports, __webpack_require__) {
    var cof = __webpack_require__(20),
        TAG = __webpack_require__(5)("toStringTag"),
        ARG = "Arguments" == cof(function() {
            return arguments
        }());
    module.exports = function(it) {
        var O, T, B;
        return void 0 === it ? "Undefined" : null === it ? "Null" : "string" == typeof(T = function(it, key) {
            try {
                return it[key]
            } catch (e) {}
        }(O = Object(it), TAG)) ? T : ARG ? cof(O) : "Object" == (B = cof(O)) && "function" == typeof O.callee ? "Arguments" : B
    }
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        defined = __webpack_require__(24),
        fails = __webpack_require__(3),
        spaces = __webpack_require__(76),
        space = "[" + spaces + "]",
        ltrim = RegExp("^" + space + space + "*"),
        rtrim = RegExp(space + space + "*$"),
        exporter = function(KEY, exec, ALIAS) {
            var exp = {},
                FORCE = fails(function() {
                    return !!spaces[KEY]() || "​" != "​" [KEY]()
                }),
                fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
            ALIAS && (exp[ALIAS] = fn), $export($export.P + $export.F * FORCE, "String", exp)
        },
        trim = exporter.trim = function(string, TYPE) {
            return string = String(defined(string)), 1 & TYPE && (string = string.replace(ltrim, "")), 2 & TYPE && (string = string.replace(rtrim, "")), string
        };
    module.exports = exporter
}, function(module, exports) {
    module.exports = {}
}, function(module, exports, __webpack_require__) {
    var core = __webpack_require__(18),
        global = __webpack_require__(2),
        store = global["__core-js_shared__"] || (global["__core-js_shared__"] = {});
    (module.exports = function(key, value) {
        return store[key] || (store[key] = void 0 !== value ? value : {})
    })("versions", []).push({
        version: core.version,
        mode: __webpack_require__(29) ? "pure" : "global",
        copyright: "© 2019 Denis Pushkarev (zloirock.ru)"
    })
}, function(module, exports, __webpack_require__) {
    var cof = __webpack_require__(20);
    module.exports = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
        return "String" == cof(it) ? it.split("") : Object(it)
    }
}, function(module, exports) {
    exports.f = {}.propertyIsEnumerable
}, function(module, exports, __webpack_require__) {
    "use strict";
    var anObject = __webpack_require__(1);
    module.exports = function() {
        var that = anObject(this),
            result = "";
        return that.global && (result += "g"), that.ignoreCase && (result += "i"), that.multiline && (result += "m"), that.unicode && (result += "u"), that.sticky && (result += "y"), result
    }
}, function(module, exports, __webpack_require__) {
    var anObject = __webpack_require__(1),
        aFunction = __webpack_require__(10),
        SPECIES = __webpack_require__(5)("species");
    module.exports = function(O, D) {
        var S, C = anObject(O).constructor;
        return void 0 === C || void 0 == (S = anObject(C)[SPECIES]) ? D : aFunction(S)
    }
}, function(module, exports, __webpack_require__) {
    (function(global) {
        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__, factory, root;
        factory = function(root, Backbone, _, $) {
            var previousBackbone = root.Backbone,
                slice = Array.prototype.slice;
            Backbone.VERSION = "1.2.3", Backbone.$ = $, Backbone.noConflict = function() {
                return root.Backbone = previousBackbone, this
            }, Backbone.emulateHTTP = !1, Backbone.emulateJSON = !1;
            var addUnderscoreMethods = function(Class, methods, attribute) {
                    _.each(methods, function(length, method) {
                        _[method] && (Class.prototype[method] = function(length, method, attribute) {
                            switch (length) {
                                case 1:
                                    return function() {
                                        return _[method](this[attribute])
                                    };
                                case 2:
                                    return function(value) {
                                        return _[method](this[attribute], value)
                                    };
                                case 3:
                                    return function(iteratee, context) {
                                        return _[method](this[attribute], cb(iteratee, this), context)
                                    };
                                case 4:
                                    return function(iteratee, defaultVal, context) {
                                        return _[method](this[attribute], cb(iteratee, this), defaultVal, context)
                                    };
                                default:
                                    return function() {
                                        var args = slice.call(arguments);
                                        return args.unshift(this[attribute]), _[method].apply(_, args)
                                    }
                            }
                        }(length, method, attribute))
                    })
                },
                cb = function(iteratee, instance) {
                    return _.isFunction(iteratee) ? iteratee : _.isObject(iteratee) && !instance._isModel(iteratee) ? modelMatcher(iteratee) : _.isString(iteratee) ? function(model) {
                        return model.get(iteratee)
                    } : iteratee
                },
                modelMatcher = function(attrs) {
                    var matcher = _.matches(attrs);
                    return function(model) {
                        return matcher(model.attributes)
                    }
                },
                Events = Backbone.Events = {},
                eventSplitter = /\s+/,
                eventsApi = function(iteratee, events, name, callback, opts) {
                    var names, i = 0;
                    if (name && "object" == typeof name) {
                        void 0 !== callback && "context" in opts && void 0 === opts.context && (opts.context = callback);
                        for (names = _.keys(name); i < names.length; i++) events = eventsApi(iteratee, events, names[i], name[names[i]], opts)
                    } else if (name && eventSplitter.test(name))
                        for (names = name.split(eventSplitter); i < names.length; i++) events = iteratee(events, names[i], callback, opts);
                    else events = iteratee(events, name, callback, opts);
                    return events
                };
            Events.on = function(name, callback, context) {
                return internalOn(this, name, callback, context)
            };
            var internalOn = function(obj, name, callback, context, listening) {
                (obj._events = eventsApi(onApi, obj._events || {}, name, callback, {
                    context: context,
                    ctx: obj,
                    listening: listening
                }), listening) && ((obj._listeners || (obj._listeners = {}))[listening.id] = listening);
                return obj
            };
            Events.listenTo = function(obj, name, callback) {
                if (!obj) return this;
                var id = obj._listenId || (obj._listenId = _.uniqueId("l")),
                    listeningTo = this._listeningTo || (this._listeningTo = {}),
                    listening = listeningTo[id];
                if (!listening) {
                    var thisId = this._listenId || (this._listenId = _.uniqueId("l"));
                    listening = listeningTo[id] = {
                        obj: obj,
                        objId: id,
                        id: thisId,
                        listeningTo: listeningTo,
                        count: 0
                    }
                }
                return internalOn(obj, name, callback, this, listening), this
            };
            var onApi = function(events, name, callback, options) {
                if (callback) {
                    var handlers = events[name] || (events[name] = []),
                        context = options.context,
                        ctx = options.ctx,
                        listening = options.listening;
                    listening && listening.count++, handlers.push({
                        callback: callback,
                        context: context,
                        ctx: context || ctx,
                        listening: listening
                    })
                }
                return events
            };
            Events.off = function(name, callback, context) {
                return this._events ? (this._events = eventsApi(offApi, this._events, name, callback, {
                    context: context,
                    listeners: this._listeners
                }), this) : this
            }, Events.stopListening = function(obj, name, callback) {
                var listeningTo = this._listeningTo;
                if (!listeningTo) return this;
                for (var ids = obj ? [obj._listenId] : _.keys(listeningTo), i = 0; i < ids.length; i++) {
                    var listening = listeningTo[ids[i]];
                    if (!listening) break;
                    listening.obj.off(name, callback, this)
                }
                return _.isEmpty(listeningTo) && (this._listeningTo = void 0), this
            };
            var offApi = function(events, name, callback, options) {
                if (events) {
                    var listening, i = 0,
                        context = options.context,
                        listeners = options.listeners;
                    if (name || callback || context) {
                        for (var names = name ? [name] : _.keys(events); i < names.length; i++) {
                            var handlers = events[name = names[i]];
                            if (!handlers) break;
                            for (var remaining = [], j = 0; j < handlers.length; j++) {
                                var handler = handlers[j];
                                callback && callback !== handler.callback && callback !== handler.callback._callback || context && context !== handler.context ? remaining.push(handler) : (listening = handler.listening) && 0 == --listening.count && (delete listeners[listening.id], delete listening.listeningTo[listening.objId])
                            }
                            remaining.length ? events[name] = remaining : delete events[name]
                        }
                        return _.size(events) ? events : void 0
                    }
                    for (var ids = _.keys(listeners); i < ids.length; i++) delete listeners[(listening = listeners[ids[i]]).id], delete listening.listeningTo[listening.objId]
                }
            };
            Events.once = function(name, callback, context) {
                var events = eventsApi(onceMap, {}, name, callback, _.bind(this.off, this));
                return this.on(events, void 0, context)
            }, Events.listenToOnce = function(obj, name, callback) {
                var events = eventsApi(onceMap, {}, name, callback, _.bind(this.stopListening, this, obj));
                return this.listenTo(obj, events)
            };
            var onceMap = function(map, name, callback, offer) {
                if (callback) {
                    var once = map[name] = _.once(function() {
                        offer(name, once), callback.apply(this, arguments)
                    });
                    once._callback = callback
                }
                return map
            };
            Events.trigger = function(name) {
                if (!this._events) return this;
                for (var length = Math.max(0, arguments.length - 1), args = Array(length), i = 0; i < length; i++) args[i] = arguments[i + 1];
                return eventsApi(triggerApi, this._events, name, void 0, args), this
            };
            var triggerApi = function(objEvents, name, cb, args) {
                    if (objEvents) {
                        var events = objEvents[name],
                            allEvents = objEvents.all;
                        events && allEvents && (allEvents = allEvents.slice()), events && triggerEvents(events, args), allEvents && triggerEvents(allEvents, [name].concat(args))
                    }
                    return objEvents
                },
                triggerEvents = function(events, args) {
                    var ev, i = -1,
                        l = events.length,
                        a1 = args[0],
                        a2 = args[1],
                        a3 = args[2];
                    switch (args.length) {
                        case 0:
                            for (; ++i < l;)(ev = events[i]).callback.call(ev.ctx);
                            return;
                        case 1:
                            for (; ++i < l;)(ev = events[i]).callback.call(ev.ctx, a1);
                            return;
                        case 2:
                            for (; ++i < l;)(ev = events[i]).callback.call(ev.ctx, a1, a2);
                            return;
                        case 3:
                            for (; ++i < l;)(ev = events[i]).callback.call(ev.ctx, a1, a2, a3);
                            return;
                        default:
                            for (; ++i < l;)(ev = events[i]).callback.apply(ev.ctx, args);
                            return
                    }
                };
            Events.bind = Events.on, Events.unbind = Events.off, _.extend(Backbone, Events);
            var Model = Backbone.Model = function(attributes, options) {
                var attrs = attributes || {};
                options || (options = {}), this.cid = _.uniqueId(this.cidPrefix), this.attributes = {}, options.collection && (this.collection = options.collection), options.parse && (attrs = this.parse(attrs, options) || {}), attrs = _.defaults({}, attrs, _.result(this, "defaults")), this.set(attrs, options), this.changed = {}, this.initialize.apply(this, arguments)
            };
            _.extend(Model.prototype, Events, {
                changed: null,
                validationError: null,
                idAttribute: "id",
                cidPrefix: "c",
                initialize: function() {},
                toJSON: function(options) {
                    return _.clone(this.attributes)
                },
                sync: function() {
                    return Backbone.sync.apply(this, arguments)
                },
                get: function(attr) {
                    return this.attributes[attr]
                },
                escape: function(attr) {
                    return _.escape(this.get(attr))
                },
                has: function(attr) {
                    return null != this.get(attr)
                },
                matches: function(attrs) {
                    return !!_.iteratee(attrs, this)(this.attributes)
                },
                set: function(key, val, options) {
                    if (null == key) return this;
                    var attrs;
                    if ("object" == typeof key ? (attrs = key, options = val) : (attrs = {})[key] = val, options || (options = {}), !this._validate(attrs, options)) return !1;
                    var unset = options.unset,
                        silent = options.silent,
                        changes = [],
                        changing = this._changing;
                    this._changing = !0, changing || (this._previousAttributes = _.clone(this.attributes), this.changed = {});
                    var current = this.attributes,
                        changed = this.changed,
                        prev = this._previousAttributes;
                    for (var attr in attrs) val = attrs[attr], _.isEqual(current[attr], val) || changes.push(attr), _.isEqual(prev[attr], val) ? delete changed[attr] : changed[attr] = val, unset ? delete current[attr] : current[attr] = val;
                    if (this.id = this.get(this.idAttribute), !silent) {
                        changes.length && (this._pending = options);
                        for (var i = 0; i < changes.length; i++) this.trigger("change:" + changes[i], this, current[changes[i]], options)
                    }
                    if (changing) return this;
                    if (!silent)
                        for (; this._pending;) options = this._pending, this._pending = !1, this.trigger("change", this, options);
                    return this._pending = !1, this._changing = !1, this
                },
                unset: function(attr, options) {
                    return this.set(attr, void 0, _.extend({}, options, {
                        unset: !0
                    }))
                },
                clear: function(options) {
                    var attrs = {};
                    for (var key in this.attributes) attrs[key] = void 0;
                    return this.set(attrs, _.extend({}, options, {
                        unset: !0
                    }))
                },
                hasChanged: function(attr) {
                    return null == attr ? !_.isEmpty(this.changed) : _.has(this.changed, attr)
                },
                changedAttributes: function(diff) {
                    if (!diff) return !!this.hasChanged() && _.clone(this.changed);
                    var old = this._changing ? this._previousAttributes : this.attributes,
                        changed = {};
                    for (var attr in diff) {
                        var val = diff[attr];
                        _.isEqual(old[attr], val) || (changed[attr] = val)
                    }
                    return !!_.size(changed) && changed
                },
                previous: function(attr) {
                    return null != attr && this._previousAttributes ? this._previousAttributes[attr] : null
                },
                previousAttributes: function() {
                    return _.clone(this._previousAttributes)
                },
                fetch: function(options) {
                    var model = this,
                        success = (options = _.extend({
                            parse: !0
                        }, options)).success;
                    return options.success = function(resp) {
                        var serverAttrs = options.parse ? model.parse(resp, options) : resp;
                        if (!model.set(serverAttrs, options)) return !1;
                        success && success.call(options.context, model, resp, options), model.trigger("sync", model, resp, options)
                    }, wrapError(this, options), this.sync("read", this, options)
                },
                save: function(key, val, options) {
                    var attrs;
                    null == key || "object" == typeof key ? (attrs = key, options = val) : (attrs = {})[key] = val;
                    var wait = (options = _.extend({
                        validate: !0,
                        parse: !0
                    }, options)).wait;
                    if (attrs && !wait) {
                        if (!this.set(attrs, options)) return !1
                    } else if (!this._validate(attrs, options)) return !1;
                    var model = this,
                        success = options.success,
                        attributes = this.attributes;
                    options.success = function(resp) {
                        model.attributes = attributes;
                        var serverAttrs = options.parse ? model.parse(resp, options) : resp;
                        if (wait && (serverAttrs = _.extend({}, attrs, serverAttrs)), serverAttrs && !model.set(serverAttrs, options)) return !1;
                        success && success.call(options.context, model, resp, options), model.trigger("sync", model, resp, options)
                    }, wrapError(this, options), attrs && wait && (this.attributes = _.extend({}, attributes, attrs));
                    var method = this.isNew() ? "create" : options.patch ? "patch" : "update";
                    "patch" !== method || options.attrs || (options.attrs = attrs);
                    var xhr = this.sync(method, this, options);
                    return this.attributes = attributes, xhr
                },
                destroy: function(options) {
                    var model = this,
                        success = (options = options ? _.clone(options) : {}).success,
                        wait = options.wait,
                        destroy = function() {
                            model.stopListening(), model.trigger("destroy", model, model.collection, options)
                        };
                    options.success = function(resp) {
                        wait && destroy(), success && success.call(options.context, model, resp, options), model.isNew() || model.trigger("sync", model, resp, options)
                    };
                    var xhr = !1;
                    return this.isNew() ? _.defer(options.success) : (wrapError(this, options), xhr = this.sync("delete", this, options)), wait || destroy(), xhr
                },
                url: function() {
                    var base = _.result(this, "urlRoot") || _.result(this.collection, "url") || urlError();
                    if (this.isNew()) return base;
                    var id = this.get(this.idAttribute);
                    return base.replace(/[^\/]$/, "$&/") + encodeURIComponent(id)
                },
                parse: function(resp, options) {
                    return resp
                },
                clone: function() {
                    return new this.constructor(this.attributes)
                },
                isNew: function() {
                    return !this.has(this.idAttribute)
                },
                isValid: function(options) {
                    return this._validate({}, _.defaults({
                        validate: !0
                    }, options))
                },
                _validate: function(attrs, options) {
                    if (!options.validate || !this.validate) return !0;
                    attrs = _.extend({}, this.attributes, attrs);
                    var error = this.validationError = this.validate(attrs, options) || null;
                    return !error || (this.trigger("invalid", this, error, _.extend(options, {
                        validationError: error
                    })), !1)
                }
            });
            addUnderscoreMethods(Model, {
                keys: 1,
                values: 1,
                pairs: 1,
                invert: 1,
                pick: 0,
                omit: 0,
                chain: 1,
                isEmpty: 1
            }, "attributes");
            var Collection = Backbone.Collection = function(models, options) {
                    options || (options = {}), options.model && (this.model = options.model), void 0 !== options.comparator && (this.comparator = options.comparator), this._reset(), this.initialize.apply(this, arguments), models && this.reset(models, _.extend({
                        silent: !0
                    }, options))
                },
                setOptions = {
                    add: !0,
                    remove: !0,
                    merge: !0
                },
                addOptions = {
                    add: !0,
                    remove: !1
                },
                splice = function(array, insert, at) {
                    at = Math.min(Math.max(at, 0), array.length);
                    for (var tail = Array(array.length - at), length = insert.length, i = 0; i < tail.length; i++) tail[i] = array[i + at];
                    for (i = 0; i < length; i++) array[i + at] = insert[i];
                    for (i = 0; i < tail.length; i++) array[i + length + at] = tail[i]
                };
            _.extend(Collection.prototype, Events, {
                model: Model,
                initialize: function() {},
                toJSON: function(options) {
                    return this.map(function(model) {
                        return model.toJSON(options)
                    })
                },
                sync: function() {
                    return Backbone.sync.apply(this, arguments)
                },
                add: function(models, options) {
                    return this.set(models, _.extend({
                        merge: !1
                    }, options, addOptions))
                },
                remove: function(models, options) {
                    options = _.extend({}, options);
                    var singular = !_.isArray(models);
                    models = singular ? [models] : _.clone(models);
                    var removed = this._removeModels(models, options);
                    return !options.silent && removed && this.trigger("update", this, options), singular ? removed[0] : removed
                },
                set: function(models, options) {
                    if (null != models) {
                        (options = _.defaults({}, options, setOptions)).parse && !this._isModel(models) && (models = this.parse(models, options));
                        var singular = !_.isArray(models);
                        models = singular ? [models] : models.slice();
                        var at = options.at;
                        null != at && (at = +at), at < 0 && (at += this.length + 1);
                        for (var model, set = [], toAdd = [], toRemove = [], modelMap = {}, add = options.add, merge = options.merge, remove = options.remove, sort = !1, sortable = this.comparator && null == at && !1 !== options.sort, sortAttr = _.isString(this.comparator) ? this.comparator : null, i = 0; i < models.length; i++) {
                            model = models[i];
                            var existing = this.get(model);
                            if (existing) {
                                if (merge && model !== existing) {
                                    var attrs = this._isModel(model) ? model.attributes : model;
                                    options.parse && (attrs = existing.parse(attrs, options)), existing.set(attrs, options), sortable && !sort && (sort = existing.hasChanged(sortAttr))
                                }
                                modelMap[existing.cid] || (modelMap[existing.cid] = !0, set.push(existing)), models[i] = existing
                            } else add && (model = models[i] = this._prepareModel(model, options)) && (toAdd.push(model), this._addReference(model, options), modelMap[model.cid] = !0, set.push(model))
                        }
                        if (remove) {
                            for (i = 0; i < this.length; i++) modelMap[(model = this.models[i]).cid] || toRemove.push(model);
                            toRemove.length && this._removeModels(toRemove, options)
                        }
                        var orderChanged = !1,
                            replace = !sortable && add && remove;
                        if (set.length && replace ? (orderChanged = this.length != set.length || _.some(this.models, function(model, index) {
                                return model !== set[index]
                            }), this.models.length = 0, splice(this.models, set, 0), this.length = this.models.length) : toAdd.length && (sortable && (sort = !0), splice(this.models, toAdd, null == at ? this.length : at), this.length = this.models.length), sort && this.sort({
                                silent: !0
                            }), !options.silent) {
                            for (i = 0; i < toAdd.length; i++) null != at && (options.index = at + i), (model = toAdd[i]).trigger("add", model, this, options);
                            (sort || orderChanged) && this.trigger("sort", this, options), (toAdd.length || toRemove.length) && this.trigger("update", this, options)
                        }
                        return singular ? models[0] : models
                    }
                },
                reset: function(models, options) {
                    options = options ? _.clone(options) : {};
                    for (var i = 0; i < this.models.length; i++) this._removeReference(this.models[i], options);
                    return options.previousModels = this.models, this._reset(), models = this.add(models, _.extend({
                        silent: !0
                    }, options)), options.silent || this.trigger("reset", this, options), models
                },
                push: function(model, options) {
                    return this.add(model, _.extend({
                        at: this.length
                    }, options))
                },
                pop: function(options) {
                    var model = this.at(this.length - 1);
                    return this.remove(model, options)
                },
                unshift: function(model, options) {
                    return this.add(model, _.extend({
                        at: 0
                    }, options))
                },
                shift: function(options) {
                    var model = this.at(0);
                    return this.remove(model, options)
                },
                slice: function() {
                    return slice.apply(this.models, arguments)
                },
                get: function(obj) {
                    if (null != obj) {
                        var id = this.modelId(this._isModel(obj) ? obj.attributes : obj);
                        return this._byId[obj] || this._byId[id] || this._byId[obj.cid]
                    }
                },
                at: function(index) {
                    return index < 0 && (index += this.length), this.models[index]
                },
                where: function(attrs, first) {
                    return this[first ? "find" : "filter"](attrs)
                },
                findWhere: function(attrs) {
                    return this.where(attrs, !0)
                },
                sort: function(options) {
                    var comparator = this.comparator;
                    if (!comparator) throw new Error("Cannot sort a set without a comparator");
                    options || (options = {});
                    var length = comparator.length;
                    return _.isFunction(comparator) && (comparator = _.bind(comparator, this)), 1 === length || _.isString(comparator) ? this.models = this.sortBy(comparator) : this.models.sort(comparator), options.silent || this.trigger("sort", this, options), this
                },
                pluck: function(attr) {
                    return _.invoke(this.models, "get", attr)
                },
                fetch: function(options) {
                    var success = (options = _.extend({
                            parse: !0
                        }, options)).success,
                        collection = this;
                    return options.success = function(resp) {
                        var method = options.reset ? "reset" : "set";
                        collection[method](resp, options), success && success.call(options.context, collection, resp, options), collection.trigger("sync", collection, resp, options)
                    }, wrapError(this, options), this.sync("read", this, options)
                },
                create: function(model, options) {
                    var wait = (options = options ? _.clone(options) : {}).wait;
                    if (!(model = this._prepareModel(model, options))) return !1;
                    wait || this.add(model, options);
                    var collection = this,
                        success = options.success;
                    return options.success = function(model, resp, callbackOpts) {
                        wait && collection.add(model, callbackOpts), success && success.call(callbackOpts.context, model, resp, callbackOpts)
                    }, model.save(null, options), model
                },
                parse: function(resp, options) {
                    return resp
                },
                clone: function() {
                    return new this.constructor(this.models, {
                        model: this.model,
                        comparator: this.comparator
                    })
                },
                modelId: function(attrs) {
                    return attrs[this.model.prototype.idAttribute || "id"]
                },
                _reset: function() {
                    this.length = 0, this.models = [], this._byId = {}
                },
                _prepareModel: function(attrs, options) {
                    if (this._isModel(attrs)) return attrs.collection || (attrs.collection = this), attrs;
                    (options = options ? _.clone(options) : {}).collection = this;
                    var model = new this.model(attrs, options);
                    return model.validationError ? (this.trigger("invalid", this, model.validationError, options), !1) : model
                },
                _removeModels: function(models, options) {
                    for (var removed = [], i = 0; i < models.length; i++) {
                        var model = this.get(models[i]);
                        if (model) {
                            var index = this.indexOf(model);
                            this.models.splice(index, 1), this.length--, options.silent || (options.index = index, model.trigger("remove", model, this, options)), removed.push(model), this._removeReference(model, options)
                        }
                    }
                    return !!removed.length && removed
                },
                _isModel: function(model) {
                    return model instanceof Model
                },
                _addReference: function(model, options) {
                    this._byId[model.cid] = model;
                    var id = this.modelId(model.attributes);
                    null != id && (this._byId[id] = model), model.on("all", this._onModelEvent, this)
                },
                _removeReference: function(model, options) {
                    delete this._byId[model.cid];
                    var id = this.modelId(model.attributes);
                    null != id && delete this._byId[id], this === model.collection && delete model.collection, model.off("all", this._onModelEvent, this)
                },
                _onModelEvent: function(event, model, collection, options) {
                    if ("add" !== event && "remove" !== event || collection === this) {
                        if ("destroy" === event && this.remove(model, options), "change" === event) {
                            var prevId = this.modelId(model.previousAttributes()),
                                id = this.modelId(model.attributes);
                            prevId !== id && (null != prevId && delete this._byId[prevId], null != id && (this._byId[id] = model))
                        }
                        this.trigger.apply(this, arguments)
                    }
                }
            });
            addUnderscoreMethods(Collection, {
                forEach: 3,
                each: 3,
                map: 3,
                collect: 3,
                reduce: 4,
                foldl: 4,
                inject: 4,
                reduceRight: 4,
                foldr: 4,
                find: 3,
                detect: 3,
                filter: 3,
                select: 3,
                reject: 3,
                every: 3,
                all: 3,
                some: 3,
                any: 3,
                include: 3,
                includes: 3,
                contains: 3,
                invoke: 0,
                max: 3,
                min: 3,
                toArray: 1,
                size: 1,
                first: 3,
                head: 3,
                take: 3,
                initial: 3,
                rest: 3,
                tail: 3,
                drop: 3,
                last: 3,
                without: 0,
                difference: 0,
                indexOf: 3,
                shuffle: 1,
                lastIndexOf: 3,
                isEmpty: 1,
                chain: 1,
                sample: 3,
                partition: 3,
                groupBy: 3,
                countBy: 3,
                sortBy: 3,
                indexBy: 3
            }, "models");
            var View = Backbone.View = function(options) {
                    this.cid = _.uniqueId("view"), _.extend(this, _.pick(options, viewOptions)), this._ensureElement(), this.initialize.apply(this, arguments)
                },
                delegateEventSplitter = /^(\S+)\s*(.*)$/,
                viewOptions = ["model", "collection", "el", "id", "attributes", "className", "tagName", "events"];
            _.extend(View.prototype, Events, {
                tagName: "div",
                $: function(selector) {
                    return this.$el.find(selector)
                },
                initialize: function() {},
                render: function() {
                    return this
                },
                remove: function() {
                    return this._removeElement(), this.stopListening(), this
                },
                _removeElement: function() {
                    this.$el.remove()
                },
                setElement: function(element) {
                    return this.undelegateEvents(), this._setElement(element), this.delegateEvents(), this
                },
                _setElement: function(el) {
                    this.$el = el instanceof Backbone.$ ? el : Backbone.$(el), this.el = this.$el[0]
                },
                delegateEvents: function(events) {
                    if (events || (events = _.result(this, "events")), !events) return this;
                    for (var key in this.undelegateEvents(), events) {
                        var method = events[key];
                        if (_.isFunction(method) || (method = this[method]), method) {
                            var match = key.match(delegateEventSplitter);
                            this.delegate(match[1], match[2], _.bind(method, this))
                        }
                    }
                    return this
                },
                delegate: function(eventName, selector, listener) {
                    return this.$el.on(eventName + ".delegateEvents" + this.cid, selector, listener), this
                },
                undelegateEvents: function() {
                    return this.$el && this.$el.off(".delegateEvents" + this.cid), this
                },
                undelegate: function(eventName, selector, listener) {
                    return this.$el.off(eventName + ".delegateEvents" + this.cid, selector, listener), this
                },
                _createElement: function(tagName) {
                    return document.createElement(tagName)
                },
                _ensureElement: function() {
                    if (this.el) this.setElement(_.result(this, "el"));
                    else {
                        var attrs = _.extend({}, _.result(this, "attributes"));
                        this.id && (attrs.id = _.result(this, "id")), this.className && (attrs.class = _.result(this, "className")), this.setElement(this._createElement(_.result(this, "tagName"))), this._setAttributes(attrs)
                    }
                },
                _setAttributes: function(attributes) {
                    this.$el.attr(attributes)
                }
            }), Backbone.sync = function(method, model, options) {
                var type = methodMap[method];
                _.defaults(options || (options = {}), {
                    emulateHTTP: Backbone.emulateHTTP,
                    emulateJSON: Backbone.emulateJSON
                });
                var params = {
                    type: type,
                    dataType: "json"
                };
                if (options.url || (params.url = _.result(model, "url") || urlError()), null != options.data || !model || "create" !== method && "update" !== method && "patch" !== method || (params.contentType = "application/json", params.data = JSON.stringify(options.attrs || model.toJSON(options))), options.emulateJSON && (params.contentType = "application/x-www-form-urlencoded", params.data = params.data ? {
                        model: params.data
                    } : {}), options.emulateHTTP && ("PUT" === type || "DELETE" === type || "PATCH" === type)) {
                    params.type = "POST", options.emulateJSON && (params.data._method = type);
                    var beforeSend = options.beforeSend;
                    options.beforeSend = function(xhr) {
                        if (xhr.setRequestHeader("X-HTTP-Method-Override", type), beforeSend) return beforeSend.apply(this, arguments)
                    }
                }
                "GET" === params.type || options.emulateJSON || (params.processData = !1);
                var error = options.error;
                options.error = function(xhr, textStatus, errorThrown) {
                    options.textStatus = textStatus, options.errorThrown = errorThrown, error && error.call(options.context, xhr, textStatus, errorThrown)
                };
                var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
                return model.trigger("request", model, xhr, options), xhr
            };
            var methodMap = {
                create: "POST",
                update: "PUT",
                patch: "PATCH",
                delete: "DELETE",
                read: "GET"
            };
            Backbone.ajax = function() {
                return Backbone.$.ajax.apply(Backbone.$, arguments)
            };
            var Router = Backbone.Router = function(options) {
                    options || (options = {}), options.routes && (this.routes = options.routes), this._bindRoutes(), this.initialize.apply(this, arguments)
                },
                optionalParam = /\((.*?)\)/g,
                namedParam = /(\(\?)?:\w+/g,
                splatParam = /\*\w+/g,
                escapeRegExp = /[\-{}\[\]+?.,\\\^$|#\s]/g;
            _.extend(Router.prototype, Events, {
                initialize: function() {},
                route: function(route, name, callback) {
                    _.isRegExp(route) || (route = this._routeToRegExp(route)), _.isFunction(name) && (callback = name, name = ""), callback || (callback = this[name]);
                    var router = this;
                    return Backbone.history.route(route, function(fragment) {
                        var args = router._extractParameters(route, fragment);
                        !1 !== router.execute(callback, args, name) && (router.trigger.apply(router, ["route:" + name].concat(args)), router.trigger("route", name, args), Backbone.history.trigger("route", router, name, args))
                    }), this
                },
                execute: function(callback, args, name) {
                    callback && callback.apply(this, args)
                },
                navigate: function(fragment, options) {
                    return Backbone.history.navigate(fragment, options), this
                },
                _bindRoutes: function() {
                    if (this.routes) {
                        this.routes = _.result(this, "routes");
                        for (var route, routes = _.keys(this.routes); null != (route = routes.pop());) this.route(route, this.routes[route])
                    }
                },
                _routeToRegExp: function(route) {
                    return route = route.replace(escapeRegExp, "\\$&").replace(optionalParam, "(?:$1)?").replace(namedParam, function(match, optional) {
                        return optional ? match : "([^/?]+)"
                    }).replace(splatParam, "([^?]*?)"), new RegExp("^" + route + "(?:\\?([\\s\\S]*))?$")
                },
                _extractParameters: function(route, fragment) {
                    var params = route.exec(fragment).slice(1);
                    return _.map(params, function(param, i) {
                        return i === params.length - 1 ? param || null : param ? decodeURIComponent(param) : null
                    })
                }
            });
            var History = Backbone.History = function() {
                    this.handlers = [], this.checkUrl = _.bind(this.checkUrl, this), "undefined" != typeof window && (this.location = window.location, this.history = window.history)
                },
                routeStripper = /^[#\/]|\s+$/g,
                rootStripper = /^\/+|\/+$/g,
                pathStripper = /#.*$/;
            History.started = !1, _.extend(History.prototype, Events, {
                interval: 50,
                atRoot: function() {
                    return this.location.pathname.replace(/[^\/]$/, "$&/") === this.root && !this.getSearch()
                },
                matchRoot: function() {
                    return this.decodeFragment(this.location.pathname).slice(0, this.root.length - 1) + "/" === this.root
                },
                decodeFragment: function(fragment) {
                    return decodeURI(fragment.replace(/%25/g, "%2525"))
                },
                getSearch: function() {
                    var match = this.location.href.replace(/#.*/, "").match(/\?.+/);
                    return match ? match[0] : ""
                },
                getHash: function(window) {
                    var match = (window || this).location.href.match(/#(.*)$/);
                    return match ? match[1] : ""
                },
                getPath: function() {
                    var path = this.decodeFragment(this.location.pathname + this.getSearch()).slice(this.root.length - 1);
                    return "/" === path.charAt(0) ? path.slice(1) : path
                },
                getFragment: function(fragment) {
                    return null == fragment && (fragment = this._usePushState || !this._wantsHashChange ? this.getPath() : this.getHash()), fragment.replace(routeStripper, "")
                },
                start: function(options) {
                    if (History.started) throw new Error("Backbone.history has already been started");
                    if (History.started = !0, this.options = _.extend({
                            root: "/"
                        }, this.options, options), this.root = this.options.root, this._wantsHashChange = !1 !== this.options.hashChange, this._hasHashChange = "onhashchange" in window && (void 0 === document.documentMode || document.documentMode > 7), this._useHashChange = this._wantsHashChange && this._hasHashChange, this._wantsPushState = !!this.options.pushState, this._hasPushState = !(!this.history || !this.history.pushState), this._usePushState = this._wantsPushState && this._hasPushState, this.fragment = this.getFragment(), this.root = ("/" + this.root + "/").replace(rootStripper, "/"), this._wantsHashChange && this._wantsPushState) {
                        if (!this._hasPushState && !this.atRoot()) {
                            var root = this.root.slice(0, -1) || "/";
                            return this.location.replace(root + "#" + this.getPath()), !0
                        }
                        this._hasPushState && this.atRoot() && this.navigate(this.getHash(), {
                            replace: !0
                        })
                    }
                    if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {
                        this.iframe = document.createElement("iframe"), this.iframe.src = "javascript:0", this.iframe.style.display = "none", this.iframe.tabIndex = -1;
                        var body = document.body,
                            iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;
                        iWindow.document.open(), iWindow.document.close(), iWindow.location.hash = "#" + this.fragment
                    }
                    var addEventListener = window.addEventListener || function(eventName, listener) {
                        return attachEvent("on" + eventName, listener)
                    };
                    if (this._usePushState ? addEventListener("popstate", this.checkUrl, !1) : this._useHashChange && !this.iframe ? addEventListener("hashchange", this.checkUrl, !1) : this._wantsHashChange && (this._checkUrlInterval = setInterval(this.checkUrl, this.interval)), !this.options.silent) return this.loadUrl()
                },
                stop: function() {
                    var removeEventListener = window.removeEventListener || function(eventName, listener) {
                        return detachEvent("on" + eventName, listener)
                    };
                    this._usePushState ? removeEventListener("popstate", this.checkUrl, !1) : this._useHashChange && !this.iframe && removeEventListener("hashchange", this.checkUrl, !1), this.iframe && (document.body.removeChild(this.iframe), this.iframe = null), this._checkUrlInterval && clearInterval(this._checkUrlInterval), History.started = !1
                },
                route: function(route, callback) {
                    this.handlers.unshift({
                        route: route,
                        callback: callback
                    })
                },
                checkUrl: function(e) {
                    var current = this.getFragment();
                    if (current === this.fragment && this.iframe && (current = this.getHash(this.iframe.contentWindow)), current === this.fragment) return !1;
                    this.iframe && this.navigate(current), this.loadUrl()
                },
                loadUrl: function(fragment) {
                    return !!this.matchRoot() && (fragment = this.fragment = this.getFragment(fragment), _.some(this.handlers, function(handler) {
                        if (handler.route.test(fragment)) return handler.callback(fragment), !0
                    }))
                },
                navigate: function(fragment, options) {
                    if (!History.started) return !1;
                    options && !0 !== options || (options = {
                        trigger: !!options
                    }), fragment = this.getFragment(fragment || "");
                    var root = this.root;
                    "" !== fragment && "?" !== fragment.charAt(0) || (root = root.slice(0, -1) || "/");
                    var url = root + fragment;
                    if (fragment = this.decodeFragment(fragment.replace(pathStripper, "")), this.fragment !== fragment) {
                        if (this.fragment = fragment, this._usePushState) this.history[options.replace ? "replaceState" : "pushState"]({}, document.title, url);
                        else {
                            if (!this._wantsHashChange) return this.location.assign(url);
                            if (this._updateHash(this.location, fragment, options.replace), this.iframe && fragment !== this.getHash(this.iframe.contentWindow)) {
                                var iWindow = this.iframe.contentWindow;
                                options.replace || (iWindow.document.open(), iWindow.document.close()), this._updateHash(iWindow.location, fragment, options.replace)
                            }
                        }
                        return options.trigger ? this.loadUrl(fragment) : void 0
                    }
                },
                _updateHash: function(location, fragment, replace) {
                    if (replace) {
                        var href = location.href.replace(/(javascript:|#).*$/, "");
                        location.replace(href + "#" + fragment)
                    } else location.hash = "#" + fragment
                }
            }), Backbone.history = new History;
            Model.extend = Collection.extend = Router.extend = View.extend = History.extend = function(protoProps, staticProps) {
                var child, parent = this;
                child = protoProps && _.has(protoProps, "constructor") ? protoProps.constructor : function() {
                    return parent.apply(this, arguments)
                }, _.extend(child, parent, staticProps);
                var Surrogate = function() {
                    this.constructor = child
                };
                return Surrogate.prototype = parent.prototype, child.prototype = new Surrogate, protoProps && _.extend(child.prototype, protoProps), child.__super__ = parent.prototype, child
            };
            var urlError = function() {
                    throw new Error('A "url" property or function must be specified')
                },
                wrapError = function(model, options) {
                    var error = options.error;
                    options.error = function(resp) {
                        error && error.call(options.context, model, resp, options), model.trigger("error", model, resp, options)
                    }
                };
            return Backbone
        }, root = "object" == typeof self && self.self == self && self || "object" == typeof global && global.global == global && global, __WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(43), __webpack_require__(69), exports], void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = function(_, $, exports) {
            root.Backbone = factory(root, exports, _, $)
        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)
    }).call(exports, __webpack_require__(54))
}, function(module, exports) {
    var g;
    g = function() {
        return this
    }();
    try {
        g = g || Function("return this")() || (0, eval)("this")
    } catch (e) {
        "object" == typeof window && (g = window)
    }
    module.exports = g
}, function(module, exports, __webpack_require__) {
    var toIObject = __webpack_require__(15),
        toLength = __webpack_require__(6),
        toAbsoluteIndex = __webpack_require__(35);
    module.exports = function(IS_INCLUDES) {
        return function($this, el, fromIndex) {
            var value, O = toIObject($this),
                length = toLength(O.length),
                index = toAbsoluteIndex(fromIndex, length);
            if (IS_INCLUDES && el != el) {
                for (; length > index;)
                    if ((value = O[index++]) != value) return !0
            } else
                for (; length > index; index++)
                    if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
            return !IS_INCLUDES && -1
        }
    }
}, function(module, exports) {
    exports.f = Object.getOwnPropertySymbols
}, function(module, exports, __webpack_require__) {
    var cof = __webpack_require__(20);
    module.exports = Array.isArray || function(arg) {
        return "Array" == cof(arg)
    }
}, function(module, exports, __webpack_require__) {
    var toInteger = __webpack_require__(21),
        defined = __webpack_require__(24);
    module.exports = function(TO_STRING) {
        return function(that, pos) {
            var a, b, s = String(defined(that)),
                i = toInteger(pos),
                l = s.length;
            return i < 0 || i >= l ? TO_STRING ? "" : void 0 : (a = s.charCodeAt(i)) < 55296 || a > 56319 || i + 1 === l || (b = s.charCodeAt(i + 1)) < 56320 || b > 57343 ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : b - 56320 + (a - 55296 << 10) + 65536
        }
    }
}, function(module, exports, __webpack_require__) {
    var isObject = __webpack_require__(4),
        cof = __webpack_require__(20),
        MATCH = __webpack_require__(5)("match");
    module.exports = function(it) {
        var isRegExp;
        return isObject(it) && (void 0 !== (isRegExp = it[MATCH]) ? !!isRegExp : "RegExp" == cof(it))
    }
}, function(module, exports, __webpack_require__) {
    var ITERATOR = __webpack_require__(5)("iterator"),
        SAFE_CLOSING = !1;
    try {
        var riter = [7][ITERATOR]();
        riter.return = function() {
            SAFE_CLOSING = !0
        }, Array.from(riter, function() {
            throw 2
        })
    } catch (e) {}
    module.exports = function(exec, skipClosing) {
        if (!skipClosing && !SAFE_CLOSING) return !1;
        var safe = !1;
        try {
            var arr = [7],
                iter = arr[ITERATOR]();
            iter.next = function() {
                return {
                    done: safe = !0
                }
            }, arr[ITERATOR] = function() {
                return iter
            }, exec(arr)
        } catch (e) {}
        return safe
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var classof = __webpack_require__(45),
        builtinExec = RegExp.prototype.exec;
    module.exports = function(R, S) {
        var exec = R.exec;
        if ("function" == typeof exec) {
            var result = exec.call(R, S);
            if ("object" != typeof result) throw new TypeError("RegExp exec method returned something other than an Object or null");
            return result
        }
        if ("RegExp" !== classof(R)) throw new TypeError("RegExp#exec called on incompatible receiver");
        return builtinExec.call(R, S)
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    __webpack_require__(116);
    var redefine = __webpack_require__(12),
        hide = __webpack_require__(11),
        fails = __webpack_require__(3),
        defined = __webpack_require__(24),
        wks = __webpack_require__(5),
        regexpExec = __webpack_require__(91),
        SPECIES = wks("species"),
        REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
            var re = /./;
            return re.exec = function() {
                var result = [];
                return result.groups = {
                    a: "7"
                }, result
            }, "7" !== "".replace(re, "$<a>")
        }),
        SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = function() {
            var re = /(?:)/,
                originalExec = re.exec;
            re.exec = function() {
                return originalExec.apply(this, arguments)
            };
            var result = "ab".split(re);
            return 2 === result.length && "a" === result[0] && "b" === result[1]
        }();
    module.exports = function(KEY, length, exec) {
        var SYMBOL = wks(KEY),
            DELEGATES_TO_SYMBOL = !fails(function() {
                var O = {};
                return O[SYMBOL] = function() {
                    return 7
                }, 7 != "" [KEY](O)
            }),
            DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function() {
                var execCalled = !1,
                    re = /a/;
                return re.exec = function() {
                    return execCalled = !0, null
                }, "split" === KEY && (re.constructor = {}, re.constructor[SPECIES] = function() {
                    return re
                }), re[SYMBOL](""), !execCalled
            }) : void 0;
        if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || "replace" === KEY && !REPLACE_SUPPORTS_NAMED_GROUPS || "split" === KEY && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
            var nativeRegExpMethod = /./ [SYMBOL],
                fns = exec(defined, SYMBOL, "" [KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
                    return regexp.exec === regexpExec ? DELEGATES_TO_SYMBOL && !forceStringMethod ? {
                        done: !0,
                        value: nativeRegExpMethod.call(regexp, str, arg2)
                    } : {
                        done: !0,
                        value: nativeMethod.call(str, regexp, arg2)
                    } : {
                        done: !1
                    }
                }),
                strfn = fns[0],
                rxfn = fns[1];
            redefine(String.prototype, KEY, strfn), hide(RegExp.prototype, SYMBOL, 2 == length ? function(string, arg) {
                return rxfn.call(string, this, arg)
            } : function(string) {
                return rxfn.call(string, this)
            })
        }
    }
}, function(module, exports, __webpack_require__) {
    var navigator = __webpack_require__(2).navigator;
    module.exports = navigator && navigator.userAgent || ""
}, function(module, exports, __webpack_require__) {
    "use strict";
    var global = __webpack_require__(2),
        $export = __webpack_require__(0),
        redefine = __webpack_require__(12),
        redefineAll = __webpack_require__(41),
        meta = __webpack_require__(30),
        forOf = __webpack_require__(40),
        anInstance = __webpack_require__(39),
        isObject = __webpack_require__(4),
        fails = __webpack_require__(3),
        $iterDetect = __webpack_require__(60),
        setToStringTag = __webpack_require__(44),
        inheritIfRequired = __webpack_require__(77);
    module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
        var Base = global[NAME],
            C = Base,
            ADDER = IS_MAP ? "set" : "add",
            proto = C && C.prototype,
            O = {},
            fixMethod = function(KEY) {
                var fn = proto[KEY];
                redefine(proto, KEY, "delete" == KEY ? function(a) {
                    return !(IS_WEAK && !isObject(a)) && fn.call(this, 0 === a ? 0 : a)
                } : "has" == KEY ? function(a) {
                    return !(IS_WEAK && !isObject(a)) && fn.call(this, 0 === a ? 0 : a)
                } : "get" == KEY ? function(a) {
                    return IS_WEAK && !isObject(a) ? void 0 : fn.call(this, 0 === a ? 0 : a)
                } : "add" == KEY ? function(a) {
                    return fn.call(this, 0 === a ? 0 : a), this
                } : function(a, b) {
                    return fn.call(this, 0 === a ? 0 : a, b), this
                })
            };
        if ("function" == typeof C && (IS_WEAK || proto.forEach && !fails(function() {
                (new C).entries().next()
            }))) {
            var instance = new C,
                HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance,
                THROWS_ON_PRIMITIVES = fails(function() {
                    instance.has(1)
                }),
                ACCEPT_ITERABLES = $iterDetect(function(iter) {
                    new C(iter)
                }),
                BUGGY_ZERO = !IS_WEAK && fails(function() {
                    for (var $instance = new C, index = 5; index--;) $instance[ADDER](index, index);
                    return !$instance.has(-0)
                });
            ACCEPT_ITERABLES || ((C = wrapper(function(target, iterable) {
                anInstance(target, C, NAME);
                var that = inheritIfRequired(new Base, target, C);
                return void 0 != iterable && forOf(iterable, IS_MAP, that[ADDER], that), that
            })).prototype = proto, proto.constructor = C), (THROWS_ON_PRIMITIVES || BUGGY_ZERO) && (fixMethod("delete"), fixMethod("has"), IS_MAP && fixMethod("get")), (BUGGY_ZERO || HASNT_CHAINING) && fixMethod(ADDER), IS_WEAK && proto.clear && delete proto.clear
        } else C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER), redefineAll(C.prototype, methods), meta.NEED = !0;
        return setToStringTag(C, NAME), O[NAME] = C, $export($export.G + $export.W + $export.F * (C != Base), O), IS_WEAK || common.setStrong(C, NAME, IS_MAP), C
    }
}, function(module, exports, __webpack_require__) {
    for (var Typed, global = __webpack_require__(2), hide = __webpack_require__(11), uid = __webpack_require__(33), TYPED = uid("typed_array"), VIEW = uid("view"), ABV = !(!global.ArrayBuffer || !global.DataView), CONSTR = ABV, i = 0, TypedArrayConstructors = "Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(","); i < 9;)(Typed = global[TypedArrayConstructors[i++]]) ? (hide(Typed.prototype, TYPED, !0), hide(Typed.prototype, VIEW, !0)) : CONSTR = !1;
    module.exports = {
        ABV: ABV,
        CONSTR: CONSTR,
        TYPED: TYPED,
        VIEW: VIEW
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = __webpack_require__(29) || !__webpack_require__(3)(function() {
        var K = Math.random();
        __defineSetter__.call(null, K, function() {}), delete __webpack_require__(2)[K]
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0);
    module.exports = function(COLLECTION) {
        $export($export.S, COLLECTION, {
            of: function() {
                for (var length = arguments.length, A = new Array(length); length--;) A[length] = arguments[length];
                return new this(A)
            }
        })
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        aFunction = __webpack_require__(10),
        ctx = __webpack_require__(19),
        forOf = __webpack_require__(40);
    module.exports = function(COLLECTION) {
        $export($export.S, COLLECTION, {
            from: function(source) {
                var mapping, A, n, cb, mapFn = arguments[1];
                return aFunction(this), (mapping = void 0 !== mapFn) && aFunction(mapFn), void 0 == source ? new this : (A = [], mapping ? (n = 0, cb = ctx(mapFn, arguments[2], 2), forOf(source, !1, function(nextItem) {
                    A.push(cb(nextItem, n++))
                })) : forOf(source, !1, A.push, A), new this(A))
            }
        })
    }
}, function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_RESULT__, global, factory;
    global = "undefined" != typeof window ? window : this, factory = function(window, noGlobal) {
        var deletedIds = [],
            slice = deletedIds.slice,
            concat = deletedIds.concat,
            push = deletedIds.push,
            indexOf = deletedIds.indexOf,
            class2type = {},
            toString = class2type.toString,
            hasOwn = class2type.hasOwnProperty,
            support = {},
            jQuery = function(selector, context) {
                return new jQuery.fn.init(selector, context)
            },
            rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
            rmsPrefix = /^-ms-/,
            rdashAlpha = /-([\da-z])/gi,
            fcamelCase = function(all, letter) {
                return letter.toUpperCase()
            };

        function isArraylike(obj) {
            var length = "length" in obj && obj.length,
                type = jQuery.type(obj);
            return "function" !== type && !jQuery.isWindow(obj) && (!(1 !== obj.nodeType || !length) || ("array" === type || 0 === length || "number" == typeof length && length > 0 && length - 1 in obj))
        }
        jQuery.fn = jQuery.prototype = {
            jquery: "1.11.3",
            constructor: jQuery,
            selector: "",
            length: 0,
            toArray: function() {
                return slice.call(this)
            },
            get: function(num) {
                return null != num ? num < 0 ? this[num + this.length] : this[num] : slice.call(this)
            },
            pushStack: function(elems) {
                var ret = jQuery.merge(this.constructor(), elems);
                return ret.prevObject = this, ret.context = this.context, ret
            },
            each: function(callback, args) {
                return jQuery.each(this, callback, args)
            },
            map: function(callback) {
                return this.pushStack(jQuery.map(this, function(elem, i) {
                    return callback.call(elem, i, elem)
                }))
            },
            slice: function() {
                return this.pushStack(slice.apply(this, arguments))
            },
            first: function() {
                return this.eq(0)
            },
            last: function() {
                return this.eq(-1)
            },
            eq: function(i) {
                var len = this.length,
                    j = +i + (i < 0 ? len : 0);
                return this.pushStack(j >= 0 && j < len ? [this[j]] : [])
            },
            end: function() {
                return this.prevObject || this.constructor(null)
            },
            push: push,
            sort: deletedIds.sort,
            splice: deletedIds.splice
        }, jQuery.extend = jQuery.fn.extend = function() {
            var src, copyIsArray, copy, name, options, clone, target = arguments[0] || {},
                i = 1,
                length = arguments.length,
                deep = !1;
            for ("boolean" == typeof target && (deep = target, target = arguments[i] || {}, i++), "object" == typeof target || jQuery.isFunction(target) || (target = {}), i === length && (target = this, i--); i < length; i++)
                if (null != (options = arguments[i]))
                    for (name in options) src = target[name], target !== (copy = options[name]) && (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy))) ? (copyIsArray ? (copyIsArray = !1, clone = src && jQuery.isArray(src) ? src : []) : clone = src && jQuery.isPlainObject(src) ? src : {}, target[name] = jQuery.extend(deep, clone, copy)) : void 0 !== copy && (target[name] = copy));
            return target
        }, jQuery.extend({
            expando: "jQuery" + ("1.11.3" + Math.random()).replace(/\D/g, ""),
            isReady: !0,
            error: function(msg) {
                throw new Error(msg)
            },
            noop: function() {},
            isFunction: function(obj) {
                return "function" === jQuery.type(obj)
            },
            isArray: Array.isArray || function(obj) {
                return "array" === jQuery.type(obj)
            },
            isWindow: function(obj) {
                return null != obj && obj == obj.window
            },
            isNumeric: function(obj) {
                return !jQuery.isArray(obj) && obj - parseFloat(obj) + 1 >= 0
            },
            isEmptyObject: function(obj) {
                var name;
                for (name in obj) return !1;
                return !0
            },
            isPlainObject: function(obj) {
                var key;
                if (!obj || "object" !== jQuery.type(obj) || obj.nodeType || jQuery.isWindow(obj)) return !1;
                try {
                    if (obj.constructor && !hasOwn.call(obj, "constructor") && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) return !1
                } catch (e) {
                    return !1
                }
                if (support.ownLast)
                    for (key in obj) return hasOwn.call(obj, key);
                for (key in obj);
                return void 0 === key || hasOwn.call(obj, key)
            },
            type: function(obj) {
                return null == obj ? obj + "" : "object" == typeof obj || "function" == typeof obj ? class2type[toString.call(obj)] || "object" : typeof obj
            },
            globalEval: function(data) {
                data && jQuery.trim(data) && (window.execScript || function(data) {
                    window.eval.call(window, data)
                })(data)
            },
            camelCase: function(string) {
                return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase)
            },
            nodeName: function(elem, name) {
                return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase()
            },
            each: function(obj, callback, args) {
                var i = 0,
                    length = obj.length,
                    isArray = isArraylike(obj);
                if (args) {
                    if (isArray)
                        for (; i < length && !1 !== callback.apply(obj[i], args); i++);
                    else
                        for (i in obj)
                            if (!1 === callback.apply(obj[i], args)) break
                } else if (isArray)
                    for (; i < length && !1 !== callback.call(obj[i], i, obj[i]); i++);
                else
                    for (i in obj)
                        if (!1 === callback.call(obj[i], i, obj[i])) break;
                return obj
            },
            trim: function(text) {
                return null == text ? "" : (text + "").replace(rtrim, "")
            },
            makeArray: function(arr, results) {
                var ret = results || [];
                return null != arr && (isArraylike(Object(arr)) ? jQuery.merge(ret, "string" == typeof arr ? [arr] : arr) : push.call(ret, arr)), ret
            },
            inArray: function(elem, arr, i) {
                var len;
                if (arr) {
                    if (indexOf) return indexOf.call(arr, elem, i);
                    for (len = arr.length, i = i ? i < 0 ? Math.max(0, len + i) : i : 0; i < len; i++)
                        if (i in arr && arr[i] === elem) return i
                }
                return -1
            },
            merge: function(first, second) {
                for (var len = +second.length, j = 0, i = first.length; j < len;) first[i++] = second[j++];
                if (len != len)
                    for (; void 0 !== second[j];) first[i++] = second[j++];
                return first.length = i, first
            },
            grep: function(elems, callback, invert) {
                for (var matches = [], i = 0, length = elems.length, callbackExpect = !invert; i < length; i++) !callback(elems[i], i) !== callbackExpect && matches.push(elems[i]);
                return matches
            },
            map: function(elems, callback, arg) {
                var value, i = 0,
                    length = elems.length,
                    ret = [];
                if (isArraylike(elems))
                    for (; i < length; i++) null != (value = callback(elems[i], i, arg)) && ret.push(value);
                else
                    for (i in elems) null != (value = callback(elems[i], i, arg)) && ret.push(value);
                return concat.apply([], ret)
            },
            guid: 1,
            proxy: function(fn, context) {
                var args, proxy, tmp;
                if ("string" == typeof context && (tmp = fn[context], context = fn, fn = tmp), jQuery.isFunction(fn)) return args = slice.call(arguments, 2), (proxy = function() {
                    return fn.apply(context || this, args.concat(slice.call(arguments)))
                }).guid = fn.guid = fn.guid || jQuery.guid++, proxy
            },
            now: function() {
                return +new Date
            },
            support: support
        }), jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
            class2type["[object " + name + "]"] = name.toLowerCase()
        });
        var Sizzle = function(window) {
            var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + 1 * new Date,
                preferredDoc = window.document,
                dirruns = 0,
                done = 0,
                classCache = createCache(),
                tokenCache = createCache(),
                compilerCache = createCache(),
                sortOrder = function(a, b) {
                    return a === b && (hasDuplicate = !0), 0
                },
                MAX_NEGATIVE = 1 << 31,
                hasOwn = {}.hasOwnProperty,
                arr = [],
                pop = arr.pop,
                push_native = arr.push,
                push = arr.push,
                slice = arr.slice,
                indexOf = function(list, elem) {
                    for (var i = 0, len = list.length; i < len; i++)
                        if (list[i] === elem) return i;
                    return -1
                },
                booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
                whitespace = "[\\x20\\t\\r\\n\\f]",
                characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
                identifier = characterEncoding.replace("w", "w#"),
                attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
                pseudos = ":(" + characterEncoding + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|.*)\\)|)",
                rwhitespace = new RegExp(whitespace + "+", "g"),
                rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
                rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
                rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
                rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
                rpseudo = new RegExp(pseudos),
                ridentifier = new RegExp("^" + identifier + "$"),
                matchExpr = {
                    ID: new RegExp("^#(" + characterEncoding + ")"),
                    CLASS: new RegExp("^\\.(" + characterEncoding + ")"),
                    TAG: new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
                    ATTR: new RegExp("^" + attributes),
                    PSEUDO: new RegExp("^" + pseudos),
                    CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
                    bool: new RegExp("^(?:" + booleans + ")$", "i"),
                    needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
                },
                rinputs = /^(?:input|select|textarea|button)$/i,
                rheader = /^h\d$/i,
                rnative = /^[^{]+\{\s*\[native \w/,
                rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
                rsibling = /[+~]/,
                rescape = /'|\\/g,
                runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
                funescape = function(_, escaped, escapedWhitespace) {
                    var high = "0x" + escaped - 65536;
                    return high != high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, 1023 & high | 56320)
                },
                unloadHandler = function() {
                    setDocument()
                };
            try {
                push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes), arr[preferredDoc.childNodes.length].nodeType
            } catch (e) {
                push = {
                    apply: arr.length ? function(target, els) {
                        push_native.apply(target, slice.call(els))
                    } : function(target, els) {
                        for (var j = target.length, i = 0; target[j++] = els[i++];);
                        target.length = j - 1
                    }
                }
            }

            function Sizzle(selector, context, results, seed) {
                var match, elem, m, nodeType, i, groups, old, nid, newContext, newSelector;
                if ((context ? context.ownerDocument || context : preferredDoc) !== document && setDocument(context), context = context || document, results = results || [], nodeType = context.nodeType, "string" != typeof selector || !selector || 1 !== nodeType && 9 !== nodeType && 11 !== nodeType) return results;
                if (!seed && documentIsHTML) {
                    if (11 !== nodeType && (match = rquickExpr.exec(selector)))
                        if (m = match[1]) {
                            if (9 === nodeType) {
                                if (!(elem = context.getElementById(m)) || !elem.parentNode) return results;
                                if (elem.id === m) return results.push(elem), results
                            } else if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) return results.push(elem), results
                        } else {
                            if (match[2]) return push.apply(results, context.getElementsByTagName(selector)), results;
                            if ((m = match[3]) && support.getElementsByClassName) return push.apply(results, context.getElementsByClassName(m)), results
                        } if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                        if (nid = old = expando, newContext = context, newSelector = 1 !== nodeType && selector, 1 === nodeType && "object" !== context.nodeName.toLowerCase()) {
                            for (groups = tokenize(selector), (old = context.getAttribute("id")) ? nid = old.replace(rescape, "\\$&") : context.setAttribute("id", nid), nid = "[id='" + nid + "'] ", i = groups.length; i--;) groups[i] = nid + toSelector(groups[i]);
                            newContext = rsibling.test(selector) && testContext(context.parentNode) || context, newSelector = groups.join(",")
                        }
                        if (newSelector) try {
                            return push.apply(results, newContext.querySelectorAll(newSelector)), results
                        } catch (qsaError) {} finally {
                            old || context.removeAttribute("id")
                        }
                    }
                }
                return select(selector.replace(rtrim, "$1"), context, results, seed)
            }

            function createCache() {
                var keys = [];
                return function cache(key, value) {
                    return keys.push(key + " ") > Expr.cacheLength && delete cache[keys.shift()], cache[key + " "] = value
                }
            }

            function markFunction(fn) {
                return fn[expando] = !0, fn
            }

            function assert(fn) {
                var div = document.createElement("div");
                try {
                    return !!fn(div)
                } catch (e) {
                    return !1
                } finally {
                    div.parentNode && div.parentNode.removeChild(div), div = null
                }
            }

            function addHandle(attrs, handler) {
                for (var arr = attrs.split("|"), i = attrs.length; i--;) Expr.attrHandle[arr[i]] = handler
            }

            function siblingCheck(a, b) {
                var cur = b && a,
                    diff = cur && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
                if (diff) return diff;
                if (cur)
                    for (; cur = cur.nextSibling;)
                        if (cur === b) return -1;
                return a ? 1 : -1
            }

            function createInputPseudo(type) {
                return function(elem) {
                    return "input" === elem.nodeName.toLowerCase() && elem.type === type
                }
            }

            function createButtonPseudo(type) {
                return function(elem) {
                    var name = elem.nodeName.toLowerCase();
                    return ("input" === name || "button" === name) && elem.type === type
                }
            }

            function createPositionalPseudo(fn) {
                return markFunction(function(argument) {
                    return argument = +argument, markFunction(function(seed, matches) {
                        for (var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length; i--;) seed[j = matchIndexes[i]] && (seed[j] = !(matches[j] = seed[j]))
                    })
                })
            }

            function testContext(context) {
                return context && void 0 !== context.getElementsByTagName && context
            }
            for (i in support = Sizzle.support = {}, isXML = Sizzle.isXML = function(elem) {
                    var documentElement = elem && (elem.ownerDocument || elem).documentElement;
                    return !!documentElement && "HTML" !== documentElement.nodeName
                }, setDocument = Sizzle.setDocument = function(node) {
                    var hasCompare, parent, doc = node ? node.ownerDocument || node : preferredDoc;
                    return doc !== document && 9 === doc.nodeType && doc.documentElement ? (document = doc, docElem = doc.documentElement, (parent = doc.defaultView) && parent !== parent.top && (parent.addEventListener ? parent.addEventListener("unload", unloadHandler, !1) : parent.attachEvent && parent.attachEvent("onunload", unloadHandler)), documentIsHTML = !isXML(doc), support.attributes = assert(function(div) {
                        return div.className = "i", !div.getAttribute("className")
                    }), support.getElementsByTagName = assert(function(div) {
                        return div.appendChild(doc.createComment("")), !div.getElementsByTagName("*").length
                    }), support.getElementsByClassName = rnative.test(doc.getElementsByClassName), support.getById = assert(function(div) {
                        return docElem.appendChild(div).id = expando, !doc.getElementsByName || !doc.getElementsByName(expando).length
                    }), support.getById ? (Expr.find.ID = function(id, context) {
                        if (void 0 !== context.getElementById && documentIsHTML) {
                            var m = context.getElementById(id);
                            return m && m.parentNode ? [m] : []
                        }
                    }, Expr.filter.ID = function(id) {
                        var attrId = id.replace(runescape, funescape);
                        return function(elem) {
                            return elem.getAttribute("id") === attrId
                        }
                    }) : (delete Expr.find.ID, Expr.filter.ID = function(id) {
                        var attrId = id.replace(runescape, funescape);
                        return function(elem) {
                            var node = void 0 !== elem.getAttributeNode && elem.getAttributeNode("id");
                            return node && node.value === attrId
                        }
                    }), Expr.find.TAG = support.getElementsByTagName ? function(tag, context) {
                        return void 0 !== context.getElementsByTagName ? context.getElementsByTagName(tag) : support.qsa ? context.querySelectorAll(tag) : void 0
                    } : function(tag, context) {
                        var elem, tmp = [],
                            i = 0,
                            results = context.getElementsByTagName(tag);
                        if ("*" === tag) {
                            for (; elem = results[i++];) 1 === elem.nodeType && tmp.push(elem);
                            return tmp
                        }
                        return results
                    }, Expr.find.CLASS = support.getElementsByClassName && function(className, context) {
                        if (documentIsHTML) return context.getElementsByClassName(className)
                    }, rbuggyMatches = [], rbuggyQSA = [], (support.qsa = rnative.test(doc.querySelectorAll)) && (assert(function(div) {
                        docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a><select id='" + expando + "-\f]' msallowcapture=''><option selected=''></option></select>", div.querySelectorAll("[msallowcapture^='']").length && rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")"), div.querySelectorAll("[selected]").length || rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")"), div.querySelectorAll("[id~=" + expando + "-]").length || rbuggyQSA.push("~="), div.querySelectorAll(":checked").length || rbuggyQSA.push(":checked"), div.querySelectorAll("a#" + expando + "+*").length || rbuggyQSA.push(".#.+[+~]")
                    }), assert(function(div) {
                        var input = doc.createElement("input");
                        input.setAttribute("type", "hidden"), div.appendChild(input).setAttribute("name", "D"), div.querySelectorAll("[name=d]").length && rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?="), div.querySelectorAll(":enabled").length || rbuggyQSA.push(":enabled", ":disabled"), div.querySelectorAll("*,:x"), rbuggyQSA.push(",.*:")
                    })), (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) && assert(function(div) {
                        support.disconnectedMatch = matches.call(div, "div"), matches.call(div, "[s!='']:x"), rbuggyMatches.push("!=", pseudos)
                    }), rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|")), rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|")), hasCompare = rnative.test(docElem.compareDocumentPosition), contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
                        var adown = 9 === a.nodeType ? a.documentElement : a,
                            bup = b && b.parentNode;
                        return a === bup || !(!bup || 1 !== bup.nodeType || !(adown.contains ? adown.contains(bup) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(bup)))
                    } : function(a, b) {
                        if (b)
                            for (; b = b.parentNode;)
                                if (b === a) return !0;
                        return !1
                    }, sortOrder = hasCompare ? function(a, b) {
                        if (a === b) return hasDuplicate = !0, 0;
                        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                        return compare || (1 & (compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1) || !support.sortDetached && b.compareDocumentPosition(a) === compare ? a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ? -1 : b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0 : 4 & compare ? -1 : 1)
                    } : function(a, b) {
                        if (a === b) return hasDuplicate = !0, 0;
                        var cur, i = 0,
                            aup = a.parentNode,
                            bup = b.parentNode,
                            ap = [a],
                            bp = [b];
                        if (!aup || !bup) return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                        if (aup === bup) return siblingCheck(a, b);
                        for (cur = a; cur = cur.parentNode;) ap.unshift(cur);
                        for (cur = b; cur = cur.parentNode;) bp.unshift(cur);
                        for (; ap[i] === bp[i];) i++;
                        return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0
                    }, doc) : document
                }, Sizzle.matches = function(expr, elements) {
                    return Sizzle(expr, null, null, elements)
                }, Sizzle.matchesSelector = function(elem, expr) {
                    if ((elem.ownerDocument || elem) !== document && setDocument(elem), expr = expr.replace(rattributeQuotes, "='$1']"), support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) try {
                        var ret = matches.call(elem, expr);
                        if (ret || support.disconnectedMatch || elem.document && 11 !== elem.document.nodeType) return ret
                    } catch (e) {}
                    return Sizzle(expr, document, null, [elem]).length > 0
                }, Sizzle.contains = function(context, elem) {
                    return (context.ownerDocument || context) !== document && setDocument(context), contains(context, elem)
                }, Sizzle.attr = function(elem, name) {
                    (elem.ownerDocument || elem) !== document && setDocument(elem);
                    var fn = Expr.attrHandle[name.toLowerCase()],
                        val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : void 0;
                    return void 0 !== val ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null
                }, Sizzle.error = function(msg) {
                    throw new Error("Syntax error, unrecognized expression: " + msg)
                }, Sizzle.uniqueSort = function(results) {
                    var elem, duplicates = [],
                        j = 0,
                        i = 0;
                    if (hasDuplicate = !support.detectDuplicates, sortInput = !support.sortStable && results.slice(0), results.sort(sortOrder), hasDuplicate) {
                        for (; elem = results[i++];) elem === results[i] && (j = duplicates.push(i));
                        for (; j--;) results.splice(duplicates[j], 1)
                    }
                    return sortInput = null, results
                }, getText = Sizzle.getText = function(elem) {
                    var node, ret = "",
                        i = 0,
                        nodeType = elem.nodeType;
                    if (nodeType) {
                        if (1 === nodeType || 9 === nodeType || 11 === nodeType) {
                            if ("string" == typeof elem.textContent) return elem.textContent;
                            for (elem = elem.firstChild; elem; elem = elem.nextSibling) ret += getText(elem)
                        } else if (3 === nodeType || 4 === nodeType) return elem.nodeValue
                    } else
                        for (; node = elem[i++];) ret += getText(node);
                    return ret
                }, (Expr = Sizzle.selectors = {
                    cacheLength: 50,
                    createPseudo: markFunction,
                    match: matchExpr,
                    attrHandle: {},
                    find: {},
                    relative: {
                        ">": {
                            dir: "parentNode",
                            first: !0
                        },
                        " ": {
                            dir: "parentNode"
                        },
                        "+": {
                            dir: "previousSibling",
                            first: !0
                        },
                        "~": {
                            dir: "previousSibling"
                        }
                    },
                    preFilter: {
                        ATTR: function(match) {
                            return match[1] = match[1].replace(runescape, funescape), match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape), "~=" === match[2] && (match[3] = " " + match[3] + " "), match.slice(0, 4)
                        },
                        CHILD: function(match) {
                            return match[1] = match[1].toLowerCase(), "nth" === match[1].slice(0, 3) ? (match[3] || Sizzle.error(match[0]), match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * ("even" === match[3] || "odd" === match[3])), match[5] = +(match[7] + match[8] || "odd" === match[3])) : match[3] && Sizzle.error(match[0]), match
                        },
                        PSEUDO: function(match) {
                            var excess, unquoted = !match[6] && match[2];
                            return matchExpr.CHILD.test(match[0]) ? null : (match[3] ? match[2] = match[4] || match[5] || "" : unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, !0)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length) && (match[0] = match[0].slice(0, excess), match[2] = unquoted.slice(0, excess)), match.slice(0, 3))
                        }
                    },
                    filter: {
                        TAG: function(nodeNameSelector) {
                            var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                            return "*" === nodeNameSelector ? function() {
                                return !0
                            } : function(elem) {
                                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName
                            }
                        },
                        CLASS: function(className) {
                            var pattern = classCache[className + " "];
                            return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                                return pattern.test("string" == typeof elem.className && elem.className || void 0 !== elem.getAttribute && elem.getAttribute("class") || "")
                            })
                        },
                        ATTR: function(name, operator, check) {
                            return function(elem) {
                                var result = Sizzle.attr(elem, name);
                                return null == result ? "!=" === operator : !operator || (result += "", "=" === operator ? result === check : "!=" === operator ? result !== check : "^=" === operator ? check && 0 === result.indexOf(check) : "*=" === operator ? check && result.indexOf(check) > -1 : "$=" === operator ? check && result.slice(-check.length) === check : "~=" === operator ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : "|=" === operator && (result === check || result.slice(0, check.length + 1) === check + "-"))
                            }
                        },
                        CHILD: function(type, what, argument, first, last) {
                            var simple = "nth" !== type.slice(0, 3),
                                forward = "last" !== type.slice(-4),
                                ofType = "of-type" === what;
                            return 1 === first && 0 === last ? function(elem) {
                                return !!elem.parentNode
                            } : function(elem, context, xml) {
                                var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling",
                                    parent = elem.parentNode,
                                    name = ofType && elem.nodeName.toLowerCase(),
                                    useCache = !xml && !ofType;
                                if (parent) {
                                    if (simple) {
                                        for (; dir;) {
                                            for (node = elem; node = node[dir];)
                                                if (ofType ? node.nodeName.toLowerCase() === name : 1 === node.nodeType) return !1;
                                            start = dir = "only" === type && !start && "nextSibling"
                                        }
                                        return !0
                                    }
                                    if (start = [forward ? parent.firstChild : parent.lastChild], forward && useCache) {
                                        for (nodeIndex = (cache = (outerCache = parent[expando] || (parent[expando] = {}))[type] || [])[0] === dirruns && cache[1], diff = cache[0] === dirruns && cache[2], node = nodeIndex && parent.childNodes[nodeIndex]; node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop();)
                                            if (1 === node.nodeType && ++diff && node === elem) {
                                                outerCache[type] = [dirruns, nodeIndex, diff];
                                                break
                                            }
                                    } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) diff = cache[1];
                                    else
                                        for (;
                                            (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) && ((ofType ? node.nodeName.toLowerCase() !== name : 1 !== node.nodeType) || !++diff || (useCache && ((node[expando] || (node[expando] = {}))[type] = [dirruns, diff]), node !== elem)););
                                    return (diff -= last) === first || diff % first == 0 && diff / first >= 0
                                }
                            }
                        },
                        PSEUDO: function(pseudo, argument) {
                            var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                            return fn[expando] ? fn(argument) : fn.length > 1 ? (args = [pseudo, pseudo, "", argument], Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
                                for (var idx, matched = fn(seed, argument), i = matched.length; i--;) seed[idx = indexOf(seed, matched[i])] = !(matches[idx] = matched[i])
                            }) : function(elem) {
                                return fn(elem, 0, args)
                            }) : fn
                        }
                    },
                    pseudos: {
                        not: markFunction(function(selector) {
                            var input = [],
                                results = [],
                                matcher = compile(selector.replace(rtrim, "$1"));
                            return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
                                for (var elem, unmatched = matcher(seed, null, xml, []), i = seed.length; i--;)(elem = unmatched[i]) && (seed[i] = !(matches[i] = elem))
                            }) : function(elem, context, xml) {
                                return input[0] = elem, matcher(input, null, xml, results), input[0] = null, !results.pop()
                            }
                        }),
                        has: markFunction(function(selector) {
                            return function(elem) {
                                return Sizzle(selector, elem).length > 0
                            }
                        }),
                        contains: markFunction(function(text) {
                            return text = text.replace(runescape, funescape),
                                function(elem) {
                                    return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1
                                }
                        }),
                        lang: markFunction(function(lang) {
                            return ridentifier.test(lang || "") || Sizzle.error("unsupported lang: " + lang), lang = lang.replace(runescape, funescape).toLowerCase(),
                                function(elem) {
                                    var elemLang;
                                    do {
                                        if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) return (elemLang = elemLang.toLowerCase()) === lang || 0 === elemLang.indexOf(lang + "-")
                                    } while ((elem = elem.parentNode) && 1 === elem.nodeType);
                                    return !1
                                }
                        }),
                        target: function(elem) {
                            var hash = window.location && window.location.hash;
                            return hash && hash.slice(1) === elem.id
                        },
                        root: function(elem) {
                            return elem === docElem
                        },
                        focus: function(elem) {
                            return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex)
                        },
                        enabled: function(elem) {
                            return !1 === elem.disabled
                        },
                        disabled: function(elem) {
                            return !0 === elem.disabled
                        },
                        checked: function(elem) {
                            var nodeName = elem.nodeName.toLowerCase();
                            return "input" === nodeName && !!elem.checked || "option" === nodeName && !!elem.selected
                        },
                        selected: function(elem) {
                            return elem.parentNode && elem.parentNode.selectedIndex, !0 === elem.selected
                        },
                        empty: function(elem) {
                            for (elem = elem.firstChild; elem; elem = elem.nextSibling)
                                if (elem.nodeType < 6) return !1;
                            return !0
                        },
                        parent: function(elem) {
                            return !Expr.pseudos.empty(elem)
                        },
                        header: function(elem) {
                            return rheader.test(elem.nodeName)
                        },
                        input: function(elem) {
                            return rinputs.test(elem.nodeName)
                        },
                        button: function(elem) {
                            var name = elem.nodeName.toLowerCase();
                            return "input" === name && "button" === elem.type || "button" === name
                        },
                        text: function(elem) {
                            var attr;
                            return "input" === elem.nodeName.toLowerCase() && "text" === elem.type && (null == (attr = elem.getAttribute("type")) || "text" === attr.toLowerCase())
                        },
                        first: createPositionalPseudo(function() {
                            return [0]
                        }),
                        last: createPositionalPseudo(function(matchIndexes, length) {
                            return [length - 1]
                        }),
                        eq: createPositionalPseudo(function(matchIndexes, length, argument) {
                            return [argument < 0 ? argument + length : argument]
                        }),
                        even: createPositionalPseudo(function(matchIndexes, length) {
                            for (var i = 0; i < length; i += 2) matchIndexes.push(i);
                            return matchIndexes
                        }),
                        odd: createPositionalPseudo(function(matchIndexes, length) {
                            for (var i = 1; i < length; i += 2) matchIndexes.push(i);
                            return matchIndexes
                        }),
                        lt: createPositionalPseudo(function(matchIndexes, length, argument) {
                            for (var i = argument < 0 ? argument + length : argument; --i >= 0;) matchIndexes.push(i);
                            return matchIndexes
                        }),
                        gt: createPositionalPseudo(function(matchIndexes, length, argument) {
                            for (var i = argument < 0 ? argument + length : argument; ++i < length;) matchIndexes.push(i);
                            return matchIndexes
                        })
                    }
                }).pseudos.nth = Expr.pseudos.eq, {
                    radio: !0,
                    checkbox: !0,
                    file: !0,
                    password: !0,
                    image: !0
                }) Expr.pseudos[i] = createInputPseudo(i);
            for (i in {
                    submit: !0,
                    reset: !0
                }) Expr.pseudos[i] = createButtonPseudo(i);

            function setFilters() {}

            function toSelector(tokens) {
                for (var i = 0, len = tokens.length, selector = ""; i < len; i++) selector += tokens[i].value;
                return selector
            }

            function addCombinator(matcher, combinator, base) {
                var dir = combinator.dir,
                    checkNonElements = base && "parentNode" === dir,
                    doneName = done++;
                return combinator.first ? function(elem, context, xml) {
                    for (; elem = elem[dir];)
                        if (1 === elem.nodeType || checkNonElements) return matcher(elem, context, xml)
                } : function(elem, context, xml) {
                    var oldCache, outerCache, newCache = [dirruns, doneName];
                    if (xml) {
                        for (; elem = elem[dir];)
                            if ((1 === elem.nodeType || checkNonElements) && matcher(elem, context, xml)) return !0
                    } else
                        for (; elem = elem[dir];)
                            if (1 === elem.nodeType || checkNonElements) {
                                if ((oldCache = (outerCache = elem[expando] || (elem[expando] = {}))[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) return newCache[2] = oldCache[2];
                                if (outerCache[dir] = newCache, newCache[2] = matcher(elem, context, xml)) return !0
                            }
                }
            }

            function elementMatcher(matchers) {
                return matchers.length > 1 ? function(elem, context, xml) {
                    for (var i = matchers.length; i--;)
                        if (!matchers[i](elem, context, xml)) return !1;
                    return !0
                } : matchers[0]
            }

            function condense(unmatched, map, filter, context, xml) {
                for (var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = null != map; i < len; i++)(elem = unmatched[i]) && (filter && !filter(elem, context, xml) || (newUnmatched.push(elem), mapped && map.push(i)));
                return newUnmatched
            }

            function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
                return postFilter && !postFilter[expando] && (postFilter = setMatcher(postFilter)), postFinder && !postFinder[expando] && (postFinder = setMatcher(postFinder, postSelector)), markFunction(function(seed, results, context, xml) {
                    var temp, i, elem, preMap = [],
                        postMap = [],
                        preexisting = results.length,
                        elems = seed || function(selector, contexts, results) {
                            for (var i = 0, len = contexts.length; i < len; i++) Sizzle(selector, contexts[i], results);
                            return results
                        }(selector || "*", context.nodeType ? [context] : context, []),
                        matcherIn = !preFilter || !seed && selector ? elems : condense(elems, preMap, preFilter, context, xml),
                        matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                    if (matcher && matcher(matcherIn, matcherOut, context, xml), postFilter)
                        for (temp = condense(matcherOut, postMap), postFilter(temp, [], context, xml), i = temp.length; i--;)(elem = temp[i]) && (matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem));
                    if (seed) {
                        if (postFinder || preFilter) {
                            if (postFinder) {
                                for (temp = [], i = matcherOut.length; i--;)(elem = matcherOut[i]) && temp.push(matcherIn[i] = elem);
                                postFinder(null, matcherOut = [], temp, xml)
                            }
                            for (i = matcherOut.length; i--;)(elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1 && (seed[temp] = !(results[temp] = elem))
                        }
                    } else matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut), postFinder ? postFinder(null, results, matcherOut, xml) : push.apply(results, matcherOut)
                })
            }

            function matcherFromTokens(tokens) {
                for (var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
                        return elem === checkContext
                    }, implicitRelative, !0), matchAnyContext = addCombinator(function(elem) {
                        return indexOf(checkContext, elem) > -1
                    }, implicitRelative, !0), matchers = [function(elem, context, xml) {
                        var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                        return checkContext = null, ret
                    }]; i < len; i++)
                    if (matcher = Expr.relative[tokens[i].type]) matchers = [addCombinator(elementMatcher(matchers), matcher)];
                    else {
                        if ((matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches))[expando]) {
                            for (j = ++i; j < len && !Expr.relative[tokens[j].type]; j++);
                            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({
                                value: " " === tokens[i - 2].type ? "*" : ""
                            })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens))
                        }
                        matchers.push(matcher)
                    } return elementMatcher(matchers)
            }
            return setFilters.prototype = Expr.filters = Expr.pseudos, Expr.setFilters = new setFilters, tokenize = Sizzle.tokenize = function(selector, parseOnly) {
                var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
                if (cached) return parseOnly ? 0 : cached.slice(0);
                for (soFar = selector, groups = [], preFilters = Expr.preFilter; soFar;) {
                    for (type in matched && !(match = rcomma.exec(soFar)) || (match && (soFar = soFar.slice(match[0].length) || soFar), groups.push(tokens = [])), matched = !1, (match = rcombinators.exec(soFar)) && (matched = match.shift(), tokens.push({
                            value: matched,
                            type: match[0].replace(rtrim, " ")
                        }), soFar = soFar.slice(matched.length)), Expr.filter) !(match = matchExpr[type].exec(soFar)) || preFilters[type] && !(match = preFilters[type](match)) || (matched = match.shift(), tokens.push({
                        value: matched,
                        type: type,
                        matches: match
                    }), soFar = soFar.slice(matched.length));
                    if (!matched) break
                }
                return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0)
            }, compile = Sizzle.compile = function(selector, match) {
                var i, setMatchers = [],
                    elementMatchers = [],
                    cached = compilerCache[selector + " "];
                if (!cached) {
                    for (match || (match = tokenize(selector)), i = match.length; i--;)(cached = matcherFromTokens(match[i]))[expando] ? setMatchers.push(cached) : elementMatchers.push(cached);
                    (cached = compilerCache(selector, function(elementMatchers, setMatchers) {
                        var bySet = setMatchers.length > 0,
                            byElement = elementMatchers.length > 0,
                            superMatcher = function(seed, context, xml, results, outermost) {
                                var elem, j, matcher, matchedCount = 0,
                                    i = "0",
                                    unmatched = seed && [],
                                    setMatched = [],
                                    contextBackup = outermostContext,
                                    elems = seed || byElement && Expr.find.TAG("*", outermost),
                                    dirrunsUnique = dirruns += null == contextBackup ? 1 : Math.random() || .1,
                                    len = elems.length;
                                for (outermost && (outermostContext = context !== document && context); i !== len && null != (elem = elems[i]); i++) {
                                    if (byElement && elem) {
                                        for (j = 0; matcher = elementMatchers[j++];)
                                            if (matcher(elem, context, xml)) {
                                                results.push(elem);
                                                break
                                            } outermost && (dirruns = dirrunsUnique)
                                    }
                                    bySet && ((elem = !matcher && elem) && matchedCount--, seed && unmatched.push(elem))
                                }
                                if (matchedCount += i, bySet && i !== matchedCount) {
                                    for (j = 0; matcher = setMatchers[j++];) matcher(unmatched, setMatched, context, xml);
                                    if (seed) {
                                        if (matchedCount > 0)
                                            for (; i--;) unmatched[i] || setMatched[i] || (setMatched[i] = pop.call(results));
                                        setMatched = condense(setMatched)
                                    }
                                    push.apply(results, setMatched), outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1 && Sizzle.uniqueSort(results)
                                }
                                return outermost && (dirruns = dirrunsUnique, outermostContext = contextBackup), unmatched
                            };
                        return bySet ? markFunction(superMatcher) : superMatcher
                    }(elementMatchers, setMatchers))).selector = selector
                }
                return cached
            }, select = Sizzle.select = function(selector, context, results, seed) {
                var i, tokens, token, type, find, compiled = "function" == typeof selector && selector,
                    match = !seed && tokenize(selector = compiled.selector || selector);
                if (results = results || [], 1 === match.length) {
                    if ((tokens = match[0] = match[0].slice(0)).length > 2 && "ID" === (token = tokens[0]).type && support.getById && 9 === context.nodeType && documentIsHTML && Expr.relative[tokens[1].type]) {
                        if (!(context = (Expr.find.ID(token.matches[0].replace(runescape, funescape), context) || [])[0])) return results;
                        compiled && (context = context.parentNode), selector = selector.slice(tokens.shift().value.length)
                    }
                    for (i = matchExpr.needsContext.test(selector) ? 0 : tokens.length; i-- && (token = tokens[i], !Expr.relative[type = token.type]);)
                        if ((find = Expr.find[type]) && (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {
                            if (tokens.splice(i, 1), !(selector = seed.length && toSelector(tokens))) return push.apply(results, seed), results;
                            break
                        }
                }
                return (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context), results
            }, support.sortStable = expando.split("").sort(sortOrder).join("") === expando, support.detectDuplicates = !!hasDuplicate, setDocument(), support.sortDetached = assert(function(div1) {
                return 1 & div1.compareDocumentPosition(document.createElement("div"))
            }), assert(function(div) {
                return div.innerHTML = "<a href='#'></a>", "#" === div.firstChild.getAttribute("href")
            }) || addHandle("type|href|height|width", function(elem, name, isXML) {
                if (!isXML) return elem.getAttribute(name, "type" === name.toLowerCase() ? 1 : 2)
            }), support.attributes && assert(function(div) {
                return div.innerHTML = "<input/>", div.firstChild.setAttribute("value", ""), "" === div.firstChild.getAttribute("value")
            }) || addHandle("value", function(elem, name, isXML) {
                if (!isXML && "input" === elem.nodeName.toLowerCase()) return elem.defaultValue
            }), assert(function(div) {
                return null == div.getAttribute("disabled")
            }) || addHandle(booleans, function(elem, name, isXML) {
                var val;
                if (!isXML) return !0 === elem[name] ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null
            }), Sizzle
        }(window);
        jQuery.find = Sizzle, jQuery.expr = Sizzle.selectors, jQuery.expr[":"] = jQuery.expr.pseudos, jQuery.unique = Sizzle.uniqueSort, jQuery.text = Sizzle.getText, jQuery.isXMLDoc = Sizzle.isXML, jQuery.contains = Sizzle.contains;
        var rneedsContext = jQuery.expr.match.needsContext,
            rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
            risSimple = /^.[^:#\[\.,]*$/;

        function winnow(elements, qualifier, not) {
            if (jQuery.isFunction(qualifier)) return jQuery.grep(elements, function(elem, i) {
                return !!qualifier.call(elem, i, elem) !== not
            });
            if (qualifier.nodeType) return jQuery.grep(elements, function(elem) {
                return elem === qualifier !== not
            });
            if ("string" == typeof qualifier) {
                if (risSimple.test(qualifier)) return jQuery.filter(qualifier, elements, not);
                qualifier = jQuery.filter(qualifier, elements)
            }
            return jQuery.grep(elements, function(elem) {
                return jQuery.inArray(elem, qualifier) >= 0 !== not
            })
        }
        jQuery.filter = function(expr, elems, not) {
            var elem = elems[0];
            return not && (expr = ":not(" + expr + ")"), 1 === elems.length && 1 === elem.nodeType ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
                return 1 === elem.nodeType
            }))
        }, jQuery.fn.extend({
            find: function(selector) {
                var i, ret = [],
                    self = this,
                    len = self.length;
                if ("string" != typeof selector) return this.pushStack(jQuery(selector).filter(function() {
                    for (i = 0; i < len; i++)
                        if (jQuery.contains(self[i], this)) return !0
                }));
                for (i = 0; i < len; i++) jQuery.find(selector, self[i], ret);
                return (ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret)).selector = this.selector ? this.selector + " " + selector : selector, ret
            },
            filter: function(selector) {
                return this.pushStack(winnow(this, selector || [], !1))
            },
            not: function(selector) {
                return this.pushStack(winnow(this, selector || [], !0))
            },
            is: function(selector) {
                return !!winnow(this, "string" == typeof selector && rneedsContext.test(selector) ? jQuery(selector) : selector || [], !1).length
            }
        });
        var rootjQuery, document = window.document,
            rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/;
        (jQuery.fn.init = function(selector, context) {
            var match, elem;
            if (!selector) return this;
            if ("string" == typeof selector) {
                if (!(match = "<" === selector.charAt(0) && ">" === selector.charAt(selector.length - 1) && selector.length >= 3 ? [null, selector, null] : rquickExpr.exec(selector)) || !match[1] && context) return !context || context.jquery ? (context || rootjQuery).find(selector) : this.constructor(context).find(selector);
                if (match[1]) {
                    if (context = context instanceof jQuery ? context[0] : context, jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, !0)), rsingleTag.test(match[1]) && jQuery.isPlainObject(context))
                        for (match in context) jQuery.isFunction(this[match]) ? this[match](context[match]) : this.attr(match, context[match]);
                    return this
                }
                if ((elem = document.getElementById(match[2])) && elem.parentNode) {
                    if (elem.id !== match[2]) return rootjQuery.find(selector);
                    this.length = 1, this[0] = elem
                }
                return this.context = document, this.selector = selector, this
            }
            return selector.nodeType ? (this.context = this[0] = selector, this.length = 1, this) : jQuery.isFunction(selector) ? void 0 !== rootjQuery.ready ? rootjQuery.ready(selector) : selector(jQuery) : (void 0 !== selector.selector && (this.selector = selector.selector, this.context = selector.context), jQuery.makeArray(selector, this))
        }).prototype = jQuery.fn, rootjQuery = jQuery(document);
        var rparentsprev = /^(?:parents|prev(?:Until|All))/,
            guaranteedUnique = {
                children: !0,
                contents: !0,
                next: !0,
                prev: !0
            };

        function sibling(cur, dir) {
            do {
                cur = cur[dir]
            } while (cur && 1 !== cur.nodeType);
            return cur
        }
        jQuery.extend({
            dir: function(elem, dir, until) {
                for (var matched = [], cur = elem[dir]; cur && 9 !== cur.nodeType && (void 0 === until || 1 !== cur.nodeType || !jQuery(cur).is(until));) 1 === cur.nodeType && matched.push(cur), cur = cur[dir];
                return matched
            },
            sibling: function(n, elem) {
                for (var r = []; n; n = n.nextSibling) 1 === n.nodeType && n !== elem && r.push(n);
                return r
            }
        }), jQuery.fn.extend({
            has: function(target) {
                var i, targets = jQuery(target, this),
                    len = targets.length;
                return this.filter(function() {
                    for (i = 0; i < len; i++)
                        if (jQuery.contains(this, targets[i])) return !0
                })
            },
            closest: function(selectors, context) {
                for (var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || "string" != typeof selectors ? jQuery(selectors, context || this.context) : 0; i < l; i++)
                    for (cur = this[i]; cur && cur !== context; cur = cur.parentNode)
                        if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : 1 === cur.nodeType && jQuery.find.matchesSelector(cur, selectors))) {
                            matched.push(cur);
                            break
                        } return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched)
            },
            index: function(elem) {
                return elem ? "string" == typeof elem ? jQuery.inArray(this[0], jQuery(elem)) : jQuery.inArray(elem.jquery ? elem[0] : elem, this) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
            },
            add: function(selector, context) {
                return this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))))
            },
            addBack: function(selector) {
                return this.add(null == selector ? this.prevObject : this.prevObject.filter(selector))
            }
        }), jQuery.each({
            parent: function(elem) {
                var parent = elem.parentNode;
                return parent && 11 !== parent.nodeType ? parent : null
            },
            parents: function(elem) {
                return jQuery.dir(elem, "parentNode")
            },
            parentsUntil: function(elem, i, until) {
                return jQuery.dir(elem, "parentNode", until)
            },
            next: function(elem) {
                return sibling(elem, "nextSibling")
            },
            prev: function(elem) {
                return sibling(elem, "previousSibling")
            },
            nextAll: function(elem) {
                return jQuery.dir(elem, "nextSibling")
            },
            prevAll: function(elem) {
                return jQuery.dir(elem, "previousSibling")
            },
            nextUntil: function(elem, i, until) {
                return jQuery.dir(elem, "nextSibling", until)
            },
            prevUntil: function(elem, i, until) {
                return jQuery.dir(elem, "previousSibling", until)
            },
            siblings: function(elem) {
                return jQuery.sibling((elem.parentNode || {}).firstChild, elem)
            },
            children: function(elem) {
                return jQuery.sibling(elem.firstChild)
            },
            contents: function(elem) {
                return jQuery.nodeName(elem, "iframe") ? elem.contentDocument || elem.contentWindow.document : jQuery.merge([], elem.childNodes)
            }
        }, function(name, fn) {
            jQuery.fn[name] = function(until, selector) {
                var ret = jQuery.map(this, fn, until);
                return "Until" !== name.slice(-5) && (selector = until), selector && "string" == typeof selector && (ret = jQuery.filter(selector, ret)), this.length > 1 && (guaranteedUnique[name] || (ret = jQuery.unique(ret)), rparentsprev.test(name) && (ret = ret.reverse())), this.pushStack(ret)
            }
        });
        var readyList, rnotwhite = /\S+/g,
            optionsCache = {};

        function detach() {
            document.addEventListener ? (document.removeEventListener("DOMContentLoaded", completed, !1), window.removeEventListener("load", completed, !1)) : (document.detachEvent("onreadystatechange", completed), window.detachEvent("onload", completed))
        }

        function completed() {
            (document.addEventListener || "load" === event.type || "complete" === document.readyState) && (detach(), jQuery.ready())
        }
        jQuery.Callbacks = function(options) {
            var firing, memory, fired, firingLength, firingIndex, firingStart, list = [],
                stack = !(options = "string" == typeof options ? optionsCache[options] || function(options) {
                    var object = optionsCache[options] = {};
                    return jQuery.each(options.match(rnotwhite) || [], function(_, flag) {
                        object[flag] = !0
                    }), object
                }(options) : jQuery.extend({}, options)).once && [],
                fire = function(data) {
                    for (memory = options.memory && data, fired = !0, firingIndex = firingStart || 0, firingStart = 0, firingLength = list.length, firing = !0; list && firingIndex < firingLength; firingIndex++)
                        if (!1 === list[firingIndex].apply(data[0], data[1]) && options.stopOnFalse) {
                            memory = !1;
                            break
                        } firing = !1, list && (stack ? stack.length && fire(stack.shift()) : memory ? list = [] : self.disable())
                },
                self = {
                    add: function() {
                        if (list) {
                            var start = list.length;
                            ! function add(args) {
                                jQuery.each(args, function(_, arg) {
                                    var type = jQuery.type(arg);
                                    "function" === type ? options.unique && self.has(arg) || list.push(arg) : arg && arg.length && "string" !== type && add(arg)
                                })
                            }(arguments), firing ? firingLength = list.length : memory && (firingStart = start, fire(memory))
                        }
                        return this
                    },
                    remove: function() {
                        return list && jQuery.each(arguments, function(_, arg) {
                            for (var index;
                                (index = jQuery.inArray(arg, list, index)) > -1;) list.splice(index, 1), firing && (index <= firingLength && firingLength--, index <= firingIndex && firingIndex--)
                        }), this
                    },
                    has: function(fn) {
                        return fn ? jQuery.inArray(fn, list) > -1 : !(!list || !list.length)
                    },
                    empty: function() {
                        return list = [], firingLength = 0, this
                    },
                    disable: function() {
                        return list = stack = memory = void 0, this
                    },
                    disabled: function() {
                        return !list
                    },
                    lock: function() {
                        return stack = void 0, memory || self.disable(), this
                    },
                    locked: function() {
                        return !stack
                    },
                    fireWith: function(context, args) {
                        return !list || fired && !stack || (args = [context, (args = args || []).slice ? args.slice() : args], firing ? stack.push(args) : fire(args)), this
                    },
                    fire: function() {
                        return self.fireWith(this, arguments), this
                    },
                    fired: function() {
                        return !!fired
                    }
                };
            return self
        }, jQuery.extend({
            Deferred: function(func) {
                var tuples = [
                        ["resolve", "done", jQuery.Callbacks("once memory"), "resolved"],
                        ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"],
                        ["notify", "progress", jQuery.Callbacks("memory")]
                    ],
                    state = "pending",
                    promise = {
                        state: function() {
                            return state
                        },
                        always: function() {
                            return deferred.done(arguments).fail(arguments), this
                        },
                        then: function() {
                            var fns = arguments;
                            return jQuery.Deferred(function(newDefer) {
                                jQuery.each(tuples, function(i, tuple) {
                                    var fn = jQuery.isFunction(fns[i]) && fns[i];
                                    deferred[tuple[1]](function() {
                                        var returned = fn && fn.apply(this, arguments);
                                        returned && jQuery.isFunction(returned.promise) ? returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify) : newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments)
                                    })
                                }), fns = null
                            }).promise()
                        },
                        promise: function(obj) {
                            return null != obj ? jQuery.extend(obj, promise) : promise
                        }
                    },
                    deferred = {};
                return promise.pipe = promise.then, jQuery.each(tuples, function(i, tuple) {
                    var list = tuple[2],
                        stateString = tuple[3];
                    promise[tuple[1]] = list.add, stateString && list.add(function() {
                        state = stateString
                    }, tuples[1 ^ i][2].disable, tuples[2][2].lock), deferred[tuple[0]] = function() {
                        return deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments), this
                    }, deferred[tuple[0] + "With"] = list.fireWith
                }), promise.promise(deferred), func && func.call(deferred, deferred), deferred
            },
            when: function(subordinate) {
                var progressValues, progressContexts, resolveContexts, i = 0,
                    resolveValues = slice.call(arguments),
                    length = resolveValues.length,
                    remaining = 1 !== length || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0,
                    deferred = 1 === remaining ? subordinate : jQuery.Deferred(),
                    updateFunc = function(i, contexts, values) {
                        return function(value) {
                            contexts[i] = this, values[i] = arguments.length > 1 ? slice.call(arguments) : value, values === progressValues ? deferred.notifyWith(contexts, values) : --remaining || deferred.resolveWith(contexts, values)
                        }
                    };
                if (length > 1)
                    for (progressValues = new Array(length), progressContexts = new Array(length), resolveContexts = new Array(length); i < length; i++) resolveValues[i] && jQuery.isFunction(resolveValues[i].promise) ? resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues)) : --remaining;
                return remaining || deferred.resolveWith(resolveContexts, resolveValues), deferred.promise()
            }
        }), jQuery.fn.ready = function(fn) {
            return jQuery.ready.promise().done(fn), this
        }, jQuery.extend({
            isReady: !1,
            readyWait: 1,
            holdReady: function(hold) {
                hold ? jQuery.readyWait++ : jQuery.ready(!0)
            },
            ready: function(wait) {
                if (!0 === wait ? !--jQuery.readyWait : !jQuery.isReady) {
                    if (!document.body) return setTimeout(jQuery.ready);
                    jQuery.isReady = !0, !0 !== wait && --jQuery.readyWait > 0 || (readyList.resolveWith(document, [jQuery]), jQuery.fn.triggerHandler && (jQuery(document).triggerHandler("ready"), jQuery(document).off("ready")))
                }
            }
        }), jQuery.ready.promise = function(obj) {
            if (!readyList)
                if (readyList = jQuery.Deferred(), "complete" === document.readyState) setTimeout(jQuery.ready);
                else if (document.addEventListener) document.addEventListener("DOMContentLoaded", completed, !1), window.addEventListener("load", completed, !1);
            else {
                document.attachEvent("onreadystatechange", completed), window.attachEvent("onload", completed);
                var top = !1;
                try {
                    top = null == window.frameElement && document.documentElement
                } catch (e) {}
                top && top.doScroll && function doScrollCheck() {
                    if (!jQuery.isReady) {
                        try {
                            top.doScroll("left")
                        } catch (e) {
                            return setTimeout(doScrollCheck, 50)
                        }
                        detach(), jQuery.ready()
                    }
                }()
            }
            return readyList.promise(obj)
        };
        var i, strundefined = "undefined";
        for (i in jQuery(support)) break;
        support.ownLast = "0" !== i, support.inlineBlockNeedsLayout = !1, jQuery(function() {
                var val, div, body, container;
                (body = document.getElementsByTagName("body")[0]) && body.style && (div = document.createElement("div"), (container = document.createElement("div")).style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", body.appendChild(container).appendChild(div), typeof div.style.zoom !== strundefined && (div.style.cssText = "display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1", support.inlineBlockNeedsLayout = val = 3 === div.offsetWidth, val && (body.style.zoom = 1)), body.removeChild(container))
            }),
            function() {
                var div = document.createElement("div");
                if (null == support.deleteExpando) {
                    support.deleteExpando = !0;
                    try {
                        delete div.test
                    } catch (e) {
                        support.deleteExpando = !1
                    }
                }
                div = null
            }(), jQuery.acceptData = function(elem) {
                var noData = jQuery.noData[(elem.nodeName + " ").toLowerCase()],
                    nodeType = +elem.nodeType || 1;
                return (1 === nodeType || 9 === nodeType) && (!noData || !0 !== noData && elem.getAttribute("classid") === noData)
            };
        var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
            rmultiDash = /([A-Z])/g;

        function dataAttr(elem, key, data) {
            if (void 0 === data && 1 === elem.nodeType) {
                var name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();
                if ("string" == typeof(data = elem.getAttribute(name))) {
                    try {
                        data = "true" === data || "false" !== data && ("null" === data ? null : +data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data)
                    } catch (e) {}
                    jQuery.data(elem, key, data)
                } else data = void 0
            }
            return data
        }

        function isEmptyDataObject(obj) {
            var name;
            for (name in obj)
                if (("data" !== name || !jQuery.isEmptyObject(obj[name])) && "toJSON" !== name) return !1;
            return !0
        }

        function internalData(elem, name, data, pvt) {
            if (jQuery.acceptData(elem)) {
                var ret, thisCache, internalKey = jQuery.expando,
                    isNode = elem.nodeType,
                    cache = isNode ? jQuery.cache : elem,
                    id = isNode ? elem[internalKey] : elem[internalKey] && internalKey;
                if (id && cache[id] && (pvt || cache[id].data) || void 0 !== data || "string" != typeof name) return id || (id = isNode ? elem[internalKey] = deletedIds.pop() || jQuery.guid++ : internalKey), cache[id] || (cache[id] = isNode ? {} : {
                    toJSON: jQuery.noop
                }), "object" != typeof name && "function" != typeof name || (pvt ? cache[id] = jQuery.extend(cache[id], name) : cache[id].data = jQuery.extend(cache[id].data, name)), thisCache = cache[id], pvt || (thisCache.data || (thisCache.data = {}), thisCache = thisCache.data), void 0 !== data && (thisCache[jQuery.camelCase(name)] = data), "string" == typeof name ? null == (ret = thisCache[name]) && (ret = thisCache[jQuery.camelCase(name)]) : ret = thisCache, ret
            }
        }

        function internalRemoveData(elem, name, pvt) {
            if (jQuery.acceptData(elem)) {
                var thisCache, i, isNode = elem.nodeType,
                    cache = isNode ? jQuery.cache : elem,
                    id = isNode ? elem[jQuery.expando] : jQuery.expando;
                if (cache[id]) {
                    if (name && (thisCache = pvt ? cache[id] : cache[id].data)) {
                        i = (name = jQuery.isArray(name) ? name.concat(jQuery.map(name, jQuery.camelCase)) : name in thisCache ? [name] : (name = jQuery.camelCase(name)) in thisCache ? [name] : name.split(" ")).length;
                        for (; i--;) delete thisCache[name[i]];
                        if (pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache)) return
                    }(pvt || (delete cache[id].data, isEmptyDataObject(cache[id]))) && (isNode ? jQuery.cleanData([elem], !0) : support.deleteExpando || cache != cache.window ? delete cache[id] : cache[id] = null)
                }
            }
        }
        jQuery.extend({
            cache: {},
            noData: {
                "applet ": !0,
                "embed ": !0,
                "object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
            },
            hasData: function(elem) {
                return !!(elem = elem.nodeType ? jQuery.cache[elem[jQuery.expando]] : elem[jQuery.expando]) && !isEmptyDataObject(elem)
            },
            data: function(elem, name, data) {
                return internalData(elem, name, data)
            },
            removeData: function(elem, name) {
                return internalRemoveData(elem, name)
            },
            _data: function(elem, name, data) {
                return internalData(elem, name, data, !0)
            },
            _removeData: function(elem, name) {
                return internalRemoveData(elem, name, !0)
            }
        }), jQuery.fn.extend({
            data: function(key, value) {
                var i, name, data, elem = this[0],
                    attrs = elem && elem.attributes;
                if (void 0 === key) {
                    if (this.length && (data = jQuery.data(elem), 1 === elem.nodeType && !jQuery._data(elem, "parsedAttrs"))) {
                        for (i = attrs.length; i--;) attrs[i] && 0 === (name = attrs[i].name).indexOf("data-") && dataAttr(elem, name = jQuery.camelCase(name.slice(5)), data[name]);
                        jQuery._data(elem, "parsedAttrs", !0)
                    }
                    return data
                }
                return "object" == typeof key ? this.each(function() {
                    jQuery.data(this, key)
                }) : arguments.length > 1 ? this.each(function() {
                    jQuery.data(this, key, value)
                }) : elem ? dataAttr(elem, key, jQuery.data(elem, key)) : void 0
            },
            removeData: function(key) {
                return this.each(function() {
                    jQuery.removeData(this, key)
                })
            }
        }), jQuery.extend({
            queue: function(elem, type, data) {
                var queue;
                if (elem) return type = (type || "fx") + "queue", queue = jQuery._data(elem, type), data && (!queue || jQuery.isArray(data) ? queue = jQuery._data(elem, type, jQuery.makeArray(data)) : queue.push(data)), queue || []
            },
            dequeue: function(elem, type) {
                type = type || "fx";
                var queue = jQuery.queue(elem, type),
                    startLength = queue.length,
                    fn = queue.shift(),
                    hooks = jQuery._queueHooks(elem, type);
                "inprogress" === fn && (fn = queue.shift(), startLength--), fn && ("fx" === type && queue.unshift("inprogress"), delete hooks.stop, fn.call(elem, function() {
                    jQuery.dequeue(elem, type)
                }, hooks)), !startLength && hooks && hooks.empty.fire()
            },
            _queueHooks: function(elem, type) {
                var key = type + "queueHooks";
                return jQuery._data(elem, key) || jQuery._data(elem, key, {
                    empty: jQuery.Callbacks("once memory").add(function() {
                        jQuery._removeData(elem, type + "queue"), jQuery._removeData(elem, key)
                    })
                })
            }
        }), jQuery.fn.extend({
            queue: function(type, data) {
                var setter = 2;
                return "string" != typeof type && (data = type, type = "fx", setter--), arguments.length < setter ? jQuery.queue(this[0], type) : void 0 === data ? this : this.each(function() {
                    var queue = jQuery.queue(this, type, data);
                    jQuery._queueHooks(this, type), "fx" === type && "inprogress" !== queue[0] && jQuery.dequeue(this, type)
                })
            },
            dequeue: function(type) {
                return this.each(function() {
                    jQuery.dequeue(this, type)
                })
            },
            clearQueue: function(type) {
                return this.queue(type || "fx", [])
            },
            promise: function(type, obj) {
                var tmp, count = 1,
                    defer = jQuery.Deferred(),
                    elements = this,
                    i = this.length,
                    resolve = function() {
                        --count || defer.resolveWith(elements, [elements])
                    };
                for ("string" != typeof type && (obj = type, type = void 0), type = type || "fx"; i--;)(tmp = jQuery._data(elements[i], type + "queueHooks")) && tmp.empty && (count++, tmp.empty.add(resolve));
                return resolve(), defer.promise(obj)
            }
        });
        var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
            cssExpand = ["Top", "Right", "Bottom", "Left"],
            isHidden = function(elem, el) {
                return elem = el || elem, "none" === jQuery.css(elem, "display") || !jQuery.contains(elem.ownerDocument, elem)
            },
            access = jQuery.access = function(elems, fn, key, value, chainable, emptyGet, raw) {
                var i = 0,
                    length = elems.length,
                    bulk = null == key;
                if ("object" === jQuery.type(key))
                    for (i in chainable = !0, key) jQuery.access(elems, fn, i, key[i], !0, emptyGet, raw);
                else if (void 0 !== value && (chainable = !0, jQuery.isFunction(value) || (raw = !0), bulk && (raw ? (fn.call(elems, value), fn = null) : (bulk = fn, fn = function(elem, key, value) {
                        return bulk.call(jQuery(elem), value)
                    })), fn))
                    for (; i < length; i++) fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                return chainable ? elems : bulk ? fn.call(elems) : length ? fn(elems[0], key) : emptyGet
            },
            rcheckableType = /^(?:checkbox|radio)$/i;
        ! function() {
            var input = document.createElement("input"),
                div = document.createElement("div"),
                fragment = document.createDocumentFragment();
            if (div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", support.leadingWhitespace = 3 === div.firstChild.nodeType, support.tbody = !div.getElementsByTagName("tbody").length, support.htmlSerialize = !!div.getElementsByTagName("link").length, support.html5Clone = "<:nav></:nav>" !== document.createElement("nav").cloneNode(!0).outerHTML, input.type = "checkbox", input.checked = !0, fragment.appendChild(input), support.appendChecked = input.checked, div.innerHTML = "<textarea>x</textarea>", support.noCloneChecked = !!div.cloneNode(!0).lastChild.defaultValue, fragment.appendChild(div), div.innerHTML = "<input type='radio' checked='checked' name='t'/>", support.checkClone = div.cloneNode(!0).cloneNode(!0).lastChild.checked, support.noCloneEvent = !0, div.attachEvent && (div.attachEvent("onclick", function() {
                    support.noCloneEvent = !1
                }), div.cloneNode(!0).click()), null == support.deleteExpando) {
                support.deleteExpando = !0;
                try {
                    delete div.test
                } catch (e) {
                    support.deleteExpando = !1
                }
            }
        }(),
        function() {
            var i, eventName, div = document.createElement("div");
            for (i in {
                    submit: !0,
                    change: !0,
                    focusin: !0
                }) eventName = "on" + i, (support[i + "Bubbles"] = eventName in window) || (div.setAttribute(eventName, "t"), support[i + "Bubbles"] = !1 === div.attributes[eventName].expando);
            div = null
        }();
        var rformElems = /^(?:input|select|textarea)$/i,
            rkeyEvent = /^key/,
            rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
            rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
            rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

        function returnTrue() {
            return !0
        }

        function returnFalse() {
            return !1
        }

        function safeActiveElement() {
            try {
                return document.activeElement
            } catch (err) {}
        }

        function createSafeFragment(document) {
            var list = nodeNames.split("|"),
                safeFrag = document.createDocumentFragment();
            if (safeFrag.createElement)
                for (; list.length;) safeFrag.createElement(list.pop());
            return safeFrag
        }
        jQuery.event = {
            global: {},
            add: function(elem, types, handler, data, selector) {
                var tmp, events, t, handleObjIn, special, eventHandle, handleObj, handlers, type, namespaces, origType, elemData = jQuery._data(elem);
                if (elemData) {
                    for (handler.handler && (handler = (handleObjIn = handler).handler, selector = handleObjIn.selector), handler.guid || (handler.guid = jQuery.guid++), (events = elemData.events) || (events = elemData.events = {}), (eventHandle = elemData.handle) || ((eventHandle = elemData.handle = function(e) {
                            return typeof jQuery === strundefined || e && jQuery.event.triggered === e.type ? void 0 : jQuery.event.dispatch.apply(eventHandle.elem, arguments)
                        }).elem = elem), t = (types = (types || "").match(rnotwhite) || [""]).length; t--;) type = origType = (tmp = rtypenamespace.exec(types[t]) || [])[1], namespaces = (tmp[2] || "").split(".").sort(), type && (special = jQuery.event.special[type] || {}, type = (selector ? special.delegateType : special.bindType) || type, special = jQuery.event.special[type] || {}, handleObj = jQuery.extend({
                        type: type,
                        origType: origType,
                        data: data,
                        handler: handler,
                        guid: handler.guid,
                        selector: selector,
                        needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                        namespace: namespaces.join(".")
                    }, handleObjIn), (handlers = events[type]) || ((handlers = events[type] = []).delegateCount = 0, special.setup && !1 !== special.setup.call(elem, data, namespaces, eventHandle) || (elem.addEventListener ? elem.addEventListener(type, eventHandle, !1) : elem.attachEvent && elem.attachEvent("on" + type, eventHandle))), special.add && (special.add.call(elem, handleObj), handleObj.handler.guid || (handleObj.handler.guid = handler.guid)), selector ? handlers.splice(handlers.delegateCount++, 0, handleObj) : handlers.push(handleObj), jQuery.event.global[type] = !0);
                    elem = null
                }
            },
            remove: function(elem, types, handler, selector, mappedTypes) {
                var j, handleObj, tmp, origCount, t, events, special, handlers, type, namespaces, origType, elemData = jQuery.hasData(elem) && jQuery._data(elem);
                if (elemData && (events = elemData.events)) {
                    for (t = (types = (types || "").match(rnotwhite) || [""]).length; t--;)
                        if (type = origType = (tmp = rtypenamespace.exec(types[t]) || [])[1], namespaces = (tmp[2] || "").split(".").sort(), type) {
                            for (special = jQuery.event.special[type] || {}, handlers = events[type = (selector ? special.delegateType : special.bindType) || type] || [], tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"), origCount = j = handlers.length; j--;) handleObj = handlers[j], !mappedTypes && origType !== handleObj.origType || handler && handler.guid !== handleObj.guid || tmp && !tmp.test(handleObj.namespace) || selector && selector !== handleObj.selector && ("**" !== selector || !handleObj.selector) || (handlers.splice(j, 1), handleObj.selector && handlers.delegateCount--, special.remove && special.remove.call(elem, handleObj));
                            origCount && !handlers.length && (special.teardown && !1 !== special.teardown.call(elem, namespaces, elemData.handle) || jQuery.removeEvent(elem, type, elemData.handle), delete events[type])
                        } else
                            for (type in events) jQuery.event.remove(elem, type + types[t], handler, selector, !0);
                    jQuery.isEmptyObject(events) && (delete elemData.handle, jQuery._removeData(elem, "events"))
                }
            },
            trigger: function(event, data, elem, onlyHandlers) {
                var handle, ontype, cur, bubbleType, special, tmp, i, eventPath = [elem || document],
                    type = hasOwn.call(event, "type") ? event.type : event,
                    namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
                if (cur = tmp = elem = elem || document, 3 !== elem.nodeType && 8 !== elem.nodeType && !rfocusMorph.test(type + jQuery.event.triggered) && (type.indexOf(".") >= 0 && (type = (namespaces = type.split(".")).shift(), namespaces.sort()), ontype = type.indexOf(":") < 0 && "on" + type, (event = event[jQuery.expando] ? event : new jQuery.Event(type, "object" == typeof event && event)).isTrigger = onlyHandlers ? 2 : 3, event.namespace = namespaces.join("."), event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, event.result = void 0, event.target || (event.target = elem), data = null == data ? [event] : jQuery.makeArray(data, [event]), special = jQuery.event.special[type] || {}, onlyHandlers || !special.trigger || !1 !== special.trigger.apply(elem, data))) {
                    if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                        for (bubbleType = special.delegateType || type, rfocusMorph.test(bubbleType + type) || (cur = cur.parentNode); cur; cur = cur.parentNode) eventPath.push(cur), tmp = cur;
                        tmp === (elem.ownerDocument || document) && eventPath.push(tmp.defaultView || tmp.parentWindow || window)
                    }
                    for (i = 0;
                        (cur = eventPath[i++]) && !event.isPropagationStopped();) event.type = i > 1 ? bubbleType : special.bindType || type, (handle = (jQuery._data(cur, "events") || {})[event.type] && jQuery._data(cur, "handle")) && handle.apply(cur, data), (handle = ontype && cur[ontype]) && handle.apply && jQuery.acceptData(cur) && (event.result = handle.apply(cur, data), !1 === event.result && event.preventDefault());
                    if (event.type = type, !onlyHandlers && !event.isDefaultPrevented() && (!special._default || !1 === special._default.apply(eventPath.pop(), data)) && jQuery.acceptData(elem) && ontype && elem[type] && !jQuery.isWindow(elem)) {
                        (tmp = elem[ontype]) && (elem[ontype] = null), jQuery.event.triggered = type;
                        try {
                            elem[type]()
                        } catch (e) {}
                        jQuery.event.triggered = void 0, tmp && (elem[ontype] = tmp)
                    }
                    return event.result
                }
            },
            dispatch: function(event) {
                event = jQuery.event.fix(event);
                var i, ret, handleObj, matched, j, handlerQueue, args = slice.call(arguments),
                    handlers = (jQuery._data(this, "events") || {})[event.type] || [],
                    special = jQuery.event.special[event.type] || {};
                if (args[0] = event, event.delegateTarget = this, !special.preDispatch || !1 !== special.preDispatch.call(this, event)) {
                    for (handlerQueue = jQuery.event.handlers.call(this, event, handlers), i = 0;
                        (matched = handlerQueue[i++]) && !event.isPropagationStopped();)
                        for (event.currentTarget = matched.elem, j = 0;
                            (handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped();) event.namespace_re && !event.namespace_re.test(handleObj.namespace) || (event.handleObj = handleObj, event.data = handleObj.data, void 0 !== (ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args)) && !1 === (event.result = ret) && (event.preventDefault(), event.stopPropagation()));
                    return special.postDispatch && special.postDispatch.call(this, event), event.result
                }
            },
            handlers: function(event, handlers) {
                var sel, handleObj, matches, i, handlerQueue = [],
                    delegateCount = handlers.delegateCount,
                    cur = event.target;
                if (delegateCount && cur.nodeType && (!event.button || "click" !== event.type))
                    for (; cur != this; cur = cur.parentNode || this)
                        if (1 === cur.nodeType && (!0 !== cur.disabled || "click" !== event.type)) {
                            for (matches = [], i = 0; i < delegateCount; i++) void 0 === matches[sel = (handleObj = handlers[i]).selector + " "] && (matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length), matches[sel] && matches.push(handleObj);
                            matches.length && handlerQueue.push({
                                elem: cur,
                                handlers: matches
                            })
                        } return delegateCount < handlers.length && handlerQueue.push({
                    elem: this,
                    handlers: handlers.slice(delegateCount)
                }), handlerQueue
            },
            fix: function(event) {
                if (event[jQuery.expando]) return event;
                var i, prop, copy, type = event.type,
                    originalEvent = event,
                    fixHook = this.fixHooks[type];
                for (fixHook || (this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {}), copy = fixHook.props ? this.props.concat(fixHook.props) : this.props, event = new jQuery.Event(originalEvent), i = copy.length; i--;) event[prop = copy[i]] = originalEvent[prop];
                return event.target || (event.target = originalEvent.srcElement || document), 3 === event.target.nodeType && (event.target = event.target.parentNode), event.metaKey = !!event.metaKey, fixHook.filter ? fixHook.filter(event, originalEvent) : event
            },
            props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
            fixHooks: {},
            keyHooks: {
                props: "char charCode key keyCode".split(" "),
                filter: function(event, original) {
                    return null == event.which && (event.which = null != original.charCode ? original.charCode : original.keyCode), event
                }
            },
            mouseHooks: {
                props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
                filter: function(event, original) {
                    var body, eventDoc, doc, button = original.button,
                        fromElement = original.fromElement;
                    return null == event.pageX && null != original.clientX && (doc = (eventDoc = event.target.ownerDocument || document).documentElement, body = eventDoc.body, event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0), event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0)), !event.relatedTarget && fromElement && (event.relatedTarget = fromElement === event.target ? original.toElement : fromElement), event.which || void 0 === button || (event.which = 1 & button ? 1 : 2 & button ? 3 : 4 & button ? 2 : 0), event
                }
            },
            special: {
                load: {
                    noBubble: !0
                },
                focus: {
                    trigger: function() {
                        if (this !== safeActiveElement() && this.focus) try {
                            return this.focus(), !1
                        } catch (e) {}
                    },
                    delegateType: "focusin"
                },
                blur: {
                    trigger: function() {
                        if (this === safeActiveElement() && this.blur) return this.blur(), !1
                    },
                    delegateType: "focusout"
                },
                click: {
                    trigger: function() {
                        if (jQuery.nodeName(this, "input") && "checkbox" === this.type && this.click) return this.click(), !1
                    },
                    _default: function(event) {
                        return jQuery.nodeName(event.target, "a")
                    }
                },
                beforeunload: {
                    postDispatch: function(event) {
                        void 0 !== event.result && event.originalEvent && (event.originalEvent.returnValue = event.result)
                    }
                }
            },
            simulate: function(type, elem, event, bubble) {
                var e = jQuery.extend(new jQuery.Event, event, {
                    type: type,
                    isSimulated: !0,
                    originalEvent: {}
                });
                bubble ? jQuery.event.trigger(e, null, elem) : jQuery.event.dispatch.call(elem, e), e.isDefaultPrevented() && event.preventDefault()
            }
        }, jQuery.removeEvent = document.removeEventListener ? function(elem, type, handle) {
            elem.removeEventListener && elem.removeEventListener(type, handle, !1)
        } : function(elem, type, handle) {
            var name = "on" + type;
            elem.detachEvent && (typeof elem[name] === strundefined && (elem[name] = null), elem.detachEvent(name, handle))
        }, jQuery.Event = function(src, props) {
            if (!(this instanceof jQuery.Event)) return new jQuery.Event(src, props);
            src && src.type ? (this.originalEvent = src, this.type = src.type, this.isDefaultPrevented = src.defaultPrevented || void 0 === src.defaultPrevented && !1 === src.returnValue ? returnTrue : returnFalse) : this.type = src, props && jQuery.extend(this, props), this.timeStamp = src && src.timeStamp || jQuery.now(), this[jQuery.expando] = !0
        }, jQuery.Event.prototype = {
            isDefaultPrevented: returnFalse,
            isPropagationStopped: returnFalse,
            isImmediatePropagationStopped: returnFalse,
            preventDefault: function() {
                var e = this.originalEvent;
                this.isDefaultPrevented = returnTrue, e && (e.preventDefault ? e.preventDefault() : e.returnValue = !1)
            },
            stopPropagation: function() {
                var e = this.originalEvent;
                this.isPropagationStopped = returnTrue, e && (e.stopPropagation && e.stopPropagation(), e.cancelBubble = !0)
            },
            stopImmediatePropagation: function() {
                var e = this.originalEvent;
                this.isImmediatePropagationStopped = returnTrue, e && e.stopImmediatePropagation && e.stopImmediatePropagation(), this.stopPropagation()
            }
        }, jQuery.each({
            mouseenter: "mouseover",
            mouseleave: "mouseout",
            pointerenter: "pointerover",
            pointerleave: "pointerout"
        }, function(orig, fix) {
            jQuery.event.special[orig] = {
                delegateType: fix,
                bindType: fix,
                handle: function(event) {
                    var ret, related = event.relatedTarget,
                        handleObj = event.handleObj;
                    return related && (related === this || jQuery.contains(this, related)) || (event.type = handleObj.origType, ret = handleObj.handler.apply(this, arguments), event.type = fix), ret
                }
            }
        }), support.submitBubbles || (jQuery.event.special.submit = {
            setup: function() {
                if (jQuery.nodeName(this, "form")) return !1;
                jQuery.event.add(this, "click._submit keypress._submit", function(e) {
                    var elem = e.target,
                        form = jQuery.nodeName(elem, "input") || jQuery.nodeName(elem, "button") ? elem.form : void 0;
                    form && !jQuery._data(form, "submitBubbles") && (jQuery.event.add(form, "submit._submit", function(event) {
                        event._submit_bubble = !0
                    }), jQuery._data(form, "submitBubbles", !0))
                })
            },
            postDispatch: function(event) {
                event._submit_bubble && (delete event._submit_bubble, this.parentNode && !event.isTrigger && jQuery.event.simulate("submit", this.parentNode, event, !0))
            },
            teardown: function() {
                if (jQuery.nodeName(this, "form")) return !1;
                jQuery.event.remove(this, "._submit")
            }
        }), support.changeBubbles || (jQuery.event.special.change = {
            setup: function() {
                if (rformElems.test(this.nodeName)) return "checkbox" !== this.type && "radio" !== this.type || (jQuery.event.add(this, "propertychange._change", function(event) {
                    "checked" === event.originalEvent.propertyName && (this._just_changed = !0)
                }), jQuery.event.add(this, "click._change", function(event) {
                    this._just_changed && !event.isTrigger && (this._just_changed = !1), jQuery.event.simulate("change", this, event, !0)
                })), !1;
                jQuery.event.add(this, "beforeactivate._change", function(e) {
                    var elem = e.target;
                    rformElems.test(elem.nodeName) && !jQuery._data(elem, "changeBubbles") && (jQuery.event.add(elem, "change._change", function(event) {
                        !this.parentNode || event.isSimulated || event.isTrigger || jQuery.event.simulate("change", this.parentNode, event, !0)
                    }), jQuery._data(elem, "changeBubbles", !0))
                })
            },
            handle: function(event) {
                var elem = event.target;
                if (this !== elem || event.isSimulated || event.isTrigger || "radio" !== elem.type && "checkbox" !== elem.type) return event.handleObj.handler.apply(this, arguments)
            },
            teardown: function() {
                return jQuery.event.remove(this, "._change"), !rformElems.test(this.nodeName)
            }
        }), support.focusinBubbles || jQuery.each({
            focus: "focusin",
            blur: "focusout"
        }, function(orig, fix) {
            var handler = function(event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), !0)
            };
            jQuery.event.special[fix] = {
                setup: function() {
                    var doc = this.ownerDocument || this,
                        attaches = jQuery._data(doc, fix);
                    attaches || doc.addEventListener(orig, handler, !0), jQuery._data(doc, fix, (attaches || 0) + 1)
                },
                teardown: function() {
                    var doc = this.ownerDocument || this,
                        attaches = jQuery._data(doc, fix) - 1;
                    attaches ? jQuery._data(doc, fix, attaches) : (doc.removeEventListener(orig, handler, !0), jQuery._removeData(doc, fix))
                }
            }
        }), jQuery.fn.extend({
            on: function(types, selector, data, fn, one) {
                var type, origFn;
                if ("object" == typeof types) {
                    for (type in "string" != typeof selector && (data = data || selector, selector = void 0), types) this.on(type, selector, data, types[type], one);
                    return this
                }
                if (null == data && null == fn ? (fn = selector, data = selector = void 0) : null == fn && ("string" == typeof selector ? (fn = data, data = void 0) : (fn = data, data = selector, selector = void 0)), !1 === fn) fn = returnFalse;
                else if (!fn) return this;
                return 1 === one && (origFn = fn, (fn = function(event) {
                    return jQuery().off(event), origFn.apply(this, arguments)
                }).guid = origFn.guid || (origFn.guid = jQuery.guid++)), this.each(function() {
                    jQuery.event.add(this, types, fn, data, selector)
                })
            },
            one: function(types, selector, data, fn) {
                return this.on(types, selector, data, fn, 1)
            },
            off: function(types, selector, fn) {
                var handleObj, type;
                if (types && types.preventDefault && types.handleObj) return handleObj = types.handleObj, jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler), this;
                if ("object" == typeof types) {
                    for (type in types) this.off(type, selector, types[type]);
                    return this
                }
                return !1 !== selector && "function" != typeof selector || (fn = selector, selector = void 0), !1 === fn && (fn = returnFalse), this.each(function() {
                    jQuery.event.remove(this, types, fn, selector)
                })
            },
            trigger: function(type, data) {
                return this.each(function() {
                    jQuery.event.trigger(type, data, this)
                })
            },
            triggerHandler: function(type, data) {
                var elem = this[0];
                if (elem) return jQuery.event.trigger(type, data, elem, !0)
            }
        });
        var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
            rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
            rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
            rleadingWhitespace = /^\s+/,
            rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
            rtagName = /<([\w:]+)/,
            rtbody = /<tbody/i,
            rhtml = /<|&#?\w+;/,
            rnoInnerhtml = /<(?:script|style|link)/i,
            rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
            rscriptType = /^$|\/(?:java|ecma)script/i,
            rscriptTypeMasked = /^true\/(.*)/,
            rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
            wrapMap = {
                option: [1, "<select multiple='multiple'>", "</select>"],
                legend: [1, "<fieldset>", "</fieldset>"],
                area: [1, "<map>", "</map>"],
                param: [1, "<object>", "</object>"],
                thead: [1, "<table>", "</table>"],
                tr: [2, "<table><tbody>", "</tbody></table>"],
                col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
                td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
                _default: support.htmlSerialize ? [0, "", ""] : [1, "X<div>", "</div>"]
            },
            fragmentDiv = createSafeFragment(document).appendChild(document.createElement("div"));

        function getAll(context, tag) {
            var elems, elem, i = 0,
                found = typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName(tag || "*") : typeof context.querySelectorAll !== strundefined ? context.querySelectorAll(tag || "*") : void 0;
            if (!found)
                for (found = [], elems = context.childNodes || context; null != (elem = elems[i]); i++) !tag || jQuery.nodeName(elem, tag) ? found.push(elem) : jQuery.merge(found, getAll(elem, tag));
            return void 0 === tag || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], found) : found
        }

        function fixDefaultChecked(elem) {
            rcheckableType.test(elem.type) && (elem.defaultChecked = elem.checked)
        }

        function manipulationTarget(elem, content) {
            return jQuery.nodeName(elem, "table") && jQuery.nodeName(11 !== content.nodeType ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem
        }

        function disableScript(elem) {
            return elem.type = (null !== jQuery.find.attr(elem, "type")) + "/" + elem.type, elem
        }

        function restoreScript(elem) {
            var match = rscriptTypeMasked.exec(elem.type);
            return match ? elem.type = match[1] : elem.removeAttribute("type"), elem
        }

        function setGlobalEval(elems, refElements) {
            for (var elem, i = 0; null != (elem = elems[i]); i++) jQuery._data(elem, "globalEval", !refElements || jQuery._data(refElements[i], "globalEval"))
        }

        function cloneCopyEvent(src, dest) {
            if (1 === dest.nodeType && jQuery.hasData(src)) {
                var type, i, l, oldData = jQuery._data(src),
                    curData = jQuery._data(dest, oldData),
                    events = oldData.events;
                if (events)
                    for (type in delete curData.handle, curData.events = {}, events)
                        for (i = 0, l = events[type].length; i < l; i++) jQuery.event.add(dest, type, events[type][i]);
                curData.data && (curData.data = jQuery.extend({}, curData.data))
            }
        }

        function fixCloneNodeIssues(src, dest) {
            var nodeName, e, data;
            if (1 === dest.nodeType) {
                if (nodeName = dest.nodeName.toLowerCase(), !support.noCloneEvent && dest[jQuery.expando]) {
                    for (e in (data = jQuery._data(dest)).events) jQuery.removeEvent(dest, e, data.handle);
                    dest.removeAttribute(jQuery.expando)
                }
                "script" === nodeName && dest.text !== src.text ? (disableScript(dest).text = src.text, restoreScript(dest)) : "object" === nodeName ? (dest.parentNode && (dest.outerHTML = src.outerHTML), support.html5Clone && src.innerHTML && !jQuery.trim(dest.innerHTML) && (dest.innerHTML = src.innerHTML)) : "input" === nodeName && rcheckableType.test(src.type) ? (dest.defaultChecked = dest.checked = src.checked, dest.value !== src.value && (dest.value = src.value)) : "option" === nodeName ? dest.defaultSelected = dest.selected = src.defaultSelected : "input" !== nodeName && "textarea" !== nodeName || (dest.defaultValue = src.defaultValue)
            }
        }
        wrapMap.optgroup = wrapMap.option, wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead, wrapMap.th = wrapMap.td, jQuery.extend({
            clone: function(elem, dataAndEvents, deepDataAndEvents) {
                var destElements, node, clone, i, srcElements, inPage = jQuery.contains(elem.ownerDocument, elem);
                if (support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test("<" + elem.nodeName + ">") ? clone = elem.cloneNode(!0) : (fragmentDiv.innerHTML = elem.outerHTML, fragmentDiv.removeChild(clone = fragmentDiv.firstChild)), !(support.noCloneEvent && support.noCloneChecked || 1 !== elem.nodeType && 11 !== elem.nodeType || jQuery.isXMLDoc(elem)))
                    for (destElements = getAll(clone), srcElements = getAll(elem), i = 0; null != (node = srcElements[i]); ++i) destElements[i] && fixCloneNodeIssues(node, destElements[i]);
                if (dataAndEvents)
                    if (deepDataAndEvents)
                        for (srcElements = srcElements || getAll(elem), destElements = destElements || getAll(clone), i = 0; null != (node = srcElements[i]); i++) cloneCopyEvent(node, destElements[i]);
                    else cloneCopyEvent(elem, clone);
                return (destElements = getAll(clone, "script")).length > 0 && setGlobalEval(destElements, !inPage && getAll(elem, "script")), destElements = srcElements = node = null, clone
            },
            buildFragment: function(elems, context, scripts, selection) {
                for (var j, elem, contains, tmp, tag, tbody, wrap, l = elems.length, safe = createSafeFragment(context), nodes = [], i = 0; i < l; i++)
                    if ((elem = elems[i]) || 0 === elem)
                        if ("object" === jQuery.type(elem)) jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
                        else if (rhtml.test(elem)) {
                    for (tmp = tmp || safe.appendChild(context.createElement("div")), tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase(), wrap = wrapMap[tag] || wrapMap._default, tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2], j = wrap[0]; j--;) tmp = tmp.lastChild;
                    if (!support.leadingWhitespace && rleadingWhitespace.test(elem) && nodes.push(context.createTextNode(rleadingWhitespace.exec(elem)[0])), !support.tbody)
                        for (j = (elem = "table" !== tag || rtbody.test(elem) ? "<table>" !== wrap[1] || rtbody.test(elem) ? 0 : tmp : tmp.firstChild) && elem.childNodes.length; j--;) jQuery.nodeName(tbody = elem.childNodes[j], "tbody") && !tbody.childNodes.length && elem.removeChild(tbody);
                    for (jQuery.merge(nodes, tmp.childNodes), tmp.textContent = ""; tmp.firstChild;) tmp.removeChild(tmp.firstChild);
                    tmp = safe.lastChild
                } else nodes.push(context.createTextNode(elem));
                for (tmp && safe.removeChild(tmp), support.appendChecked || jQuery.grep(getAll(nodes, "input"), fixDefaultChecked), i = 0; elem = nodes[i++];)
                    if ((!selection || -1 === jQuery.inArray(elem, selection)) && (contains = jQuery.contains(elem.ownerDocument, elem), tmp = getAll(safe.appendChild(elem), "script"), contains && setGlobalEval(tmp), scripts))
                        for (j = 0; elem = tmp[j++];) rscriptType.test(elem.type || "") && scripts.push(elem);
                return tmp = null, safe
            },
            cleanData: function(elems, acceptData) {
                for (var elem, type, id, data, i = 0, internalKey = jQuery.expando, cache = jQuery.cache, deleteExpando = support.deleteExpando, special = jQuery.event.special; null != (elem = elems[i]); i++)
                    if ((acceptData || jQuery.acceptData(elem)) && (data = (id = elem[internalKey]) && cache[id])) {
                        if (data.events)
                            for (type in data.events) special[type] ? jQuery.event.remove(elem, type) : jQuery.removeEvent(elem, type, data.handle);
                        cache[id] && (delete cache[id], deleteExpando ? delete elem[internalKey] : typeof elem.removeAttribute !== strundefined ? elem.removeAttribute(internalKey) : elem[internalKey] = null, deletedIds.push(id))
                    }
            }
        }), jQuery.fn.extend({
            text: function(value) {
                return access(this, function(value) {
                    return void 0 === value ? jQuery.text(this) : this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(value))
                }, null, value, arguments.length)
            },
            append: function() {
                return this.domManip(arguments, function(elem) {
                    1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || manipulationTarget(this, elem).appendChild(elem)
                })
            },
            prepend: function() {
                return this.domManip(arguments, function(elem) {
                    if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                        var target = manipulationTarget(this, elem);
                        target.insertBefore(elem, target.firstChild)
                    }
                })
            },
            before: function() {
                return this.domManip(arguments, function(elem) {
                    this.parentNode && this.parentNode.insertBefore(elem, this)
                })
            },
            after: function() {
                return this.domManip(arguments, function(elem) {
                    this.parentNode && this.parentNode.insertBefore(elem, this.nextSibling)
                })
            },
            remove: function(selector, keepData) {
                for (var elem, elems = selector ? jQuery.filter(selector, this) : this, i = 0; null != (elem = elems[i]); i++) keepData || 1 !== elem.nodeType || jQuery.cleanData(getAll(elem)), elem.parentNode && (keepData && jQuery.contains(elem.ownerDocument, elem) && setGlobalEval(getAll(elem, "script")), elem.parentNode.removeChild(elem));
                return this
            },
            empty: function() {
                for (var elem, i = 0; null != (elem = this[i]); i++) {
                    for (1 === elem.nodeType && jQuery.cleanData(getAll(elem, !1)); elem.firstChild;) elem.removeChild(elem.firstChild);
                    elem.options && jQuery.nodeName(elem, "select") && (elem.options.length = 0)
                }
                return this
            },
            clone: function(dataAndEvents, deepDataAndEvents) {
                return dataAndEvents = null != dataAndEvents && dataAndEvents, deepDataAndEvents = null == deepDataAndEvents ? dataAndEvents : deepDataAndEvents, this.map(function() {
                    return jQuery.clone(this, dataAndEvents, deepDataAndEvents)
                })
            },
            html: function(value) {
                return access(this, function(value) {
                    var elem = this[0] || {},
                        i = 0,
                        l = this.length;
                    if (void 0 === value) return 1 === elem.nodeType ? elem.innerHTML.replace(rinlinejQuery, "") : void 0;
                    if ("string" == typeof value && !rnoInnerhtml.test(value) && (support.htmlSerialize || !rnoshimcache.test(value)) && (support.leadingWhitespace || !rleadingWhitespace.test(value)) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
                        value = value.replace(rxhtmlTag, "<$1></$2>");
                        try {
                            for (; i < l; i++) 1 === (elem = this[i] || {}).nodeType && (jQuery.cleanData(getAll(elem, !1)), elem.innerHTML = value);
                            elem = 0
                        } catch (e) {}
                    }
                    elem && this.empty().append(value)
                }, null, value, arguments.length)
            },
            replaceWith: function() {
                var arg = arguments[0];
                return this.domManip(arguments, function(elem) {
                    arg = this.parentNode, jQuery.cleanData(getAll(this)), arg && arg.replaceChild(elem, this)
                }), arg && (arg.length || arg.nodeType) ? this : this.remove()
            },
            detach: function(selector) {
                return this.remove(selector, !0)
            },
            domManip: function(args, callback) {
                args = concat.apply([], args);
                var first, node, hasScripts, scripts, doc, fragment, i = 0,
                    l = this.length,
                    set = this,
                    iNoClone = l - 1,
                    value = args[0],
                    isFunction = jQuery.isFunction(value);
                if (isFunction || l > 1 && "string" == typeof value && !support.checkClone && rchecked.test(value)) return this.each(function(index) {
                    var self = set.eq(index);
                    isFunction && (args[0] = value.call(this, index, self.html())), self.domManip(args, callback)
                });
                if (l && (first = (fragment = jQuery.buildFragment(args, this[0].ownerDocument, !1, this)).firstChild, 1 === fragment.childNodes.length && (fragment = first), first)) {
                    for (hasScripts = (scripts = jQuery.map(getAll(fragment, "script"), disableScript)).length; i < l; i++) node = fragment, i !== iNoClone && (node = jQuery.clone(node, !0, !0), hasScripts && jQuery.merge(scripts, getAll(node, "script"))), callback.call(this[i], node, i);
                    if (hasScripts)
                        for (doc = scripts[scripts.length - 1].ownerDocument, jQuery.map(scripts, restoreScript), i = 0; i < hasScripts; i++) node = scripts[i], rscriptType.test(node.type || "") && !jQuery._data(node, "globalEval") && jQuery.contains(doc, node) && (node.src ? jQuery._evalUrl && jQuery._evalUrl(node.src) : jQuery.globalEval((node.text || node.textContent || node.innerHTML || "").replace(rcleanScript, "")));
                    fragment = first = null
                }
                return this
            }
        }), jQuery.each({
            appendTo: "append",
            prependTo: "prepend",
            insertBefore: "before",
            insertAfter: "after",
            replaceAll: "replaceWith"
        }, function(name, original) {
            jQuery.fn[name] = function(selector) {
                for (var elems, i = 0, ret = [], insert = jQuery(selector), last = insert.length - 1; i <= last; i++) elems = i === last ? this : this.clone(!0), jQuery(insert[i])[original](elems), push.apply(ret, elems.get());
                return this.pushStack(ret)
            }
        });
        var iframe, shrinkWrapBlocksVal, elemdisplay = {};

        function actualDisplay(name, doc) {
            var style, elem = jQuery(doc.createElement(name)).appendTo(doc.body),
                display = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0])) ? style.display : jQuery.css(elem[0], "display");
            return elem.detach(), display
        }

        function defaultDisplay(nodeName) {
            var doc = document,
                display = elemdisplay[nodeName];
            return display || ("none" !== (display = actualDisplay(nodeName, doc)) && display || ((doc = ((iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement))[0].contentWindow || iframe[0].contentDocument).document).write(), doc.close(), display = actualDisplay(nodeName, doc), iframe.detach()), elemdisplay[nodeName] = display), display
        }
        support.shrinkWrapBlocks = function() {
            return null != shrinkWrapBlocksVal ? shrinkWrapBlocksVal : (shrinkWrapBlocksVal = !1, (body = document.getElementsByTagName("body")[0]) && body.style ? (div = document.createElement("div"), (container = document.createElement("div")).style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", body.appendChild(container).appendChild(div), typeof div.style.zoom !== strundefined && (div.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:1px;width:1px;zoom:1", div.appendChild(document.createElement("div")).style.width = "5px", shrinkWrapBlocksVal = 3 !== div.offsetWidth), body.removeChild(container), shrinkWrapBlocksVal) : void 0);
            var div, body, container
        };
        var getStyles, curCSS, rmargin = /^margin/,
            rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i"),
            rposition = /^(top|right|bottom|left)$/;

        function addGetHookIf(conditionFn, hookFn) {
            return {
                get: function() {
                    var condition = conditionFn();
                    if (null != condition) {
                        if (!condition) return (this.get = hookFn).apply(this, arguments);
                        delete this.get
                    }
                }
            }
        }
        window.getComputedStyle ? (getStyles = function(elem) {
                return elem.ownerDocument.defaultView.opener ? elem.ownerDocument.defaultView.getComputedStyle(elem, null) : window.getComputedStyle(elem, null)
            }, curCSS = function(elem, name, computed) {
                var width, minWidth, maxWidth, ret, style = elem.style;
                return ret = (computed = computed || getStyles(elem)) ? computed.getPropertyValue(name) || computed[name] : void 0, computed && ("" !== ret || jQuery.contains(elem.ownerDocument, elem) || (ret = jQuery.style(elem, name)), rnumnonpx.test(ret) && rmargin.test(name) && (width = style.width, minWidth = style.minWidth, maxWidth = style.maxWidth, style.minWidth = style.maxWidth = style.width = ret, ret = computed.width, style.width = width, style.minWidth = minWidth, style.maxWidth = maxWidth)), void 0 === ret ? ret : ret + ""
            }) : document.documentElement.currentStyle && (getStyles = function(elem) {
                return elem.currentStyle
            }, curCSS = function(elem, name, computed) {
                var left, rs, rsLeft, ret, style = elem.style;
                return null == (ret = (computed = computed || getStyles(elem)) ? computed[name] : void 0) && style && style[name] && (ret = style[name]), rnumnonpx.test(ret) && !rposition.test(name) && (left = style.left, (rsLeft = (rs = elem.runtimeStyle) && rs.left) && (rs.left = elem.currentStyle.left), style.left = "fontSize" === name ? "1em" : ret, ret = style.pixelLeft + "px", style.left = left, rsLeft && (rs.left = rsLeft)), void 0 === ret ? ret : ret + "" || "auto"
            }),
            function() {
                var div, style, a, pixelPositionVal, boxSizingReliableVal, reliableHiddenOffsetsVal, reliableMarginRightVal;

                function computeStyleTests() {
                    var div, body, container, contents;
                    (body = document.getElementsByTagName("body")[0]) && body.style && (div = document.createElement("div"), (container = document.createElement("div")).style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", body.appendChild(container).appendChild(div), div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute", pixelPositionVal = boxSizingReliableVal = !1, reliableMarginRightVal = !0, window.getComputedStyle && (pixelPositionVal = "1%" !== (window.getComputedStyle(div, null) || {}).top, boxSizingReliableVal = "4px" === (window.getComputedStyle(div, null) || {
                        width: "4px"
                    }).width, (contents = div.appendChild(document.createElement("div"))).style.cssText = div.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0", contents.style.marginRight = contents.style.width = "0", div.style.width = "1px", reliableMarginRightVal = !parseFloat((window.getComputedStyle(contents, null) || {}).marginRight), div.removeChild(contents)), div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>", (contents = div.getElementsByTagName("td"))[0].style.cssText = "margin:0;border:0;padding:0;display:none", (reliableHiddenOffsetsVal = 0 === contents[0].offsetHeight) && (contents[0].style.display = "", contents[1].style.display = "none", reliableHiddenOffsetsVal = 0 === contents[0].offsetHeight), body.removeChild(container))
                }(div = document.createElement("div")).innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", (style = (a = div.getElementsByTagName("a")[0]) && a.style) && (style.cssText = "float:left;opacity:.5", support.opacity = "0.5" === style.opacity, support.cssFloat = !!style.cssFloat, div.style.backgroundClip = "content-box", div.cloneNode(!0).style.backgroundClip = "", support.clearCloneStyle = "content-box" === div.style.backgroundClip, support.boxSizing = "" === style.boxSizing || "" === style.MozBoxSizing || "" === style.WebkitBoxSizing, jQuery.extend(support, {
                    reliableHiddenOffsets: function() {
                        return null == reliableHiddenOffsetsVal && computeStyleTests(), reliableHiddenOffsetsVal
                    },
                    boxSizingReliable: function() {
                        return null == boxSizingReliableVal && computeStyleTests(), boxSizingReliableVal
                    },
                    pixelPosition: function() {
                        return null == pixelPositionVal && computeStyleTests(), pixelPositionVal
                    },
                    reliableMarginRight: function() {
                        return null == reliableMarginRightVal && computeStyleTests(), reliableMarginRightVal
                    }
                }))
            }(), jQuery.swap = function(elem, options, callback, args) {
                var ret, name, old = {};
                for (name in options) old[name] = elem.style[name], elem.style[name] = options[name];
                for (name in ret = callback.apply(elem, args || []), options) elem.style[name] = old[name];
                return ret
            };
        var ralpha = /alpha\([^)]*\)/i,
            ropacity = /opacity\s*=\s*([^)]*)/,
            rdisplayswap = /^(none|table(?!-c[ea]).+)/,
            rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"),
            rrelNum = new RegExp("^([+-])=(" + pnum + ")", "i"),
            cssShow = {
                position: "absolute",
                visibility: "hidden",
                display: "block"
            },
            cssNormalTransform = {
                letterSpacing: "0",
                fontWeight: "400"
            },
            cssPrefixes = ["Webkit", "O", "Moz", "ms"];

        function vendorPropName(style, name) {
            if (name in style) return name;
            for (var capName = name.charAt(0).toUpperCase() + name.slice(1), origName = name, i = cssPrefixes.length; i--;)
                if ((name = cssPrefixes[i] + capName) in style) return name;
            return origName
        }

        function showHide(elements, show) {
            for (var display, elem, hidden, values = [], index = 0, length = elements.length; index < length; index++)(elem = elements[index]).style && (values[index] = jQuery._data(elem, "olddisplay"), display = elem.style.display, show ? (values[index] || "none" !== display || (elem.style.display = ""), "" === elem.style.display && isHidden(elem) && (values[index] = jQuery._data(elem, "olddisplay", defaultDisplay(elem.nodeName)))) : (hidden = isHidden(elem), (display && "none" !== display || !hidden) && jQuery._data(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"))));
            for (index = 0; index < length; index++)(elem = elements[index]).style && (show && "none" !== elem.style.display && "" !== elem.style.display || (elem.style.display = show ? values[index] || "" : "none"));
            return elements
        }

        function setPositiveNumber(elem, value, subtract) {
            var matches = rnumsplit.exec(value);
            return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") : value
        }

        function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
            for (var i = extra === (isBorderBox ? "border" : "content") ? 4 : "width" === name ? 1 : 0, val = 0; i < 4; i += 2) "margin" === extra && (val += jQuery.css(elem, extra + cssExpand[i], !0, styles)), isBorderBox ? ("content" === extra && (val -= jQuery.css(elem, "padding" + cssExpand[i], !0, styles)), "margin" !== extra && (val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles))) : (val += jQuery.css(elem, "padding" + cssExpand[i], !0, styles), "padding" !== extra && (val += jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles)));
            return val
        }

        function getWidthOrHeight(elem, name, extra) {
            var valueIsBorderBox = !0,
                val = "width" === name ? elem.offsetWidth : elem.offsetHeight,
                styles = getStyles(elem),
                isBorderBox = support.boxSizing && "border-box" === jQuery.css(elem, "boxSizing", !1, styles);
            if (val <= 0 || null == val) {
                if (((val = curCSS(elem, name, styles)) < 0 || null == val) && (val = elem.style[name]), rnumnonpx.test(val)) return val;
                valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]), val = parseFloat(val) || 0
            }
            return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px"
        }

        function Tween(elem, options, prop, end, easing) {
            return new Tween.prototype.init(elem, options, prop, end, easing)
        }
        jQuery.extend({
            cssHooks: {
                opacity: {
                    get: function(elem, computed) {
                        if (computed) {
                            var ret = curCSS(elem, "opacity");
                            return "" === ret ? "1" : ret
                        }
                    }
                }
            },
            cssNumber: {
                columnCount: !0,
                fillOpacity: !0,
                flexGrow: !0,
                flexShrink: !0,
                fontWeight: !0,
                lineHeight: !0,
                opacity: !0,
                order: !0,
                orphans: !0,
                widows: !0,
                zIndex: !0,
                zoom: !0
            },
            cssProps: {
                float: support.cssFloat ? "cssFloat" : "styleFloat"
            },
            style: function(elem, name, value, extra) {
                if (elem && 3 !== elem.nodeType && 8 !== elem.nodeType && elem.style) {
                    var ret, type, hooks, origName = jQuery.camelCase(name),
                        style = elem.style;
                    if (name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName)), hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName], void 0 === value) return hooks && "get" in hooks && void 0 !== (ret = hooks.get(elem, !1, extra)) ? ret : style[name];
                    if ("string" === (type = typeof value) && (ret = rrelNum.exec(value)) && (value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name)), type = "number"), null != value && value == value && ("number" !== type || jQuery.cssNumber[origName] || (value += "px"), support.clearCloneStyle || "" !== value || 0 !== name.indexOf("background") || (style[name] = "inherit"), !(hooks && "set" in hooks && void 0 === (value = hooks.set(elem, value, extra))))) try {
                        style[name] = value
                    } catch (e) {}
                }
            },
            css: function(elem, name, extra, styles) {
                var num, val, hooks, origName = jQuery.camelCase(name);
                return name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName)), (hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]) && "get" in hooks && (val = hooks.get(elem, !0, extra)), void 0 === val && (val = curCSS(elem, name, styles)), "normal" === val && name in cssNormalTransform && (val = cssNormalTransform[name]), "" === extra || extra ? (num = parseFloat(val), !0 === extra || jQuery.isNumeric(num) ? num || 0 : val) : val
            }
        }), jQuery.each(["height", "width"], function(i, name) {
            jQuery.cssHooks[name] = {
                get: function(elem, computed, extra) {
                    if (computed) return rdisplayswap.test(jQuery.css(elem, "display")) && 0 === elem.offsetWidth ? jQuery.swap(elem, cssShow, function() {
                        return getWidthOrHeight(elem, name, extra)
                    }) : getWidthOrHeight(elem, name, extra)
                },
                set: function(elem, value, extra) {
                    var styles = extra && getStyles(elem);
                    return setPositiveNumber(0, value, extra ? augmentWidthOrHeight(elem, name, extra, support.boxSizing && "border-box" === jQuery.css(elem, "boxSizing", !1, styles), styles) : 0)
                }
            }
        }), support.opacity || (jQuery.cssHooks.opacity = {
            get: function(elem, computed) {
                return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "") ? .01 * parseFloat(RegExp.$1) + "" : computed ? "1" : ""
            },
            set: function(elem, value) {
                var style = elem.style,
                    currentStyle = elem.currentStyle,
                    opacity = jQuery.isNumeric(value) ? "alpha(opacity=" + 100 * value + ")" : "",
                    filter = currentStyle && currentStyle.filter || style.filter || "";
                style.zoom = 1, (value >= 1 || "" === value) && "" === jQuery.trim(filter.replace(ralpha, "")) && style.removeAttribute && (style.removeAttribute("filter"), "" === value || currentStyle && !currentStyle.filter) || (style.filter = ralpha.test(filter) ? filter.replace(ralpha, opacity) : filter + " " + opacity)
            }
        }), jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function(elem, computed) {
            if (computed) return jQuery.swap(elem, {
                display: "inline-block"
            }, curCSS, [elem, "marginRight"])
        }), jQuery.each({
            margin: "",
            padding: "",
            border: "Width"
        }, function(prefix, suffix) {
            jQuery.cssHooks[prefix + suffix] = {
                expand: function(value) {
                    for (var i = 0, expanded = {}, parts = "string" == typeof value ? value.split(" ") : [value]; i < 4; i++) expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                    return expanded
                }
            }, rmargin.test(prefix) || (jQuery.cssHooks[prefix + suffix].set = setPositiveNumber)
        }), jQuery.fn.extend({
            css: function(name, value) {
                return access(this, function(elem, name, value) {
                    var styles, len, map = {},
                        i = 0;
                    if (jQuery.isArray(name)) {
                        for (styles = getStyles(elem), len = name.length; i < len; i++) map[name[i]] = jQuery.css(elem, name[i], !1, styles);
                        return map
                    }
                    return void 0 !== value ? jQuery.style(elem, name, value) : jQuery.css(elem, name)
                }, name, value, arguments.length > 1)
            },
            show: function() {
                return showHide(this, !0)
            },
            hide: function() {
                return showHide(this)
            },
            toggle: function(state) {
                return "boolean" == typeof state ? state ? this.show() : this.hide() : this.each(function() {
                    isHidden(this) ? jQuery(this).show() : jQuery(this).hide()
                })
            }
        }), jQuery.Tween = Tween, Tween.prototype = {
            constructor: Tween,
            init: function(elem, options, prop, end, easing, unit) {
                this.elem = elem, this.prop = prop, this.easing = easing || "swing", this.options = options, this.start = this.now = this.cur(), this.end = end, this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px")
            },
            cur: function() {
                var hooks = Tween.propHooks[this.prop];
                return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this)
            },
            run: function(percent) {
                var eased, hooks = Tween.propHooks[this.prop];
                return this.options.duration ? this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration) : this.pos = eased = percent, this.now = (this.end - this.start) * eased + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), hooks && hooks.set ? hooks.set(this) : Tween.propHooks._default.set(this), this
            }
        }, Tween.prototype.init.prototype = Tween.prototype, Tween.propHooks = {
            _default: {
                get: function(tween) {
                    var result;
                    return null == tween.elem[tween.prop] || tween.elem.style && null != tween.elem.style[tween.prop] ? (result = jQuery.css(tween.elem, tween.prop, "")) && "auto" !== result ? result : 0 : tween.elem[tween.prop]
                },
                set: function(tween) {
                    jQuery.fx.step[tween.prop] ? jQuery.fx.step[tween.prop](tween) : tween.elem.style && (null != tween.elem.style[jQuery.cssProps[tween.prop]] || jQuery.cssHooks[tween.prop]) ? jQuery.style(tween.elem, tween.prop, tween.now + tween.unit) : tween.elem[tween.prop] = tween.now
                }
            }
        }, Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
            set: function(tween) {
                tween.elem.nodeType && tween.elem.parentNode && (tween.elem[tween.prop] = tween.now)
            }
        }, jQuery.easing = {
            linear: function(p) {
                return p
            },
            swing: function(p) {
                return .5 - Math.cos(p * Math.PI) / 2
            }
        }, jQuery.fx = Tween.prototype.init, jQuery.fx.step = {};
        var fxNow, timerId, input, div, select, a, opt, rfxtypes = /^(?:toggle|show|hide)$/,
            rfxnum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"),
            rrun = /queueHooks$/,
            animationPrefilters = [function(elem, props, opts) {
                var prop, value, toggle, tween, hooks, oldfire, display, anim = this,
                    orig = {},
                    style = elem.style,
                    hidden = elem.nodeType && isHidden(elem),
                    dataShow = jQuery._data(elem, "fxshow");
                opts.queue || (null == (hooks = jQuery._queueHooks(elem, "fx")).unqueued && (hooks.unqueued = 0, oldfire = hooks.empty.fire, hooks.empty.fire = function() {
                    hooks.unqueued || oldfire()
                }), hooks.unqueued++, anim.always(function() {
                    anim.always(function() {
                        hooks.unqueued--, jQuery.queue(elem, "fx").length || hooks.empty.fire()
                    })
                }));
                1 === elem.nodeType && ("height" in props || "width" in props) && (opts.overflow = [style.overflow, style.overflowX, style.overflowY], display = jQuery.css(elem, "display"), "inline" === ("none" === display ? jQuery._data(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display) && "none" === jQuery.css(elem, "float") && (support.inlineBlockNeedsLayout && "inline" !== defaultDisplay(elem.nodeName) ? style.zoom = 1 : style.display = "inline-block"));
                opts.overflow && (style.overflow = "hidden", support.shrinkWrapBlocks() || anim.always(function() {
                    style.overflow = opts.overflow[0], style.overflowX = opts.overflow[1], style.overflowY = opts.overflow[2]
                }));
                for (prop in props)
                    if (value = props[prop], rfxtypes.exec(value)) {
                        if (delete props[prop], toggle = toggle || "toggle" === value, value === (hidden ? "hide" : "show")) {
                            if ("show" !== value || !dataShow || void 0 === dataShow[prop]) continue;
                            hidden = !0
                        }
                        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop)
                    } else display = void 0;
                if (jQuery.isEmptyObject(orig)) "inline" === ("none" === display ? defaultDisplay(elem.nodeName) : display) && (style.display = display);
                else
                    for (prop in dataShow ? "hidden" in dataShow && (hidden = dataShow.hidden) : dataShow = jQuery._data(elem, "fxshow", {}), toggle && (dataShow.hidden = !hidden), hidden ? jQuery(elem).show() : anim.done(function() {
                            jQuery(elem).hide()
                        }), anim.done(function() {
                            var prop;
                            for (prop in jQuery._removeData(elem, "fxshow"), orig) jQuery.style(elem, prop, orig[prop])
                        }), orig) tween = createTween(hidden ? dataShow[prop] : 0, prop, anim), prop in dataShow || (dataShow[prop] = tween.start, hidden && (tween.end = tween.start, tween.start = "width" === prop || "height" === prop ? 1 : 0))
            }],
            tweeners = {
                "*": [function(prop, value) {
                    var tween = this.createTween(prop, value),
                        target = tween.cur(),
                        parts = rfxnum.exec(value),
                        unit = parts && parts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
                        start = (jQuery.cssNumber[prop] || "px" !== unit && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)),
                        scale = 1,
                        maxIterations = 20;
                    if (start && start[3] !== unit) {
                        unit = unit || start[3], parts = parts || [], start = +target || 1;
                        do {
                            start /= scale = scale || ".5", jQuery.style(tween.elem, prop, start + unit)
                        } while (scale !== (scale = tween.cur() / target) && 1 !== scale && --maxIterations)
                    }
                    return parts && (start = tween.start = +start || +target || 0, tween.unit = unit, tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2]), tween
                }]
            };

        function createFxNow() {
            return setTimeout(function() {
                fxNow = void 0
            }), fxNow = jQuery.now()
        }

        function genFx(type, includeWidth) {
            var which, attrs = {
                    height: type
                },
                i = 0;
            for (includeWidth = includeWidth ? 1 : 0; i < 4; i += 2 - includeWidth) attrs["margin" + (which = cssExpand[i])] = attrs["padding" + which] = type;
            return includeWidth && (attrs.opacity = attrs.width = type), attrs
        }

        function createTween(value, prop, animation) {
            for (var tween, collection = (tweeners[prop] || []).concat(tweeners["*"]), index = 0, length = collection.length; index < length; index++)
                if (tween = collection[index].call(animation, prop, value)) return tween
        }

        function Animation(elem, properties, options) {
            var result, stopped, index = 0,
                length = animationPrefilters.length,
                deferred = jQuery.Deferred().always(function() {
                    delete tick.elem
                }),
                tick = function() {
                    if (stopped) return !1;
                    for (var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), percent = 1 - (remaining / animation.duration || 0), index = 0, length = animation.tweens.length; index < length; index++) animation.tweens[index].run(percent);
                    return deferred.notifyWith(elem, [animation, percent, remaining]), percent < 1 && length ? remaining : (deferred.resolveWith(elem, [animation]), !1)
                },
                animation = deferred.promise({
                    elem: elem,
                    props: jQuery.extend({}, properties),
                    opts: jQuery.extend(!0, {
                        specialEasing: {}
                    }, options),
                    originalProperties: properties,
                    originalOptions: options,
                    startTime: fxNow || createFxNow(),
                    duration: options.duration,
                    tweens: [],
                    createTween: function(prop, end) {
                        var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                        return animation.tweens.push(tween), tween
                    },
                    stop: function(gotoEnd) {
                        var index = 0,
                            length = gotoEnd ? animation.tweens.length : 0;
                        if (stopped) return this;
                        for (stopped = !0; index < length; index++) animation.tweens[index].run(1);
                        return gotoEnd ? deferred.resolveWith(elem, [animation, gotoEnd]) : deferred.rejectWith(elem, [animation, gotoEnd]), this
                    }
                }),
                props = animation.props;
            for (! function(props, specialEasing) {
                    var index, name, easing, value, hooks;
                    for (index in props)
                        if (easing = specialEasing[name = jQuery.camelCase(index)], value = props[index], jQuery.isArray(value) && (easing = value[1], value = props[index] = value[0]), index !== name && (props[name] = value, delete props[index]), (hooks = jQuery.cssHooks[name]) && "expand" in hooks)
                            for (index in value = hooks.expand(value), delete props[name], value) index in props || (props[index] = value[index], specialEasing[index] = easing);
                        else specialEasing[name] = easing
                }(props, animation.opts.specialEasing); index < length; index++)
                if (result = animationPrefilters[index].call(animation, elem, props, animation.opts)) return result;
            return jQuery.map(props, createTween, animation), jQuery.isFunction(animation.opts.start) && animation.opts.start.call(elem, animation), jQuery.fx.timer(jQuery.extend(tick, {
                elem: elem,
                anim: animation,
                queue: animation.opts.queue
            })), animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always)
        }
        jQuery.Animation = jQuery.extend(Animation, {
            tweener: function(props, callback) {
                jQuery.isFunction(props) ? (callback = props, props = ["*"]) : props = props.split(" ");
                for (var prop, index = 0, length = props.length; index < length; index++) prop = props[index], tweeners[prop] = tweeners[prop] || [], tweeners[prop].unshift(callback)
            },
            prefilter: function(callback, prepend) {
                prepend ? animationPrefilters.unshift(callback) : animationPrefilters.push(callback)
            }
        }), jQuery.speed = function(speed, easing, fn) {
            var opt = speed && "object" == typeof speed ? jQuery.extend({}, speed) : {
                complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
                duration: speed,
                easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
            };
            return opt.duration = jQuery.fx.off ? 0 : "number" == typeof opt.duration ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default, null != opt.queue && !0 !== opt.queue || (opt.queue = "fx"), opt.old = opt.complete, opt.complete = function() {
                jQuery.isFunction(opt.old) && opt.old.call(this), opt.queue && jQuery.dequeue(this, opt.queue)
            }, opt
        }, jQuery.fn.extend({
            fadeTo: function(speed, to, easing, callback) {
                return this.filter(isHidden).css("opacity", 0).show().end().animate({
                    opacity: to
                }, speed, easing, callback)
            },
            animate: function(prop, speed, easing, callback) {
                var empty = jQuery.isEmptyObject(prop),
                    optall = jQuery.speed(speed, easing, callback),
                    doAnimation = function() {
                        var anim = Animation(this, jQuery.extend({}, prop), optall);
                        (empty || jQuery._data(this, "finish")) && anim.stop(!0)
                    };
                return doAnimation.finish = doAnimation, empty || !1 === optall.queue ? this.each(doAnimation) : this.queue(optall.queue, doAnimation)
            },
            stop: function(type, clearQueue, gotoEnd) {
                var stopQueue = function(hooks) {
                    var stop = hooks.stop;
                    delete hooks.stop, stop(gotoEnd)
                };
                return "string" != typeof type && (gotoEnd = clearQueue, clearQueue = type, type = void 0), clearQueue && !1 !== type && this.queue(type || "fx", []), this.each(function() {
                    var dequeue = !0,
                        index = null != type && type + "queueHooks",
                        timers = jQuery.timers,
                        data = jQuery._data(this);
                    if (index) data[index] && data[index].stop && stopQueue(data[index]);
                    else
                        for (index in data) data[index] && data[index].stop && rrun.test(index) && stopQueue(data[index]);
                    for (index = timers.length; index--;) timers[index].elem !== this || null != type && timers[index].queue !== type || (timers[index].anim.stop(gotoEnd), dequeue = !1, timers.splice(index, 1));
                    !dequeue && gotoEnd || jQuery.dequeue(this, type)
                })
            },
            finish: function(type) {
                return !1 !== type && (type = type || "fx"), this.each(function() {
                    var index, data = jQuery._data(this),
                        queue = data[type + "queue"],
                        hooks = data[type + "queueHooks"],
                        timers = jQuery.timers,
                        length = queue ? queue.length : 0;
                    for (data.finish = !0, jQuery.queue(this, type, []), hooks && hooks.stop && hooks.stop.call(this, !0), index = timers.length; index--;) timers[index].elem === this && timers[index].queue === type && (timers[index].anim.stop(!0), timers.splice(index, 1));
                    for (index = 0; index < length; index++) queue[index] && queue[index].finish && queue[index].finish.call(this);
                    delete data.finish
                })
            }
        }), jQuery.each(["toggle", "show", "hide"], function(i, name) {
            var cssFn = jQuery.fn[name];
            jQuery.fn[name] = function(speed, easing, callback) {
                return null == speed || "boolean" == typeof speed ? cssFn.apply(this, arguments) : this.animate(genFx(name, !0), speed, easing, callback)
            }
        }), jQuery.each({
            slideDown: genFx("show"),
            slideUp: genFx("hide"),
            slideToggle: genFx("toggle"),
            fadeIn: {
                opacity: "show"
            },
            fadeOut: {
                opacity: "hide"
            },
            fadeToggle: {
                opacity: "toggle"
            }
        }, function(name, props) {
            jQuery.fn[name] = function(speed, easing, callback) {
                return this.animate(props, speed, easing, callback)
            }
        }), jQuery.timers = [], jQuery.fx.tick = function() {
            var timer, timers = jQuery.timers,
                i = 0;
            for (fxNow = jQuery.now(); i < timers.length; i++)(timer = timers[i])() || timers[i] !== timer || timers.splice(i--, 1);
            timers.length || jQuery.fx.stop(), fxNow = void 0
        }, jQuery.fx.timer = function(timer) {
            jQuery.timers.push(timer), timer() ? jQuery.fx.start() : jQuery.timers.pop()
        }, jQuery.fx.interval = 13, jQuery.fx.start = function() {
            timerId || (timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval))
        }, jQuery.fx.stop = function() {
            clearInterval(timerId), timerId = null
        }, jQuery.fx.speeds = {
            slow: 600,
            fast: 200,
            _default: 400
        }, jQuery.fn.delay = function(time, type) {
            return time = jQuery.fx && jQuery.fx.speeds[time] || time, type = type || "fx", this.queue(type, function(next, hooks) {
                var timeout = setTimeout(next, time);
                hooks.stop = function() {
                    clearTimeout(timeout)
                }
            })
        }, (div = document.createElement("div")).setAttribute("className", "t"), div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", a = div.getElementsByTagName("a")[0], opt = (select = document.createElement("select")).appendChild(document.createElement("option")), input = div.getElementsByTagName("input")[0], a.style.cssText = "top:1px", support.getSetAttribute = "t" !== div.className, support.style = /top/.test(a.getAttribute("style")), support.hrefNormalized = "/a" === a.getAttribute("href"), support.checkOn = !!input.value, support.optSelected = opt.selected, support.enctype = !!document.createElement("form").enctype, select.disabled = !0, support.optDisabled = !opt.disabled, (input = document.createElement("input")).setAttribute("value", ""), support.input = "" === input.getAttribute("value"), input.value = "t", input.setAttribute("type", "radio"), support.radioValue = "t" === input.value;
        var rreturn = /\r/g;
        jQuery.fn.extend({
            val: function(value) {
                var hooks, ret, isFunction, elem = this[0];
                return arguments.length ? (isFunction = jQuery.isFunction(value), this.each(function(i) {
                    var val;
                    1 === this.nodeType && (null == (val = isFunction ? value.call(this, i, jQuery(this).val()) : value) ? val = "" : "number" == typeof val ? val += "" : jQuery.isArray(val) && (val = jQuery.map(val, function(value) {
                        return null == value ? "" : value + ""
                    })), (hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]) && "set" in hooks && void 0 !== hooks.set(this, val, "value") || (this.value = val))
                })) : elem ? (hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()]) && "get" in hooks && void 0 !== (ret = hooks.get(elem, "value")) ? ret : "string" == typeof(ret = elem.value) ? ret.replace(rreturn, "") : null == ret ? "" : ret : void 0
            }
        }), jQuery.extend({
            valHooks: {
                option: {
                    get: function(elem) {
                        var val = jQuery.find.attr(elem, "value");
                        return null != val ? val : jQuery.trim(jQuery.text(elem))
                    }
                },
                select: {
                    get: function(elem) {
                        for (var value, option, options = elem.options, index = elem.selectedIndex, one = "select-one" === elem.type || index < 0, values = one ? null : [], max = one ? index + 1 : options.length, i = index < 0 ? max : one ? index : 0; i < max; i++)
                            if (((option = options[i]).selected || i === index) && (support.optDisabled ? !option.disabled : null === option.getAttribute("disabled")) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
                                if (value = jQuery(option).val(), one) return value;
                                values.push(value)
                            } return values
                    },
                    set: function(elem, value) {
                        for (var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length; i--;)
                            if (option = options[i], jQuery.inArray(jQuery.valHooks.option.get(option), values) >= 0) try {
                                option.selected = optionSet = !0
                            } catch (_) {
                                option.scrollHeight
                            } else option.selected = !1;
                        return optionSet || (elem.selectedIndex = -1), options
                    }
                }
            }
        }), jQuery.each(["radio", "checkbox"], function() {
            jQuery.valHooks[this] = {
                set: function(elem, value) {
                    if (jQuery.isArray(value)) return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0
                }
            }, support.checkOn || (jQuery.valHooks[this].get = function(elem) {
                return null === elem.getAttribute("value") ? "on" : elem.value
            })
        });
        var nodeHook, boolHook, attrHandle = jQuery.expr.attrHandle,
            ruseDefault = /^(?:checked|selected)$/i,
            getSetAttribute = support.getSetAttribute,
            getSetInput = support.input;
        jQuery.fn.extend({
            attr: function(name, value) {
                return access(this, jQuery.attr, name, value, arguments.length > 1)
            },
            removeAttr: function(name) {
                return this.each(function() {
                    jQuery.removeAttr(this, name)
                })
            }
        }), jQuery.extend({
            attr: function(elem, name, value) {
                var hooks, ret, nType = elem.nodeType;
                if (elem && 3 !== nType && 8 !== nType && 2 !== nType) return typeof elem.getAttribute === strundefined ? jQuery.prop(elem, name, value) : (1 === nType && jQuery.isXMLDoc(elem) || (name = name.toLowerCase(), hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook)), void 0 === value ? hooks && "get" in hooks && null !== (ret = hooks.get(elem, name)) ? ret : null == (ret = jQuery.find.attr(elem, name)) ? void 0 : ret : null !== value ? hooks && "set" in hooks && void 0 !== (ret = hooks.set(elem, value, name)) ? ret : (elem.setAttribute(name, value + ""), value) : void jQuery.removeAttr(elem, name))
            },
            removeAttr: function(elem, value) {
                var name, propName, i = 0,
                    attrNames = value && value.match(rnotwhite);
                if (attrNames && 1 === elem.nodeType)
                    for (; name = attrNames[i++];) propName = jQuery.propFix[name] || name, jQuery.expr.match.bool.test(name) ? getSetInput && getSetAttribute || !ruseDefault.test(name) ? elem[propName] = !1 : elem[jQuery.camelCase("default-" + name)] = elem[propName] = !1 : jQuery.attr(elem, name, ""), elem.removeAttribute(getSetAttribute ? name : propName)
            },
            attrHooks: {
                type: {
                    set: function(elem, value) {
                        if (!support.radioValue && "radio" === value && jQuery.nodeName(elem, "input")) {
                            var val = elem.value;
                            return elem.setAttribute("type", value), val && (elem.value = val), value
                        }
                    }
                }
            }
        }), boolHook = {
            set: function(elem, value, name) {
                return !1 === value ? jQuery.removeAttr(elem, name) : getSetInput && getSetAttribute || !ruseDefault.test(name) ? elem.setAttribute(!getSetAttribute && jQuery.propFix[name] || name, name) : elem[jQuery.camelCase("default-" + name)] = elem[name] = !0, name
            }
        }, jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
            var getter = attrHandle[name] || jQuery.find.attr;
            attrHandle[name] = getSetInput && getSetAttribute || !ruseDefault.test(name) ? function(elem, name, isXML) {
                var ret, handle;
                return isXML || (handle = attrHandle[name], attrHandle[name] = ret, ret = null != getter(elem, name, isXML) ? name.toLowerCase() : null, attrHandle[name] = handle), ret
            } : function(elem, name, isXML) {
                if (!isXML) return elem[jQuery.camelCase("default-" + name)] ? name.toLowerCase() : null
            }
        }), getSetInput && getSetAttribute || (jQuery.attrHooks.value = {
            set: function(elem, value, name) {
                if (!jQuery.nodeName(elem, "input")) return nodeHook && nodeHook.set(elem, value, name);
                elem.defaultValue = value
            }
        }), getSetAttribute || (nodeHook = {
            set: function(elem, value, name) {
                var ret = elem.getAttributeNode(name);
                if (ret || elem.setAttributeNode(ret = elem.ownerDocument.createAttribute(name)), ret.value = value += "", "value" === name || value === elem.getAttribute(name)) return value
            }
        }, attrHandle.id = attrHandle.name = attrHandle.coords = function(elem, name, isXML) {
            var ret;
            if (!isXML) return (ret = elem.getAttributeNode(name)) && "" !== ret.value ? ret.value : null
        }, jQuery.valHooks.button = {
            get: function(elem, name) {
                var ret = elem.getAttributeNode(name);
                if (ret && ret.specified) return ret.value
            },
            set: nodeHook.set
        }, jQuery.attrHooks.contenteditable = {
            set: function(elem, value, name) {
                nodeHook.set(elem, "" !== value && value, name)
            }
        }, jQuery.each(["width", "height"], function(i, name) {
            jQuery.attrHooks[name] = {
                set: function(elem, value) {
                    if ("" === value) return elem.setAttribute(name, "auto"), value
                }
            }
        })), support.style || (jQuery.attrHooks.style = {
            get: function(elem) {
                return elem.style.cssText || void 0
            },
            set: function(elem, value) {
                return elem.style.cssText = value + ""
            }
        });
        var rfocusable = /^(?:input|select|textarea|button|object)$/i,
            rclickable = /^(?:a|area)$/i;
        jQuery.fn.extend({
            prop: function(name, value) {
                return access(this, jQuery.prop, name, value, arguments.length > 1)
            },
            removeProp: function(name) {
                return name = jQuery.propFix[name] || name, this.each(function() {
                    try {
                        this[name] = void 0, delete this[name]
                    } catch (e) {}
                })
            }
        }), jQuery.extend({
            propFix: {
                for: "htmlFor",
                class: "className"
            },
            prop: function(elem, name, value) {
                var ret, hooks, nType = elem.nodeType;
                if (elem && 3 !== nType && 8 !== nType && 2 !== nType) return (1 !== nType || !jQuery.isXMLDoc(elem)) && (name = jQuery.propFix[name] || name, hooks = jQuery.propHooks[name]), void 0 !== value ? hooks && "set" in hooks && void 0 !== (ret = hooks.set(elem, value, name)) ? ret : elem[name] = value : hooks && "get" in hooks && null !== (ret = hooks.get(elem, name)) ? ret : elem[name]
            },
            propHooks: {
                tabIndex: {
                    get: function(elem) {
                        var tabindex = jQuery.find.attr(elem, "tabindex");
                        return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1
                    }
                }
            }
        }), support.hrefNormalized || jQuery.each(["href", "src"], function(i, name) {
            jQuery.propHooks[name] = {
                get: function(elem) {
                    return elem.getAttribute(name, 4)
                }
            }
        }), support.optSelected || (jQuery.propHooks.selected = {
            get: function(elem) {
                var parent = elem.parentNode;
                return parent && (parent.selectedIndex, parent.parentNode && parent.parentNode.selectedIndex), null
            }
        }), jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
            jQuery.propFix[this.toLowerCase()] = this
        }), support.enctype || (jQuery.propFix.enctype = "encoding");
        var rclass = /[\t\r\n\f]/g;
        jQuery.fn.extend({
            addClass: function(value) {
                var classes, elem, cur, clazz, j, finalValue, i = 0,
                    len = this.length,
                    proceed = "string" == typeof value && value;
                if (jQuery.isFunction(value)) return this.each(function(j) {
                    jQuery(this).addClass(value.call(this, j, this.className))
                });
                if (proceed)
                    for (classes = (value || "").match(rnotwhite) || []; i < len; i++)
                        if (cur = 1 === (elem = this[i]).nodeType && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : " ")) {
                            for (j = 0; clazz = classes[j++];) cur.indexOf(" " + clazz + " ") < 0 && (cur += clazz + " ");
                            finalValue = jQuery.trim(cur), elem.className !== finalValue && (elem.className = finalValue)
                        } return this
            },
            removeClass: function(value) {
                var classes, elem, cur, clazz, j, finalValue, i = 0,
                    len = this.length,
                    proceed = 0 === arguments.length || "string" == typeof value && value;
                if (jQuery.isFunction(value)) return this.each(function(j) {
                    jQuery(this).removeClass(value.call(this, j, this.className))
                });
                if (proceed)
                    for (classes = (value || "").match(rnotwhite) || []; i < len; i++)
                        if (cur = 1 === (elem = this[i]).nodeType && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : "")) {
                            for (j = 0; clazz = classes[j++];)
                                for (; cur.indexOf(" " + clazz + " ") >= 0;) cur = cur.replace(" " + clazz + " ", " ");
                            finalValue = value ? jQuery.trim(cur) : "", elem.className !== finalValue && (elem.className = finalValue)
                        } return this
            },
            toggleClass: function(value, stateVal) {
                var type = typeof value;
                return "boolean" == typeof stateVal && "string" === type ? stateVal ? this.addClass(value) : this.removeClass(value) : jQuery.isFunction(value) ? this.each(function(i) {
                    jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal)
                }) : this.each(function() {
                    if ("string" === type)
                        for (var className, i = 0, self = jQuery(this), classNames = value.match(rnotwhite) || []; className = classNames[i++];) self.hasClass(className) ? self.removeClass(className) : self.addClass(className);
                    else type !== strundefined && "boolean" !== type || (this.className && jQuery._data(this, "__className__", this.className), this.className = this.className || !1 === value ? "" : jQuery._data(this, "__className__") || "")
                })
            },
            hasClass: function(selector) {
                for (var className = " " + selector + " ", i = 0, l = this.length; i < l; i++)
                    if (1 === this[i].nodeType && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) return !0;
                return !1
            }
        }), jQuery.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function(i, name) {
            jQuery.fn[name] = function(data, fn) {
                return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name)
            }
        }), jQuery.fn.extend({
            hover: function(fnOver, fnOut) {
                return this.mouseenter(fnOver).mouseleave(fnOut || fnOver)
            },
            bind: function(types, data, fn) {
                return this.on(types, null, data, fn)
            },
            unbind: function(types, fn) {
                return this.off(types, null, fn)
            },
            delegate: function(selector, types, data, fn) {
                return this.on(types, selector, data, fn)
            },
            undelegate: function(selector, types, fn) {
                return 1 === arguments.length ? this.off(selector, "**") : this.off(types, selector || "**", fn)
            }
        });
        var nonce = jQuery.now(),
            rquery = /\?/,
            rvalidtokens = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;
        jQuery.parseJSON = function(data) {
            if (window.JSON && window.JSON.parse) return window.JSON.parse(data + "");
            var requireNonComma, depth = null,
                str = jQuery.trim(data + "");
            return str && !jQuery.trim(str.replace(rvalidtokens, function(token, comma, open, close) {
                return requireNonComma && comma && (depth = 0), 0 === depth ? token : (requireNonComma = open || comma, depth += !close - !open, "")
            })) ? Function("return " + str)() : jQuery.error("Invalid JSON: " + data)
        }, jQuery.parseXML = function(data) {
            var xml;
            if (!data || "string" != typeof data) return null;
            try {
                window.DOMParser ? xml = (new DOMParser).parseFromString(data, "text/xml") : ((xml = new ActiveXObject("Microsoft.XMLDOM")).async = "false", xml.loadXML(data))
            } catch (e) {
                xml = void 0
            }
            return xml && xml.documentElement && !xml.getElementsByTagName("parsererror").length || jQuery.error("Invalid XML: " + data), xml
        };
        var ajaxLocParts, ajaxLocation, rhash = /#.*$/,
            rts = /([?&])_=[^&]*/,
            rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm,
            rnoContent = /^(?:GET|HEAD)$/,
            rprotocol = /^\/\//,
            rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
            prefilters = {},
            transports = {},
            allTypes = "*/".concat("*");
        try {
            ajaxLocation = location.href
        } catch (e) {
            (ajaxLocation = document.createElement("a")).href = "", ajaxLocation = ajaxLocation.href
        }

        function addToPrefiltersOrTransports(structure) {
            return function(dataTypeExpression, func) {
                "string" != typeof dataTypeExpression && (func = dataTypeExpression, dataTypeExpression = "*");
                var dataType, i = 0,
                    dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
                if (jQuery.isFunction(func))
                    for (; dataType = dataTypes[i++];) "+" === dataType.charAt(0) ? (dataType = dataType.slice(1) || "*", (structure[dataType] = structure[dataType] || []).unshift(func)) : (structure[dataType] = structure[dataType] || []).push(func)
            }
        }

        function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
            var inspected = {},
                seekingTransport = structure === transports;

            function inspect(dataType) {
                var selected;
                return inspected[dataType] = !0, jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
                    var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                    return "string" != typeof dataTypeOrTransport || seekingTransport || inspected[dataTypeOrTransport] ? seekingTransport ? !(selected = dataTypeOrTransport) : void 0 : (options.dataTypes.unshift(dataTypeOrTransport), inspect(dataTypeOrTransport), !1)
                }), selected
            }
            return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*")
        }

        function ajaxExtend(target, src) {
            var deep, key, flatOptions = jQuery.ajaxSettings.flatOptions || {};
            for (key in src) void 0 !== src[key] && ((flatOptions[key] ? target : deep || (deep = {}))[key] = src[key]);
            return deep && jQuery.extend(!0, target, deep), target
        }
        ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [], jQuery.extend({
            active: 0,
            lastModified: {},
            etag: {},
            ajaxSettings: {
                url: ajaxLocation,
                type: "GET",
                isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(ajaxLocParts[1]),
                global: !0,
                processData: !0,
                async: !0,
                contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                accepts: {
                    "*": allTypes,
                    text: "text/plain",
                    html: "text/html",
                    xml: "application/xml, text/xml",
                    json: "application/json, text/javascript"
                },
                contents: {
                    xml: /xml/,
                    html: /html/,
                    json: /json/
                },
                responseFields: {
                    xml: "responseXML",
                    text: "responseText",
                    json: "responseJSON"
                },
                converters: {
                    "* text": String,
                    "text html": !0,
                    "text json": jQuery.parseJSON,
                    "text xml": jQuery.parseXML
                },
                flatOptions: {
                    url: !0,
                    context: !0
                }
            },
            ajaxSetup: function(target, settings) {
                return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target)
            },
            ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
            ajaxTransport: addToPrefiltersOrTransports(transports),
            ajax: function(url, options) {
                "object" == typeof url && (options = url, url = void 0), options = options || {};
                var parts, i, cacheURL, responseHeadersString, timeoutTimer, fireGlobals, transport, responseHeaders, s = jQuery.ajaxSetup({}, options),
                    callbackContext = s.context || s,
                    globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
                    deferred = jQuery.Deferred(),
                    completeDeferred = jQuery.Callbacks("once memory"),
                    statusCode = s.statusCode || {},
                    requestHeaders = {},
                    requestHeadersNames = {},
                    state = 0,
                    strAbort = "canceled",
                    jqXHR = {
                        readyState: 0,
                        getResponseHeader: function(key) {
                            var match;
                            if (2 === state) {
                                if (!responseHeaders)
                                    for (responseHeaders = {}; match = rheaders.exec(responseHeadersString);) responseHeaders[match[1].toLowerCase()] = match[2];
                                match = responseHeaders[key.toLowerCase()]
                            }
                            return null == match ? null : match
                        },
                        getAllResponseHeaders: function() {
                            return 2 === state ? responseHeadersString : null
                        },
                        setRequestHeader: function(name, value) {
                            var lname = name.toLowerCase();
                            return state || (name = requestHeadersNames[lname] = requestHeadersNames[lname] || name, requestHeaders[name] = value), this
                        },
                        overrideMimeType: function(type) {
                            return state || (s.mimeType = type), this
                        },
                        statusCode: function(map) {
                            var code;
                            if (map)
                                if (state < 2)
                                    for (code in map) statusCode[code] = [statusCode[code], map[code]];
                                else jqXHR.always(map[jqXHR.status]);
                            return this
                        },
                        abort: function(statusText) {
                            var finalText = statusText || strAbort;
                            return transport && transport.abort(finalText), done(0, finalText), this
                        }
                    };
                if (deferred.promise(jqXHR).complete = completeDeferred.add, jqXHR.success = jqXHR.done, jqXHR.error = jqXHR.fail, s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//"), s.type = options.method || options.type || s.method || s.type, s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""], null == s.crossDomain && (parts = rurl.exec(s.url.toLowerCase()), s.crossDomain = !(!parts || parts[1] === ajaxLocParts[1] && parts[2] === ajaxLocParts[2] && (parts[3] || ("http:" === parts[1] ? "80" : "443")) === (ajaxLocParts[3] || ("http:" === ajaxLocParts[1] ? "80" : "443")))), s.data && s.processData && "string" != typeof s.data && (s.data = jQuery.param(s.data, s.traditional)), inspectPrefiltersOrTransports(prefilters, s, options, jqXHR), 2 === state) return jqXHR;
                for (i in (fireGlobals = jQuery.event && s.global) && 0 == jQuery.active++ && jQuery.event.trigger("ajaxStart"), s.type = s.type.toUpperCase(), s.hasContent = !rnoContent.test(s.type), cacheURL = s.url, s.hasContent || (s.data && (cacheURL = s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data, delete s.data), !1 === s.cache && (s.url = rts.test(cacheURL) ? cacheURL.replace(rts, "$1_=" + nonce++) : cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++)), s.ifModified && (jQuery.lastModified[cacheURL] && jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]), jQuery.etag[cacheURL] && jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL])), (s.data && s.hasContent && !1 !== s.contentType || options.contentType) && jqXHR.setRequestHeader("Content-Type", s.contentType), jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + ("*" !== s.dataTypes[0] ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]), s.headers) jqXHR.setRequestHeader(i, s.headers[i]);
                if (s.beforeSend && (!1 === s.beforeSend.call(callbackContext, jqXHR, s) || 2 === state)) return jqXHR.abort();
                for (i in strAbort = "abort", {
                        success: 1,
                        error: 1,
                        complete: 1
                    }) jqXHR[i](s[i]);
                if (transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR)) {
                    jqXHR.readyState = 1, fireGlobals && globalEventContext.trigger("ajaxSend", [jqXHR, s]), s.async && s.timeout > 0 && (timeoutTimer = setTimeout(function() {
                        jqXHR.abort("timeout")
                    }, s.timeout));
                    try {
                        state = 1, transport.send(requestHeaders, done)
                    } catch (e) {
                        if (!(state < 2)) throw e;
                        done(-1, e)
                    }
                } else done(-1, "No Transport");

                function done(status, nativeStatusText, responses, headers) {
                    var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                    2 !== state && (state = 2, timeoutTimer && clearTimeout(timeoutTimer), transport = void 0, responseHeadersString = headers || "", jqXHR.readyState = status > 0 ? 4 : 0, isSuccess = status >= 200 && status < 300 || 304 === status, responses && (response = function(s, jqXHR, responses) {
                        for (var firstDataType, ct, finalDataType, type, contents = s.contents, dataTypes = s.dataTypes;
                            "*" === dataTypes[0];) dataTypes.shift(), void 0 === ct && (ct = s.mimeType || jqXHR.getResponseHeader("Content-Type"));
                        if (ct)
                            for (type in contents)
                                if (contents[type] && contents[type].test(ct)) {
                                    dataTypes.unshift(type);
                                    break
                                } if (dataTypes[0] in responses) finalDataType = dataTypes[0];
                        else {
                            for (type in responses) {
                                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                                    finalDataType = type;
                                    break
                                }
                                firstDataType || (firstDataType = type)
                            }
                            finalDataType = finalDataType || firstDataType
                        }
                        if (finalDataType) return finalDataType !== dataTypes[0] && dataTypes.unshift(finalDataType), responses[finalDataType]
                    }(s, jqXHR, responses)), response = function(s, response, jqXHR, isSuccess) {
                        var conv2, current, conv, tmp, prev, converters = {},
                            dataTypes = s.dataTypes.slice();
                        if (dataTypes[1])
                            for (conv in s.converters) converters[conv.toLowerCase()] = s.converters[conv];
                        for (current = dataTypes.shift(); current;)
                            if (s.responseFields[current] && (jqXHR[s.responseFields[current]] = response), !prev && isSuccess && s.dataFilter && (response = s.dataFilter(response, s.dataType)), prev = current, current = dataTypes.shift())
                                if ("*" === current) current = prev;
                                else if ("*" !== prev && prev !== current) {
                            if (!(conv = converters[prev + " " + current] || converters["* " + current]))
                                for (conv2 in converters)
                                    if ((tmp = conv2.split(" "))[1] === current && (conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]])) {
                                        !0 === conv ? conv = converters[conv2] : !0 !== converters[conv2] && (current = tmp[0], dataTypes.unshift(tmp[1]));
                                        break
                                    } if (!0 !== conv)
                                if (conv && s.throws) response = conv(response);
                                else try {
                                    response = conv(response)
                                } catch (e) {
                                    return {
                                        state: "parsererror",
                                        error: conv ? e : "No conversion from " + prev + " to " + current
                                    }
                                }
                        }
                        return {
                            state: "success",
                            data: response
                        }
                    }(s, response, jqXHR, isSuccess), isSuccess ? (s.ifModified && ((modified = jqXHR.getResponseHeader("Last-Modified")) && (jQuery.lastModified[cacheURL] = modified), (modified = jqXHR.getResponseHeader("etag")) && (jQuery.etag[cacheURL] = modified)), 204 === status || "HEAD" === s.type ? statusText = "nocontent" : 304 === status ? statusText = "notmodified" : (statusText = response.state, success = response.data, isSuccess = !(error = response.error))) : (error = statusText, !status && statusText || (statusText = "error", status < 0 && (status = 0))), jqXHR.status = status, jqXHR.statusText = (nativeStatusText || statusText) + "", isSuccess ? deferred.resolveWith(callbackContext, [success, statusText, jqXHR]) : deferred.rejectWith(callbackContext, [jqXHR, statusText, error]), jqXHR.statusCode(statusCode), statusCode = void 0, fireGlobals && globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]), completeDeferred.fireWith(callbackContext, [jqXHR, statusText]), fireGlobals && (globalEventContext.trigger("ajaxComplete", [jqXHR, s]), --jQuery.active || jQuery.event.trigger("ajaxStop")))
                }
                return jqXHR
            },
            getJSON: function(url, data, callback) {
                return jQuery.get(url, data, callback, "json")
            },
            getScript: function(url, callback) {
                return jQuery.get(url, void 0, callback, "script")
            }
        }), jQuery.each(["get", "post"], function(i, method) {
            jQuery[method] = function(url, data, callback, type) {
                return jQuery.isFunction(data) && (type = type || callback, callback = data, data = void 0), jQuery.ajax({
                    url: url,
                    type: method,
                    dataType: type,
                    data: data,
                    success: callback
                })
            }
        }), jQuery._evalUrl = function(url) {
            return jQuery.ajax({
                url: url,
                type: "GET",
                dataType: "script",
                async: !1,
                global: !1,
                throws: !0
            })
        }, jQuery.fn.extend({
            wrapAll: function(html) {
                if (jQuery.isFunction(html)) return this.each(function(i) {
                    jQuery(this).wrapAll(html.call(this, i))
                });
                if (this[0]) {
                    var wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(!0);
                    this[0].parentNode && wrap.insertBefore(this[0]), wrap.map(function() {
                        for (var elem = this; elem.firstChild && 1 === elem.firstChild.nodeType;) elem = elem.firstChild;
                        return elem
                    }).append(this)
                }
                return this
            },
            wrapInner: function(html) {
                return jQuery.isFunction(html) ? this.each(function(i) {
                    jQuery(this).wrapInner(html.call(this, i))
                }) : this.each(function() {
                    var self = jQuery(this),
                        contents = self.contents();
                    contents.length ? contents.wrapAll(html) : self.append(html)
                })
            },
            wrap: function(html) {
                var isFunction = jQuery.isFunction(html);
                return this.each(function(i) {
                    jQuery(this).wrapAll(isFunction ? html.call(this, i) : html)
                })
            },
            unwrap: function() {
                return this.parent().each(function() {
                    jQuery.nodeName(this, "body") || jQuery(this).replaceWith(this.childNodes)
                }).end()
            }
        }), jQuery.expr.filters.hidden = function(elem) {
            return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 || !support.reliableHiddenOffsets() && "none" === (elem.style && elem.style.display || jQuery.css(elem, "display"))
        }, jQuery.expr.filters.visible = function(elem) {
            return !jQuery.expr.filters.hidden(elem)
        };
        var r20 = /%20/g,
            rbracket = /\[\]$/,
            rCRLF = /\r?\n/g,
            rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
            rsubmittable = /^(?:input|select|textarea|keygen)/i;

        function buildParams(prefix, obj, traditional, add) {
            var name;
            if (jQuery.isArray(obj)) jQuery.each(obj, function(i, v) {
                traditional || rbracket.test(prefix) ? add(prefix, v) : buildParams(prefix + "[" + ("object" == typeof v ? i : "") + "]", v, traditional, add)
            });
            else if (traditional || "object" !== jQuery.type(obj)) add(prefix, obj);
            else
                for (name in obj) buildParams(prefix + "[" + name + "]", obj[name], traditional, add)
        }
        jQuery.param = function(a, traditional) {
            var prefix, s = [],
                add = function(key, value) {
                    value = jQuery.isFunction(value) ? value() : null == value ? "" : value, s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value)
                };
            if (void 0 === traditional && (traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional), jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) jQuery.each(a, function() {
                add(this.name, this.value)
            });
            else
                for (prefix in a) buildParams(prefix, a[prefix], traditional, add);
            return s.join("&").replace(r20, "+")
        }, jQuery.fn.extend({
            serialize: function() {
                return jQuery.param(this.serializeArray())
            },
            serializeArray: function() {
                return this.map(function() {
                    var elements = jQuery.prop(this, "elements");
                    return elements ? jQuery.makeArray(elements) : this
                }).filter(function() {
                    var type = this.type;
                    return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type))
                }).map(function(i, elem) {
                    var val = jQuery(this).val();
                    return null == val ? null : jQuery.isArray(val) ? jQuery.map(val, function(val) {
                        return {
                            name: elem.name,
                            value: val.replace(rCRLF, "\r\n")
                        }
                    }) : {
                        name: elem.name,
                        value: val.replace(rCRLF, "\r\n")
                    }
                }).get()
            }
        }), jQuery.ajaxSettings.xhr = void 0 !== window.ActiveXObject ? function() {
            return !this.isLocal && /^(get|post|head|put|delete|options)$/i.test(this.type) && createStandardXHR() || function() {
                try {
                    return new window.ActiveXObject("Microsoft.XMLHTTP")
                } catch (e) {}
            }()
        } : createStandardXHR;
        var xhrId = 0,
            xhrCallbacks = {},
            xhrSupported = jQuery.ajaxSettings.xhr();

        function createStandardXHR() {
            try {
                return new window.XMLHttpRequest
            } catch (e) {}
        }
        window.attachEvent && window.attachEvent("onunload", function() {
            for (var key in xhrCallbacks) xhrCallbacks[key](void 0, !0)
        }), support.cors = !!xhrSupported && "withCredentials" in xhrSupported, (xhrSupported = support.ajax = !!xhrSupported) && jQuery.ajaxTransport(function(options) {
            var callback;
            if (!options.crossDomain || support.cors) return {
                send: function(headers, complete) {
                    var i, xhr = options.xhr(),
                        id = ++xhrId;
                    if (xhr.open(options.type, options.url, options.async, options.username, options.password), options.xhrFields)
                        for (i in options.xhrFields) xhr[i] = options.xhrFields[i];
                    for (i in options.mimeType && xhr.overrideMimeType && xhr.overrideMimeType(options.mimeType), options.crossDomain || headers["X-Requested-With"] || (headers["X-Requested-With"] = "XMLHttpRequest"), headers) void 0 !== headers[i] && xhr.setRequestHeader(i, headers[i] + "");
                    xhr.send(options.hasContent && options.data || null), callback = function(_, isAbort) {
                        var status, statusText, responses;
                        if (callback && (isAbort || 4 === xhr.readyState))
                            if (delete xhrCallbacks[id], callback = void 0, xhr.onreadystatechange = jQuery.noop, isAbort) 4 !== xhr.readyState && xhr.abort();
                            else {
                                responses = {}, status = xhr.status, "string" == typeof xhr.responseText && (responses.text = xhr.responseText);
                                try {
                                    statusText = xhr.statusText
                                } catch (e) {
                                    statusText = ""
                                }
                                status || !options.isLocal || options.crossDomain ? 1223 === status && (status = 204) : status = responses.text ? 200 : 404
                            } responses && complete(status, statusText, responses, xhr.getAllResponseHeaders())
                    }, options.async ? 4 === xhr.readyState ? setTimeout(callback) : xhr.onreadystatechange = xhrCallbacks[id] = callback : callback()
                },
                abort: function() {
                    callback && callback(void 0, !0)
                }
            }
        }), jQuery.ajaxSetup({
            accepts: {
                script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
            },
            contents: {
                script: /(?:java|ecma)script/
            },
            converters: {
                "text script": function(text) {
                    return jQuery.globalEval(text), text
                }
            }
        }), jQuery.ajaxPrefilter("script", function(s) {
            void 0 === s.cache && (s.cache = !1), s.crossDomain && (s.type = "GET", s.global = !1)
        }), jQuery.ajaxTransport("script", function(s) {
            if (s.crossDomain) {
                var script, head = document.head || jQuery("head")[0] || document.documentElement;
                return {
                    send: function(_, callback) {
                        (script = document.createElement("script")).async = !0, s.scriptCharset && (script.charset = s.scriptCharset), script.src = s.url, script.onload = script.onreadystatechange = function(_, isAbort) {
                            (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) && (script.onload = script.onreadystatechange = null, script.parentNode && script.parentNode.removeChild(script), script = null, isAbort || callback(200, "success"))
                        }, head.insertBefore(script, head.firstChild)
                    },
                    abort: function() {
                        script && script.onload(void 0, !0)
                    }
                }
            }
        });
        var oldCallbacks = [],
            rjsonp = /(=)\?(?=&|$)|\?\?/;
        jQuery.ajaxSetup({
            jsonp: "callback",
            jsonpCallback: function() {
                var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
                return this[callback] = !0, callback
            }
        }), jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
            var callbackName, overwritten, responseContainer, jsonProp = !1 !== s.jsonp && (rjsonp.test(s.url) ? "url" : "string" == typeof s.data && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");
            if (jsonProp || "jsonp" === s.dataTypes[0]) return callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback, jsonProp ? s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName) : !1 !== s.jsonp && (s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName), s.converters["script json"] = function() {
                return responseContainer || jQuery.error(callbackName + " was not called"), responseContainer[0]
            }, s.dataTypes[0] = "json", overwritten = window[callbackName], window[callbackName] = function() {
                responseContainer = arguments
            }, jqXHR.always(function() {
                window[callbackName] = overwritten, s[callbackName] && (s.jsonpCallback = originalSettings.jsonpCallback, oldCallbacks.push(callbackName)), responseContainer && jQuery.isFunction(overwritten) && overwritten(responseContainer[0]), responseContainer = overwritten = void 0
            }), "script"
        }), jQuery.parseHTML = function(data, context, keepScripts) {
            if (!data || "string" != typeof data) return null;
            "boolean" == typeof context && (keepScripts = context, context = !1), context = context || document;
            var parsed = rsingleTag.exec(data),
                scripts = !keepScripts && [];
            return parsed ? [context.createElement(parsed[1])] : (parsed = jQuery.buildFragment([data], context, scripts), scripts && scripts.length && jQuery(scripts).remove(), jQuery.merge([], parsed.childNodes))
        };
        var _load = jQuery.fn.load;
        jQuery.fn.load = function(url, params, callback) {
            if ("string" != typeof url && _load) return _load.apply(this, arguments);
            var selector, response, type, self = this,
                off = url.indexOf(" ");
            return off >= 0 && (selector = jQuery.trim(url.slice(off, url.length)), url = url.slice(0, off)), jQuery.isFunction(params) ? (callback = params, params = void 0) : params && "object" == typeof params && (type = "POST"), self.length > 0 && jQuery.ajax({
                url: url,
                type: type,
                dataType: "html",
                data: params
            }).done(function(responseText) {
                response = arguments, self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText)
            }).complete(callback && function(jqXHR, status) {
                self.each(callback, response || [jqXHR.responseText, status, jqXHR])
            }), this
        }, jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(i, type) {
            jQuery.fn[type] = function(fn) {
                return this.on(type, fn)
            }
        }), jQuery.expr.filters.animated = function(elem) {
            return jQuery.grep(jQuery.timers, function(fn) {
                return elem === fn.elem
            }).length
        };
        var docElem = window.document.documentElement;

        function getWindow(elem) {
            return jQuery.isWindow(elem) ? elem : 9 === elem.nodeType && (elem.defaultView || elem.parentWindow)
        }
        jQuery.offset = {
            setOffset: function(elem, options, i) {
                var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, position = jQuery.css(elem, "position"),
                    curElem = jQuery(elem),
                    props = {};
                "static" === position && (elem.style.position = "relative"), curOffset = curElem.offset(), curCSSTop = jQuery.css(elem, "top"), curCSSLeft = jQuery.css(elem, "left"), ("absolute" === position || "fixed" === position) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1 ? (curTop = (curPosition = curElem.position()).top, curLeft = curPosition.left) : (curTop = parseFloat(curCSSTop) || 0, curLeft = parseFloat(curCSSLeft) || 0), jQuery.isFunction(options) && (options = options.call(elem, i, curOffset)), null != options.top && (props.top = options.top - curOffset.top + curTop), null != options.left && (props.left = options.left - curOffset.left + curLeft), "using" in options ? options.using.call(elem, props) : curElem.css(props)
            }
        }, jQuery.fn.extend({
            offset: function(options) {
                if (arguments.length) return void 0 === options ? this : this.each(function(i) {
                    jQuery.offset.setOffset(this, options, i)
                });
                var docElem, win, box = {
                        top: 0,
                        left: 0
                    },
                    elem = this[0],
                    doc = elem && elem.ownerDocument;
                return doc ? (docElem = doc.documentElement, jQuery.contains(docElem, elem) ? (typeof elem.getBoundingClientRect !== strundefined && (box = elem.getBoundingClientRect()), win = getWindow(doc), {
                    top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
                    left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)
                }) : box) : void 0
            },
            position: function() {
                if (this[0]) {
                    var offsetParent, offset, parentOffset = {
                            top: 0,
                            left: 0
                        },
                        elem = this[0];
                    return "fixed" === jQuery.css(elem, "position") ? offset = elem.getBoundingClientRect() : (offsetParent = this.offsetParent(), offset = this.offset(), jQuery.nodeName(offsetParent[0], "html") || (parentOffset = offsetParent.offset()), parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", !0), parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", !0)), {
                        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", !0),
                        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", !0)
                    }
                }
            },
            offsetParent: function() {
                return this.map(function() {
                    for (var offsetParent = this.offsetParent || docElem; offsetParent && !jQuery.nodeName(offsetParent, "html") && "static" === jQuery.css(offsetParent, "position");) offsetParent = offsetParent.offsetParent;
                    return offsetParent || docElem
                })
            }
        }), jQuery.each({
            scrollLeft: "pageXOffset",
            scrollTop: "pageYOffset"
        }, function(method, prop) {
            var top = /Y/.test(prop);
            jQuery.fn[method] = function(val) {
                return access(this, function(elem, method, val) {
                    var win = getWindow(elem);
                    if (void 0 === val) return win ? prop in win ? win[prop] : win.document.documentElement[method] : elem[method];
                    win ? win.scrollTo(top ? jQuery(win).scrollLeft() : val, top ? val : jQuery(win).scrollTop()) : elem[method] = val
                }, method, val, arguments.length, null)
            }
        }), jQuery.each(["top", "left"], function(i, prop) {
            jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
                if (computed) return computed = curCSS(elem, prop), rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed
            })
        }), jQuery.each({
            Height: "height",
            Width: "width"
        }, function(name, type) {
            jQuery.each({
                padding: "inner" + name,
                content: type,
                "": "outer" + name
            }, function(defaultExtra, funcName) {
                jQuery.fn[funcName] = function(margin, value) {
                    var chainable = arguments.length && (defaultExtra || "boolean" != typeof margin),
                        extra = defaultExtra || (!0 === margin || !0 === value ? "margin" : "border");
                    return access(this, function(elem, type, value) {
                        var doc;
                        return jQuery.isWindow(elem) ? elem.document.documentElement["client" + name] : 9 === elem.nodeType ? (doc = elem.documentElement, Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name])) : void 0 === value ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra)
                    }, type, chainable ? margin : void 0, chainable, null)
                }
            })
        }), jQuery.fn.size = function() {
            return this.length
        }, jQuery.fn.andSelf = jQuery.fn.addBack, void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
            return jQuery
        }.apply(exports, [])) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
        var _jQuery = window.jQuery,
            _$ = window.$;
        return jQuery.noConflict = function(deep) {
            return window.$ === jQuery && (window.$ = _$), deep && window.jQuery === jQuery && (window.jQuery = _jQuery), jQuery
        }, typeof noGlobal === strundefined && (window.jQuery = window.$ = jQuery), jQuery
    }, "object" == typeof module && "object" == typeof module.exports ? module.exports = global.document ? factory(global, !0) : function(w) {
        if (!w.document) throw new Error("jQuery requires a window with a document");
        return factory(w)
    } : factory(global)
}, function(module, exports, __webpack_require__) {
    var isObject = __webpack_require__(4),
        document = __webpack_require__(2).document,
        is = isObject(document) && isObject(document.createElement);
    module.exports = function(it) {
        return is ? document.createElement(it) : {}
    }
}, function(module, exports, __webpack_require__) {
    var global = __webpack_require__(2),
        core = __webpack_require__(18),
        LIBRARY = __webpack_require__(29),
        wksExt = __webpack_require__(98),
        defineProperty = __webpack_require__(8).f;
    module.exports = function(name) {
        var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
        "_" == name.charAt(0) || name in $Symbol || defineProperty($Symbol, name, {
            value: wksExt.f(name)
        })
    }
}, function(module, exports, __webpack_require__) {
    var shared = __webpack_require__(48)("keys"),
        uid = __webpack_require__(33);
    module.exports = function(key) {
        return shared[key] || (shared[key] = uid(key))
    }
}, function(module, exports) {
    module.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")
}, function(module, exports, __webpack_require__) {
    var document = __webpack_require__(2).document;
    module.exports = document && document.documentElement
}, function(module, exports, __webpack_require__) {
    var isObject = __webpack_require__(4),
        anObject = __webpack_require__(1),
        check = function(O, proto) {
            if (anObject(O), !isObject(proto) && null !== proto) throw TypeError(proto + ": can't set as prototype!")
        };
    module.exports = {
        set: Object.setPrototypeOf || ("__proto__" in {} ? function(test, buggy, set) {
            try {
                (set = __webpack_require__(19)(Function.call, __webpack_require__(16).f(Object.prototype, "__proto__").set, 2))(test, []), buggy = !(test instanceof Array)
            } catch (e) {
                buggy = !0
            }
            return function(O, proto) {
                return check(O, proto), buggy ? O.__proto__ = proto : set(O, proto), O
            }
        }({}, !1) : void 0),
        check: check
    }
}, function(module, exports) {
    module.exports = "\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"
}, function(module, exports, __webpack_require__) {
    var isObject = __webpack_require__(4),
        setPrototypeOf = __webpack_require__(75).set;
    module.exports = function(that, target, C) {
        var P, S = target.constructor;
        return S !== C && "function" == typeof S && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf && setPrototypeOf(that, P), that
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var toInteger = __webpack_require__(21),
        defined = __webpack_require__(24);
    module.exports = function(count) {
        var str = String(defined(this)),
            res = "",
            n = toInteger(count);
        if (n < 0 || n == 1 / 0) throw RangeError("Count can't be negative");
        for (; n > 0;
            (n >>>= 1) && (str += str)) 1 & n && (res += str);
        return res
    }
}, function(module, exports) {
    module.exports = Math.sign || function(x) {
        return 0 == (x = +x) || x != x ? x : x < 0 ? -1 : 1
    }
}, function(module, exports) {
    var $expm1 = Math.expm1;
    module.exports = !$expm1 || $expm1(10) > 22025.465794806718 || $expm1(10) < 22025.465794806718 || -2e-17 != $expm1(-2e-17) ? function(x) {
        return 0 == (x = +x) ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1
    } : $expm1
}, function(module, exports, __webpack_require__) {
    "use strict";
    var LIBRARY = __webpack_require__(29),
        $export = __webpack_require__(0),
        redefine = __webpack_require__(12),
        hide = __webpack_require__(11),
        Iterators = __webpack_require__(47),
        $iterCreate = __webpack_require__(82),
        setToStringTag = __webpack_require__(44),
        getPrototypeOf = __webpack_require__(17),
        ITERATOR = __webpack_require__(5)("iterator"),
        BUGGY = !([].keys && "next" in [].keys()),
        returnThis = function() {
            return this
        };
    module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
        $iterCreate(Constructor, NAME, next);
        var methods, key, IteratorPrototype, getMethod = function(kind) {
                if (!BUGGY && kind in proto) return proto[kind];
                switch (kind) {
                    case "keys":
                    case "values":
                        return function() {
                            return new Constructor(this, kind)
                        }
                }
                return function() {
                    return new Constructor(this, kind)
                }
            },
            TAG = NAME + " Iterator",
            DEF_VALUES = "values" == DEFAULT,
            VALUES_BUG = !1,
            proto = Base.prototype,
            $native = proto[ITERATOR] || proto["@@iterator"] || DEFAULT && proto[DEFAULT],
            $default = $native || getMethod(DEFAULT),
            $entries = DEFAULT ? DEF_VALUES ? getMethod("entries") : $default : void 0,
            $anyNative = "Array" == NAME && proto.entries || $native;
        if ($anyNative && (IteratorPrototype = getPrototypeOf($anyNative.call(new Base))) !== Object.prototype && IteratorPrototype.next && (setToStringTag(IteratorPrototype, TAG, !0), LIBRARY || "function" == typeof IteratorPrototype[ITERATOR] || hide(IteratorPrototype, ITERATOR, returnThis)), DEF_VALUES && $native && "values" !== $native.name && (VALUES_BUG = !0, $default = function() {
                return $native.call(this)
            }), LIBRARY && !FORCED || !BUGGY && !VALUES_BUG && proto[ITERATOR] || hide(proto, ITERATOR, $default), Iterators[NAME] = $default, Iterators[TAG] = returnThis, DEFAULT)
            if (methods = {
                    values: DEF_VALUES ? $default : getMethod("values"),
                    keys: IS_SET ? $default : getMethod("keys"),
                    entries: $entries
                }, FORCED)
                for (key in methods) key in proto || redefine(proto, key, methods[key]);
            else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
        return methods
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var create = __webpack_require__(36),
        descriptor = __webpack_require__(32),
        setToStringTag = __webpack_require__(44),
        IteratorPrototype = {};
    __webpack_require__(11)(IteratorPrototype, __webpack_require__(5)("iterator"), function() {
        return this
    }), module.exports = function(Constructor, NAME, next) {
        Constructor.prototype = create(IteratorPrototype, {
            next: descriptor(1, next)
        }), setToStringTag(Constructor, NAME + " Iterator")
    }
}, function(module, exports, __webpack_require__) {
    var isRegExp = __webpack_require__(59),
        defined = __webpack_require__(24);
    module.exports = function(that, searchString, NAME) {
        if (isRegExp(searchString)) throw TypeError("String#" + NAME + " doesn't accept regex!");
        return String(defined(that))
    }
}, function(module, exports, __webpack_require__) {
    var MATCH = __webpack_require__(5)("match");
    module.exports = function(KEY) {
        var re = /./;
        try {
            "/./" [KEY](re)
        } catch (e) {
            try {
                return re[MATCH] = !1, !"/./" [KEY](re)
            } catch (f) {}
        }
        return !0
    }
}, function(module, exports, __webpack_require__) {
    var Iterators = __webpack_require__(47),
        ITERATOR = __webpack_require__(5)("iterator"),
        ArrayProto = Array.prototype;
    module.exports = function(it) {
        return void 0 !== it && (Iterators.Array === it || ArrayProto[ITERATOR] === it)
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $defineProperty = __webpack_require__(8),
        createDesc = __webpack_require__(32);
    module.exports = function(object, index, value) {
        index in object ? $defineProperty.f(object, index, createDesc(0, value)) : object[index] = value
    }
}, function(module, exports, __webpack_require__) {
    var classof = __webpack_require__(45),
        ITERATOR = __webpack_require__(5)("iterator"),
        Iterators = __webpack_require__(47);
    module.exports = __webpack_require__(18).getIteratorMethod = function(it) {
        if (void 0 != it) return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)]
    }
}, function(module, exports, __webpack_require__) {
    var speciesConstructor = __webpack_require__(227);
    module.exports = function(original, length) {
        return new(speciesConstructor(original))(length)
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var toObject = __webpack_require__(9),
        toAbsoluteIndex = __webpack_require__(35),
        toLength = __webpack_require__(6);
    module.exports = function(value) {
        for (var O = toObject(this), length = toLength(O.length), aLen = arguments.length, index = toAbsoluteIndex(aLen > 1 ? arguments[1] : void 0, length), end = aLen > 2 ? arguments[2] : void 0, endPos = void 0 === end ? length : toAbsoluteIndex(end, length); endPos > index;) O[index++] = value;
        return O
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var addToUnscopables = __webpack_require__(31),
        step = __webpack_require__(115),
        Iterators = __webpack_require__(47),
        toIObject = __webpack_require__(15);
    module.exports = __webpack_require__(81)(Array, "Array", function(iterated, kind) {
        this._t = toIObject(iterated), this._i = 0, this._k = kind
    }, function() {
        var O = this._t,
            kind = this._k,
            index = this._i++;
        return !O || index >= O.length ? (this._t = void 0, step(1)) : step(0, "keys" == kind ? index : "values" == kind ? O[index] : [index, O[index]])
    }, "values"), Iterators.Arguments = Iterators.Array, addToUnscopables("keys"), addToUnscopables("values"), addToUnscopables("entries")
}, function(module, exports, __webpack_require__) {
    "use strict";
    var re1, re2, regexpFlags = __webpack_require__(51),
        nativeExec = RegExp.prototype.exec,
        nativeReplace = String.prototype.replace,
        patchedExec = nativeExec,
        UPDATES_LAST_INDEX_WRONG = (re1 = /a/, re2 = /b*/g, nativeExec.call(re1, "a"), nativeExec.call(re2, "a"), 0 !== re1.lastIndex || 0 !== re2.lastIndex),
        NPCG_INCLUDED = void 0 !== /()??/.exec("")[1];
    (UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED) && (patchedExec = function(str) {
        var lastIndex, reCopy, match, i, re = this;
        return NPCG_INCLUDED && (reCopy = new RegExp("^" + re.source + "$(?!\\s)", regexpFlags.call(re))), UPDATES_LAST_INDEX_WRONG && (lastIndex = re.lastIndex), match = nativeExec.call(re, str), UPDATES_LAST_INDEX_WRONG && match && (re.lastIndex = re.global ? match.index + match[0].length : lastIndex), NPCG_INCLUDED && match && match.length > 1 && nativeReplace.call(match[0], reCopy, function() {
            for (i = 1; i < arguments.length - 2; i++) void 0 === arguments[i] && (match[i] = void 0)
        }), match
    }), module.exports = patchedExec
}, function(module, exports, __webpack_require__) {
    "use strict";
    var at = __webpack_require__(58)(!0);
    module.exports = function(S, index, unicode) {
        return index + (unicode ? at(S, index).length : 1)
    }
}, function(module, exports, __webpack_require__) {
    var defer, channel, port, ctx = __webpack_require__(19),
        invoke = __webpack_require__(105),
        html = __webpack_require__(74),
        cel = __webpack_require__(70),
        global = __webpack_require__(2),
        process = global.process,
        setTask = global.setImmediate,
        clearTask = global.clearImmediate,
        MessageChannel = global.MessageChannel,
        Dispatch = global.Dispatch,
        counter = 0,
        queue = {},
        run = function() {
            var id = +this;
            if (queue.hasOwnProperty(id)) {
                var fn = queue[id];
                delete queue[id], fn()
            }
        },
        listener = function(event) {
            run.call(event.data)
        };
    setTask && clearTask || (setTask = function(fn) {
        for (var args = [], i = 1; arguments.length > i;) args.push(arguments[i++]);
        return queue[++counter] = function() {
            invoke("function" == typeof fn ? fn : Function(fn), args)
        }, defer(counter), counter
    }, clearTask = function(id) {
        delete queue[id]
    }, "process" == __webpack_require__(20)(process) ? defer = function(id) {
        process.nextTick(ctx(run, id, 1))
    } : Dispatch && Dispatch.now ? defer = function(id) {
        Dispatch.now(ctx(run, id, 1))
    } : MessageChannel ? (port = (channel = new MessageChannel).port2, channel.port1.onmessage = listener, defer = ctx(port.postMessage, port, 1)) : global.addEventListener && "function" == typeof postMessage && !global.importScripts ? (defer = function(id) {
        global.postMessage(id + "", "*")
    }, global.addEventListener("message", listener, !1)) : defer = "onreadystatechange" in cel("script") ? function(id) {
        html.appendChild(cel("script")).onreadystatechange = function() {
            html.removeChild(this), run.call(id)
        }
    } : function(id) {
        setTimeout(ctx(run, id, 1), 0)
    }), module.exports = {
        set: setTask,
        clear: clearTask
    }
}, function(module, exports, __webpack_require__) {
    var global = __webpack_require__(2),
        macrotask = __webpack_require__(93).set,
        Observer = global.MutationObserver || global.WebKitMutationObserver,
        process = global.process,
        Promise = global.Promise,
        isNode = "process" == __webpack_require__(20)(process);
    module.exports = function() {
        var head, last, notify, flush = function() {
            var parent, fn;
            for (isNode && (parent = process.domain) && parent.exit(); head;) {
                fn = head.fn, head = head.next;
                try {
                    fn()
                } catch (e) {
                    throw head ? notify() : last = void 0, e
                }
            }
            last = void 0, parent && parent.enter()
        };
        if (isNode) notify = function() {
            process.nextTick(flush)
        };
        else if (!Observer || global.navigator && global.navigator.standalone)
            if (Promise && Promise.resolve) {
                var promise = Promise.resolve(void 0);
                notify = function() {
                    promise.then(flush)
                }
            } else notify = function() {
                macrotask.call(global, flush)
            };
        else {
            var toggle = !0,
                node = document.createTextNode("");
            new Observer(flush).observe(node, {
                characterData: !0
            }), notify = function() {
                node.data = toggle = !toggle
            }
        }
        return function(fn) {
            var task = {
                fn: fn,
                next: void 0
            };
            last && (last.next = task), head || (head = task, notify()), last = task
        }
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var aFunction = __webpack_require__(10);
    module.exports.f = function(C) {
        return new function(C) {
            var resolve, reject;
            this.promise = new C(function($$resolve, $$reject) {
                if (void 0 !== resolve || void 0 !== reject) throw TypeError("Bad Promise constructor");
                resolve = $$resolve, reject = $$reject
            }), this.resolve = aFunction(resolve), this.reject = aFunction(reject)
        }(C)
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var global = __webpack_require__(2),
        DESCRIPTORS = __webpack_require__(7),
        LIBRARY = __webpack_require__(29),
        $typed = __webpack_require__(65),
        hide = __webpack_require__(11),
        redefineAll = __webpack_require__(41),
        fails = __webpack_require__(3),
        anInstance = __webpack_require__(39),
        toInteger = __webpack_require__(21),
        toLength = __webpack_require__(6),
        toIndex = __webpack_require__(125),
        gOPN = __webpack_require__(37).f,
        dP = __webpack_require__(8).f,
        arrayFill = __webpack_require__(89),
        setToStringTag = __webpack_require__(44),
        PROTOTYPE = "prototype",
        WRONG_INDEX = "Wrong index!",
        $ArrayBuffer = global.ArrayBuffer,
        $DataView = global.DataView,
        Math = global.Math,
        RangeError = global.RangeError,
        Infinity = global.Infinity,
        BaseBuffer = $ArrayBuffer,
        abs = Math.abs,
        pow = Math.pow,
        floor = Math.floor,
        log = Math.log,
        LN2 = Math.LN2,
        $BUFFER = DESCRIPTORS ? "_b" : "buffer",
        $LENGTH = DESCRIPTORS ? "_l" : "byteLength",
        $OFFSET = DESCRIPTORS ? "_o" : "byteOffset";

    function packIEEE754(value, mLen, nBytes) {
        var e, m, c, buffer = new Array(nBytes),
            eLen = 8 * nBytes - mLen - 1,
            eMax = (1 << eLen) - 1,
            eBias = eMax >> 1,
            rt = 23 === mLen ? pow(2, -24) - pow(2, -77) : 0,
            i = 0,
            s = value < 0 || 0 === value && 1 / value < 0 ? 1 : 0;
        for ((value = abs(value)) != value || value === Infinity ? (m = value != value ? 1 : 0, e = eMax) : (e = floor(log(value) / LN2), value * (c = pow(2, -e)) < 1 && (e--, c *= 2), (value += e + eBias >= 1 ? rt / c : rt * pow(2, 1 - eBias)) * c >= 2 && (e++, c /= 2), e + eBias >= eMax ? (m = 0, e = eMax) : e + eBias >= 1 ? (m = (value * c - 1) * pow(2, mLen), e += eBias) : (m = value * pow(2, eBias - 1) * pow(2, mLen), e = 0)); mLen >= 8; buffer[i++] = 255 & m, m /= 256, mLen -= 8);
        for (e = e << mLen | m, eLen += mLen; eLen > 0; buffer[i++] = 255 & e, e /= 256, eLen -= 8);
        return buffer[--i] |= 128 * s, buffer
    }

    function unpackIEEE754(buffer, mLen, nBytes) {
        var m, eLen = 8 * nBytes - mLen - 1,
            eMax = (1 << eLen) - 1,
            eBias = eMax >> 1,
            nBits = eLen - 7,
            i = nBytes - 1,
            s = buffer[i--],
            e = 127 & s;
        for (s >>= 7; nBits > 0; e = 256 * e + buffer[i], i--, nBits -= 8);
        for (m = e & (1 << -nBits) - 1, e >>= -nBits, nBits += mLen; nBits > 0; m = 256 * m + buffer[i], i--, nBits -= 8);
        if (0 === e) e = 1 - eBias;
        else {
            if (e === eMax) return m ? NaN : s ? -Infinity : Infinity;
            m += pow(2, mLen), e -= eBias
        }
        return (s ? -1 : 1) * m * pow(2, e - mLen)
    }

    function unpackI32(bytes) {
        return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0]
    }

    function packI8(it) {
        return [255 & it]
    }

    function packI16(it) {
        return [255 & it, it >> 8 & 255]
    }

    function packI32(it) {
        return [255 & it, it >> 8 & 255, it >> 16 & 255, it >> 24 & 255]
    }

    function packF64(it) {
        return packIEEE754(it, 52, 8)
    }

    function packF32(it) {
        return packIEEE754(it, 23, 4)
    }

    function addGetter(C, key, internal) {
        dP(C[PROTOTYPE], key, {
            get: function() {
                return this[internal]
            }
        })
    }

    function get(view, bytes, index, isLittleEndian) {
        var intIndex = toIndex(+index);
        if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
        var store = view[$BUFFER]._b,
            start = intIndex + view[$OFFSET],
            pack = store.slice(start, start + bytes);
        return isLittleEndian ? pack : pack.reverse()
    }

    function set(view, bytes, index, conversion, value, isLittleEndian) {
        var intIndex = toIndex(+index);
        if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
        for (var store = view[$BUFFER]._b, start = intIndex + view[$OFFSET], pack = conversion(+value), i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1]
    }
    if ($typed.ABV) {
        if (!fails(function() {
                $ArrayBuffer(1)
            }) || !fails(function() {
                new $ArrayBuffer(-1)
            }) || fails(function() {
                return new $ArrayBuffer, new $ArrayBuffer(1.5), new $ArrayBuffer(NaN), "ArrayBuffer" != $ArrayBuffer.name
            })) {
            for (var key, ArrayBufferProto = ($ArrayBuffer = function(length) {
                    return anInstance(this, $ArrayBuffer), new BaseBuffer(toIndex(length))
                })[PROTOTYPE] = BaseBuffer[PROTOTYPE], keys = gOPN(BaseBuffer), j = 0; keys.length > j;)(key = keys[j++]) in $ArrayBuffer || hide($ArrayBuffer, key, BaseBuffer[key]);
            LIBRARY || (ArrayBufferProto.constructor = $ArrayBuffer)
        }
        var view = new $DataView(new $ArrayBuffer(2)),
            $setInt8 = $DataView[PROTOTYPE].setInt8;
        view.setInt8(0, 2147483648), view.setInt8(1, 2147483649), !view.getInt8(0) && view.getInt8(1) || redefineAll($DataView[PROTOTYPE], {
            setInt8: function(byteOffset, value) {
                $setInt8.call(this, byteOffset, value << 24 >> 24)
            },
            setUint8: function(byteOffset, value) {
                $setInt8.call(this, byteOffset, value << 24 >> 24)
            }
        }, !0)
    } else $ArrayBuffer = function(length) {
        anInstance(this, $ArrayBuffer, "ArrayBuffer");
        var byteLength = toIndex(length);
        this._b = arrayFill.call(new Array(byteLength), 0), this[$LENGTH] = byteLength
    }, $DataView = function(buffer, byteOffset, byteLength) {
        anInstance(this, $DataView, "DataView"), anInstance(buffer, $ArrayBuffer, "DataView");
        var bufferLength = buffer[$LENGTH],
            offset = toInteger(byteOffset);
        if (offset < 0 || offset > bufferLength) throw RangeError("Wrong offset!");
        if (offset + (byteLength = void 0 === byteLength ? bufferLength - offset : toLength(byteLength)) > bufferLength) throw RangeError("Wrong length!");
        this[$BUFFER] = buffer, this[$OFFSET] = offset, this[$LENGTH] = byteLength
    }, DESCRIPTORS && (addGetter($ArrayBuffer, "byteLength", "_l"), addGetter($DataView, "buffer", "_b"), addGetter($DataView, "byteLength", "_l"), addGetter($DataView, "byteOffset", "_o")), redefineAll($DataView[PROTOTYPE], {
        getInt8: function(byteOffset) {
            return get(this, 1, byteOffset)[0] << 24 >> 24
        },
        getUint8: function(byteOffset) {
            return get(this, 1, byteOffset)[0]
        },
        getInt16: function(byteOffset) {
            var bytes = get(this, 2, byteOffset, arguments[1]);
            return (bytes[1] << 8 | bytes[0]) << 16 >> 16
        },
        getUint16: function(byteOffset) {
            var bytes = get(this, 2, byteOffset, arguments[1]);
            return bytes[1] << 8 | bytes[0]
        },
        getInt32: function(byteOffset) {
            return unpackI32(get(this, 4, byteOffset, arguments[1]))
        },
        getUint32: function(byteOffset) {
            return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0
        },
        getFloat32: function(byteOffset) {
            return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4)
        },
        getFloat64: function(byteOffset) {
            return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8)
        },
        setInt8: function(byteOffset, value) {
            set(this, 1, byteOffset, packI8, value)
        },
        setUint8: function(byteOffset, value) {
            set(this, 1, byteOffset, packI8, value)
        },
        setInt16: function(byteOffset, value) {
            set(this, 2, byteOffset, packI16, value, arguments[2])
        },
        setUint16: function(byteOffset, value) {
            set(this, 2, byteOffset, packI16, value, arguments[2])
        },
        setInt32: function(byteOffset, value) {
            set(this, 4, byteOffset, packI32, value, arguments[2])
        },
        setUint32: function(byteOffset, value) {
            set(this, 4, byteOffset, packI32, value, arguments[2])
        },
        setFloat32: function(byteOffset, value) {
            set(this, 4, byteOffset, packF32, value, arguments[2])
        },
        setFloat64: function(byteOffset, value) {
            set(this, 8, byteOffset, packF64, value, arguments[2])
        }
    });
    setToStringTag($ArrayBuffer, "ArrayBuffer"), setToStringTag($DataView, "DataView"), hide($DataView[PROTOTYPE], $typed.VIEW, !0), exports.ArrayBuffer = $ArrayBuffer, exports.DataView = $DataView
}, function(module, exports, __webpack_require__) {
    module.exports = !__webpack_require__(7) && !__webpack_require__(3)(function() {
        return 7 != Object.defineProperty(__webpack_require__(70)("div"), "a", {
            get: function() {
                return 7
            }
        }).a
    })
}, function(module, exports, __webpack_require__) {
    exports.f = __webpack_require__(5)
}, function(module, exports, __webpack_require__) {
    var has = __webpack_require__(14),
        toIObject = __webpack_require__(15),
        arrayIndexOf = __webpack_require__(55)(!1),
        IE_PROTO = __webpack_require__(72)("IE_PROTO");
    module.exports = function(object, names) {
        var key, O = toIObject(object),
            i = 0,
            result = [];
        for (key in O) key != IE_PROTO && has(O, key) && result.push(key);
        for (; names.length > i;) has(O, key = names[i++]) && (~arrayIndexOf(result, key) || result.push(key));
        return result
    }
}, function(module, exports, __webpack_require__) {
    var dP = __webpack_require__(8),
        anObject = __webpack_require__(1),
        getKeys = __webpack_require__(34);
    module.exports = __webpack_require__(7) ? Object.defineProperties : function(O, Properties) {
        anObject(O);
        for (var P, keys = getKeys(Properties), length = keys.length, i = 0; length > i;) dP.f(O, P = keys[i++], Properties[P]);
        return O
    }
}, function(module, exports, __webpack_require__) {
    var toIObject = __webpack_require__(15),
        gOPN = __webpack_require__(37).f,
        toString = {}.toString,
        windowNames = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
    module.exports.f = function(it) {
        return windowNames && "[object Window]" == toString.call(it) ? function(it) {
            try {
                return gOPN(it)
            } catch (e) {
                return windowNames.slice()
            }
        }(it) : gOPN(toIObject(it))
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var DESCRIPTORS = __webpack_require__(7),
        getKeys = __webpack_require__(34),
        gOPS = __webpack_require__(56),
        pIE = __webpack_require__(50),
        toObject = __webpack_require__(9),
        IObject = __webpack_require__(49),
        $assign = Object.assign;
    module.exports = !$assign || __webpack_require__(3)(function() {
        var A = {},
            B = {},
            S = Symbol(),
            K = "abcdefghijklmnopqrst";
        return A[S] = 7, K.split("").forEach(function(k) {
            B[k] = k
        }), 7 != $assign({}, A)[S] || Object.keys($assign({}, B)).join("") != K
    }) ? function(target, source) {
        for (var T = toObject(target), aLen = arguments.length, index = 1, getSymbols = gOPS.f, isEnum = pIE.f; aLen > index;)
            for (var key, S = IObject(arguments[index++]), keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S), length = keys.length, j = 0; length > j;) key = keys[j++], DESCRIPTORS && !isEnum.call(S, key) || (T[key] = S[key]);
        return T
    } : $assign
}, function(module, exports) {
    module.exports = Object.is || function(x, y) {
        return x === y ? 0 !== x || 1 / x == 1 / y : x != x && y != y
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var aFunction = __webpack_require__(10),
        isObject = __webpack_require__(4),
        invoke = __webpack_require__(105),
        arraySlice = [].slice,
        factories = {};
    module.exports = Function.bind || function(that) {
        var fn = aFunction(this),
            partArgs = arraySlice.call(arguments, 1),
            bound = function() {
                var args = partArgs.concat(arraySlice.call(arguments));
                return this instanceof bound ? function(F, len, args) {
                    if (!(len in factories)) {
                        for (var n = [], i = 0; i < len; i++) n[i] = "a[" + i + "]";
                        factories[len] = Function("F,a", "return new F(" + n.join(",") + ")")
                    }
                    return factories[len](F, args)
                }(fn, args.length, args) : invoke(fn, args, that)
            };
        return isObject(fn.prototype) && (bound.prototype = fn.prototype), bound
    }
}, function(module, exports) {
    module.exports = function(fn, args, that) {
        var un = void 0 === that;
        switch (args.length) {
            case 0:
                return un ? fn() : fn.call(that);
            case 1:
                return un ? fn(args[0]) : fn.call(that, args[0]);
            case 2:
                return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
            case 3:
                return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
            case 4:
                return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3])
        }
        return fn.apply(that, args)
    }
}, function(module, exports, __webpack_require__) {
    var $parseInt = __webpack_require__(2).parseInt,
        $trim = __webpack_require__(46).trim,
        ws = __webpack_require__(76),
        hex = /^[-+]?0[xX]/;
    module.exports = 8 !== $parseInt(ws + "08") || 22 !== $parseInt(ws + "0x16") ? function(str, radix) {
        var string = $trim(String(str), 3);
        return $parseInt(string, radix >>> 0 || (hex.test(string) ? 16 : 10))
    } : $parseInt
}, function(module, exports, __webpack_require__) {
    var $parseFloat = __webpack_require__(2).parseFloat,
        $trim = __webpack_require__(46).trim;
    module.exports = 1 / $parseFloat(__webpack_require__(76) + "-0") != -1 / 0 ? function(str) {
        var string = $trim(String(str), 3),
            result = $parseFloat(string);
        return 0 === result && "-" == string.charAt(0) ? -0 : result
    } : $parseFloat
}, function(module, exports, __webpack_require__) {
    var cof = __webpack_require__(20);
    module.exports = function(it, msg) {
        if ("number" != typeof it && "Number" != cof(it)) throw TypeError(msg);
        return +it
    }
}, function(module, exports, __webpack_require__) {
    var isObject = __webpack_require__(4),
        floor = Math.floor;
    module.exports = function(it) {
        return !isObject(it) && isFinite(it) && floor(it) === it
    }
}, function(module, exports) {
    module.exports = Math.log1p || function(x) {
        return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x)
    }
}, function(module, exports, __webpack_require__) {
    var sign = __webpack_require__(79),
        pow = Math.pow,
        EPSILON = pow(2, -52),
        EPSILON32 = pow(2, -23),
        MAX32 = pow(2, 127) * (2 - EPSILON32),
        MIN32 = pow(2, -126);
    module.exports = Math.fround || function(x) {
        var a, result, $abs = Math.abs(x),
            $sign = sign(x);
        return $abs < MIN32 ? $sign * ($abs / MIN32 / EPSILON32 + 1 / EPSILON - 1 / EPSILON) * MIN32 * EPSILON32 : (result = (a = (1 + EPSILON32 / EPSILON) * $abs) - (a - $abs)) > MAX32 || result != result ? $sign * (1 / 0) : $sign * result
    }
}, function(module, exports, __webpack_require__) {
    var anObject = __webpack_require__(1);
    module.exports = function(iterator, fn, value, entries) {
        try {
            return entries ? fn(anObject(value)[0], value[1]) : fn(value)
        } catch (e) {
            var ret = iterator.return;
            throw void 0 !== ret && anObject(ret.call(iterator)), e
        }
    }
}, function(module, exports, __webpack_require__) {
    var aFunction = __webpack_require__(10),
        toObject = __webpack_require__(9),
        IObject = __webpack_require__(49),
        toLength = __webpack_require__(6);
    module.exports = function(that, callbackfn, aLen, memo, isRight) {
        aFunction(callbackfn);
        var O = toObject(that),
            self = IObject(O),
            length = toLength(O.length),
            index = isRight ? length - 1 : 0,
            i = isRight ? -1 : 1;
        if (aLen < 2)
            for (;;) {
                if (index in self) {
                    memo = self[index], index += i;
                    break
                }
                if (index += i, isRight ? index < 0 : length <= index) throw TypeError("Reduce of empty array with no initial value")
            }
        for (; isRight ? index >= 0 : length > index; index += i) index in self && (memo = callbackfn(memo, self[index], index, O));
        return memo
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var toObject = __webpack_require__(9),
        toAbsoluteIndex = __webpack_require__(35),
        toLength = __webpack_require__(6);
    module.exports = [].copyWithin || function(target, start) {
        var O = toObject(this),
            len = toLength(O.length),
            to = toAbsoluteIndex(target, len),
            from = toAbsoluteIndex(start, len),
            end = arguments.length > 2 ? arguments[2] : void 0,
            count = Math.min((void 0 === end ? len : toAbsoluteIndex(end, len)) - from, len - to),
            inc = 1;
        for (from < to && to < from + count && (inc = -1, from += count - 1, to += count - 1); count-- > 0;) from in O ? O[to] = O[from] : delete O[to], to += inc, from += inc;
        return O
    }
}, function(module, exports) {
    module.exports = function(done, value) {
        return {
            value: value,
            done: !!done
        }
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var regexpExec = __webpack_require__(91);
    __webpack_require__(0)({
        target: "RegExp",
        proto: !0,
        forced: regexpExec !== /./.exec
    }, {
        exec: regexpExec
    })
}, function(module, exports, __webpack_require__) {
    __webpack_require__(7) && "g" != /./g.flags && __webpack_require__(8).f(RegExp.prototype, "flags", {
        configurable: !0,
        get: __webpack_require__(51)
    })
}, function(module, exports) {
    module.exports = function(exec) {
        try {
            return {
                e: !1,
                v: exec()
            }
        } catch (e) {
            return {
                e: !0,
                v: e
            }
        }
    }
}, function(module, exports, __webpack_require__) {
    var anObject = __webpack_require__(1),
        isObject = __webpack_require__(4),
        newPromiseCapability = __webpack_require__(95);
    module.exports = function(C, x) {
        if (anObject(C), isObject(x) && x.constructor === C) return x;
        var promiseCapability = newPromiseCapability.f(C);
        return (0, promiseCapability.resolve)(x), promiseCapability.promise
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var strong = __webpack_require__(121),
        validate = __webpack_require__(42);
    module.exports = __webpack_require__(64)("Map", function(get) {
        return function() {
            return get(this, arguments.length > 0 ? arguments[0] : void 0)
        }
    }, {
        get: function(key) {
            var entry = strong.getEntry(validate(this, "Map"), key);
            return entry && entry.v
        },
        set: function(key, value) {
            return strong.def(validate(this, "Map"), 0 === key ? 0 : key, value)
        }
    }, strong, !0)
}, function(module, exports, __webpack_require__) {
    "use strict";
    var dP = __webpack_require__(8).f,
        create = __webpack_require__(36),
        redefineAll = __webpack_require__(41),
        ctx = __webpack_require__(19),
        anInstance = __webpack_require__(39),
        forOf = __webpack_require__(40),
        $iterDefine = __webpack_require__(81),
        step = __webpack_require__(115),
        setSpecies = __webpack_require__(38),
        DESCRIPTORS = __webpack_require__(7),
        fastKey = __webpack_require__(30).fastKey,
        validate = __webpack_require__(42),
        SIZE = DESCRIPTORS ? "_s" : "size",
        getEntry = function(that, key) {
            var entry, index = fastKey(key);
            if ("F" !== index) return that._i[index];
            for (entry = that._f; entry; entry = entry.n)
                if (entry.k == key) return entry
        };
    module.exports = {
        getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
            var C = wrapper(function(that, iterable) {
                anInstance(that, C, NAME, "_i"), that._t = NAME, that._i = create(null), that._f = void 0, that._l = void 0, that[SIZE] = 0, void 0 != iterable && forOf(iterable, IS_MAP, that[ADDER], that)
            });
            return redefineAll(C.prototype, {
                clear: function() {
                    for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) entry.r = !0, entry.p && (entry.p = entry.p.n = void 0), delete data[entry.i];
                    that._f = that._l = void 0, that[SIZE] = 0
                },
                delete: function(key) {
                    var that = validate(this, NAME),
                        entry = getEntry(that, key);
                    if (entry) {
                        var next = entry.n,
                            prev = entry.p;
                        delete that._i[entry.i], entry.r = !0, prev && (prev.n = next), next && (next.p = prev), that._f == entry && (that._f = next), that._l == entry && (that._l = prev), that[SIZE]--
                    }
                    return !!entry
                },
                forEach: function(callbackfn) {
                    validate(this, NAME);
                    for (var entry, f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : void 0, 3); entry = entry ? entry.n : this._f;)
                        for (f(entry.v, entry.k, this); entry && entry.r;) entry = entry.p
                },
                has: function(key) {
                    return !!getEntry(validate(this, NAME), key)
                }
            }), DESCRIPTORS && dP(C.prototype, "size", {
                get: function() {
                    return validate(this, NAME)[SIZE]
                }
            }), C
        },
        def: function(that, key, value) {
            var prev, index, entry = getEntry(that, key);
            return entry ? entry.v = value : (that._l = entry = {
                i: index = fastKey(key, !0),
                k: key,
                v: value,
                p: prev = that._l,
                n: void 0,
                r: !1
            }, that._f || (that._f = entry), prev && (prev.n = entry), that[SIZE]++, "F" !== index && (that._i[index] = entry)), that
        },
        getEntry: getEntry,
        setStrong: function(C, NAME, IS_MAP) {
            $iterDefine(C, NAME, function(iterated, kind) {
                this._t = validate(iterated, NAME), this._k = kind, this._l = void 0
            }, function() {
                for (var kind = this._k, entry = this._l; entry && entry.r;) entry = entry.p;
                return this._t && (this._l = entry = entry ? entry.n : this._t._f) ? step(0, "keys" == kind ? entry.k : "values" == kind ? entry.v : [entry.k, entry.v]) : (this._t = void 0, step(1))
            }, IS_MAP ? "entries" : "values", !IS_MAP, !0), setSpecies(NAME)
        }
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var strong = __webpack_require__(121),
        validate = __webpack_require__(42);
    module.exports = __webpack_require__(64)("Set", function(get) {
        return function() {
            return get(this, arguments.length > 0 ? arguments[0] : void 0)
        }
    }, {
        add: function(value) {
            return strong.def(validate(this, "Set"), value = 0 === value ? 0 : value, value)
        }
    }, strong)
}, function(module, exports, __webpack_require__) {
    "use strict";
    var InternalMap, global = __webpack_require__(2),
        each = __webpack_require__(26)(0),
        redefine = __webpack_require__(12),
        meta = __webpack_require__(30),
        assign = __webpack_require__(102),
        weak = __webpack_require__(124),
        isObject = __webpack_require__(4),
        validate = __webpack_require__(42),
        NATIVE_WEAK_MAP = __webpack_require__(42),
        IS_IE11 = !global.ActiveXObject && "ActiveXObject" in global,
        getWeak = meta.getWeak,
        isExtensible = Object.isExtensible,
        uncaughtFrozenStore = weak.ufstore,
        wrapper = function(get) {
            return function() {
                return get(this, arguments.length > 0 ? arguments[0] : void 0)
            }
        },
        methods = {
            get: function(key) {
                if (isObject(key)) {
                    var data = getWeak(key);
                    return !0 === data ? uncaughtFrozenStore(validate(this, "WeakMap")).get(key) : data ? data[this._i] : void 0
                }
            },
            set: function(key, value) {
                return weak.def(validate(this, "WeakMap"), key, value)
            }
        },
        $WeakMap = module.exports = __webpack_require__(64)("WeakMap", wrapper, methods, weak, !0, !0);
    NATIVE_WEAK_MAP && IS_IE11 && (assign((InternalMap = weak.getConstructor(wrapper, "WeakMap")).prototype, methods), meta.NEED = !0, each(["delete", "has", "get", "set"], function(key) {
        var proto = $WeakMap.prototype,
            method = proto[key];
        redefine(proto, key, function(a, b) {
            if (isObject(a) && !isExtensible(a)) {
                this._f || (this._f = new InternalMap);
                var result = this._f[key](a, b);
                return "set" == key ? this : result
            }
            return method.call(this, a, b)
        })
    }))
}, function(module, exports, __webpack_require__) {
    "use strict";
    var redefineAll = __webpack_require__(41),
        getWeak = __webpack_require__(30).getWeak,
        anObject = __webpack_require__(1),
        isObject = __webpack_require__(4),
        anInstance = __webpack_require__(39),
        forOf = __webpack_require__(40),
        createArrayMethod = __webpack_require__(26),
        $has = __webpack_require__(14),
        validate = __webpack_require__(42),
        arrayFind = createArrayMethod(5),
        arrayFindIndex = createArrayMethod(6),
        id = 0,
        uncaughtFrozenStore = function(that) {
            return that._l || (that._l = new UncaughtFrozenStore)
        },
        UncaughtFrozenStore = function() {
            this.a = []
        },
        findUncaughtFrozen = function(store, key) {
            return arrayFind(store.a, function(it) {
                return it[0] === key
            })
        };
    UncaughtFrozenStore.prototype = {
        get: function(key) {
            var entry = findUncaughtFrozen(this, key);
            if (entry) return entry[1]
        },
        has: function(key) {
            return !!findUncaughtFrozen(this, key)
        },
        set: function(key, value) {
            var entry = findUncaughtFrozen(this, key);
            entry ? entry[1] = value : this.a.push([key, value])
        },
        delete: function(key) {
            var index = arrayFindIndex(this.a, function(it) {
                return it[0] === key
            });
            return ~index && this.a.splice(index, 1), !!~index
        }
    }, module.exports = {
        getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
            var C = wrapper(function(that, iterable) {
                anInstance(that, C, NAME, "_i"), that._t = NAME, that._i = id++, that._l = void 0, void 0 != iterable && forOf(iterable, IS_MAP, that[ADDER], that)
            });
            return redefineAll(C.prototype, {
                delete: function(key) {
                    if (!isObject(key)) return !1;
                    var data = getWeak(key);
                    return !0 === data ? uncaughtFrozenStore(validate(this, NAME)).delete(key) : data && $has(data, this._i) && delete data[this._i]
                },
                has: function(key) {
                    if (!isObject(key)) return !1;
                    var data = getWeak(key);
                    return !0 === data ? uncaughtFrozenStore(validate(this, NAME)).has(key) : data && $has(data, this._i)
                }
            }), C
        },
        def: function(that, key, value) {
            var data = getWeak(anObject(key), !0);
            return !0 === data ? uncaughtFrozenStore(that).set(key, value) : data[that._i] = value, that
        },
        ufstore: uncaughtFrozenStore
    }
}, function(module, exports, __webpack_require__) {
    var toInteger = __webpack_require__(21),
        toLength = __webpack_require__(6);
    module.exports = function(it) {
        if (void 0 === it) return 0;
        var number = toInteger(it),
            length = toLength(number);
        if (number !== length) throw RangeError("Wrong length!");
        return length
    }
}, function(module, exports, __webpack_require__) {
    var gOPN = __webpack_require__(37),
        gOPS = __webpack_require__(56),
        anObject = __webpack_require__(1),
        Reflect = __webpack_require__(2).Reflect;
    module.exports = Reflect && Reflect.ownKeys || function(it) {
        var keys = gOPN.f(anObject(it)),
            getSymbols = gOPS.f;
        return getSymbols ? keys.concat(getSymbols(it)) : keys
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var isArray = __webpack_require__(57),
        isObject = __webpack_require__(4),
        toLength = __webpack_require__(6),
        ctx = __webpack_require__(19),
        IS_CONCAT_SPREADABLE = __webpack_require__(5)("isConcatSpreadable");
    module.exports = function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
        for (var element, spreadable, targetIndex = start, sourceIndex = 0, mapFn = !!mapper && ctx(mapper, thisArg, 3); sourceIndex < sourceLen;) {
            if (sourceIndex in source) {
                if (element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex], spreadable = !1, isObject(element) && (spreadable = void 0 !== (spreadable = element[IS_CONCAT_SPREADABLE]) ? !!spreadable : isArray(element)), spreadable && depth > 0) targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
                else {
                    if (targetIndex >= 9007199254740991) throw TypeError();
                    target[targetIndex] = element
                }
                targetIndex++
            }
            sourceIndex++
        }
        return targetIndex
    }
}, function(module, exports, __webpack_require__) {
    var toLength = __webpack_require__(6),
        repeat = __webpack_require__(78),
        defined = __webpack_require__(24);
    module.exports = function(that, maxLength, fillString, left) {
        var S = String(defined(that)),
            stringLength = S.length,
            fillStr = void 0 === fillString ? " " : String(fillString),
            intMaxLength = toLength(maxLength);
        if (intMaxLength <= stringLength || "" == fillStr) return S;
        var fillLen = intMaxLength - stringLength,
            stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
        return stringFiller.length > fillLen && (stringFiller = stringFiller.slice(0, fillLen)), left ? stringFiller + S : S + stringFiller
    }
}, function(module, exports, __webpack_require__) {
    var DESCRIPTORS = __webpack_require__(7),
        getKeys = __webpack_require__(34),
        toIObject = __webpack_require__(15),
        isEnum = __webpack_require__(50).f;
    module.exports = function(isEntries) {
        return function(it) {
            for (var key, O = toIObject(it), keys = getKeys(O), length = keys.length, i = 0, result = []; length > i;) key = keys[i++], DESCRIPTORS && !isEnum.call(O, key) || result.push(isEntries ? [key, O[key]] : O[key]);
            return result
        }
    }
}, function(module, exports, __webpack_require__) {
    var classof = __webpack_require__(45),
        from = __webpack_require__(131);
    module.exports = function(NAME) {
        return function() {
            if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
            return from(this)
        }
    }
}, function(module, exports, __webpack_require__) {
    var forOf = __webpack_require__(40);
    module.exports = function(iter, ITERATOR) {
        var result = [];
        return forOf(iter, !1, result.push, result, ITERATOR), result
    }
}, function(module, exports) {
    module.exports = Math.scale || function(x, inLow, inHigh, outLow, outHigh) {
        return 0 === arguments.length || x != x || inLow != inLow || inHigh != inHigh || outLow != outLow || outHigh != outHigh ? NaN : x === 1 / 0 || x === -1 / 0 ? x : (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow
    }
}, function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__, root, factory;
    root = this, factory = function(root, Backbone, _) {
        "use strict";
        var previousMarionette = root.Marionette,
            previousMn = root.Mn,
            Marionette = Backbone.Marionette = {};
        Marionette.VERSION = "2.4.4", Marionette.noConflict = function() {
            return root.Marionette = previousMarionette, root.Mn = previousMn, this
        }, Marionette.Deferred = Backbone.$.Deferred, Marionette.FEATURES = {}, Marionette.isEnabled = function(name) {
            return !!Marionette.FEATURES[name]
        }, Marionette.extend = Backbone.Model.extend, Marionette.isNodeAttached = function(el) {
            return Backbone.$.contains(document.documentElement, el)
        }, Marionette.mergeOptions = function(options, keys) {
            options && _.extend(this, _.pick(options, keys))
        }, Marionette.getOption = function(target, optionName) {
            if (target && optionName) return target.options && void 0 !== target.options[optionName] ? target.options[optionName] : target[optionName]
        }, Marionette.proxyGetOption = function(optionName) {
            return Marionette.getOption(this, optionName)
        }, Marionette._getValue = function(value, context, params) {
            return _.isFunction(value) && (value = params ? value.apply(context, params) : value.call(context)), value
        }, Marionette.normalizeMethods = function(hash) {
            return _.reduce(hash, function(normalizedHash, method, name) {
                return _.isFunction(method) || (method = this[method]), method && (normalizedHash[name] = method), normalizedHash
            }, {}, this)
        }, Marionette.normalizeUIString = function(uiString, ui) {
            return uiString.replace(/@ui\.[a-zA-Z_$0-9]*/g, function(r) {
                return ui[r.slice(4)]
            })
        }, Marionette.normalizeUIKeys = function(hash, ui) {
            return _.reduce(hash, function(memo, val, key) {
                return memo[Marionette.normalizeUIString(key, ui)] = val, memo
            }, {})
        }, Marionette.normalizeUIValues = function(hash, ui, properties) {
            return _.each(hash, function(val, key) {
                _.isString(val) ? hash[key] = Marionette.normalizeUIString(val, ui) : _.isObject(val) && _.isArray(properties) && (_.extend(val, Marionette.normalizeUIValues(_.pick(val, properties), ui)), _.each(properties, function(property) {
                    var propertyVal = val[property];
                    _.isString(propertyVal) && (val[property] = Marionette.normalizeUIString(propertyVal, ui))
                }))
            }), hash
        }, Marionette.actAsCollection = function(object, listProperty) {
            _.each(["forEach", "each", "map", "find", "detect", "filter", "select", "reject", "every", "all", "some", "any", "include", "contains", "invoke", "toArray", "first", "initial", "rest", "last", "without", "isEmpty", "pluck"], function(method) {
                object[method] = function() {
                    var args = [_.values(_.result(this, listProperty))].concat(_.toArray(arguments));
                    return _[method].apply(_, args)
                }
            })
        };
        var deprecate = Marionette.deprecate = function(message, test) {
            _.isObject(message) && (message = message.prev + " is going to be removed in the future. Please use " + message.next + " instead." + (message.url ? " See: " + message.url : "")), void 0 !== test && test || deprecate._cache[message] || (deprecate._warn("Deprecation warning: " + message), deprecate._cache[message] = !0)
        };
        deprecate._warn = "undefined" != typeof console && (console.warn || console.log) || function() {}, deprecate._cache = {}, Marionette._triggerMethod = function() {
                var splitter = /(^|:)(\w)/gi;

                function getEventName(match, prefix, eventName) {
                    return eventName.toUpperCase()
                }
                return function(context, event, args) {
                    var noEventArg = arguments.length < 3;
                    noEventArg && (event = (args = event)[0]);
                    var result, method = context["on" + event.replace(splitter, getEventName)];
                    return _.isFunction(method) && (result = method.apply(context, noEventArg ? _.rest(args) : args)), _.isFunction(context.trigger) && (noEventArg + args.length > 1 ? context.trigger.apply(context, noEventArg ? args : [event].concat(_.drop(args, 0))) : context.trigger(event)), result
                }
            }(), Marionette.triggerMethod = function(event) {
                return Marionette._triggerMethod(this, arguments)
            }, Marionette.triggerMethodOn = function(context) {
                return (_.isFunction(context.triggerMethod) ? context.triggerMethod : Marionette.triggerMethod).apply(context, _.rest(arguments))
            }, Marionette.MonitorDOMRefresh = function(view) {
                function triggerDOMRefresh() {
                    view._isShown && view._isRendered && Marionette.isNodeAttached(view.el) && Marionette.triggerMethodOn(view, "dom:refresh", view)
                }
                view._isDomRefreshMonitored || (view._isDomRefreshMonitored = !0, view.on({
                    show: function() {
                        view._isShown = !0, triggerDOMRefresh()
                    },
                    render: function() {
                        view._isRendered = !0, triggerDOMRefresh()
                    }
                }))
            },
            function(Marionette) {
                function bindFromStrings(target, entity, evt, methods) {
                    var methodNames = methods.split(/\s+/);
                    _.each(methodNames, function(methodName) {
                        var method = target[methodName];
                        if (!method) throw new Marionette.Error('Method "' + methodName + '" was configured as an event handler, but does not exist.');
                        target.listenTo(entity, evt, method)
                    })
                }

                function bindToFunction(target, entity, evt, method) {
                    target.listenTo(entity, evt, method)
                }

                function unbindFromStrings(target, entity, evt, methods) {
                    var methodNames = methods.split(/\s+/);
                    _.each(methodNames, function(methodName) {
                        var method = target[methodName];
                        target.stopListening(entity, evt, method)
                    })
                }

                function unbindToFunction(target, entity, evt, method) {
                    target.stopListening(entity, evt, method)
                }

                function iterateEvents(target, entity, bindings, functionCallback, stringCallback) {
                    if (entity && bindings) {
                        if (!_.isObject(bindings)) throw new Marionette.Error({
                            message: "Bindings must be an object or function.",
                            url: "marionette.functions.html#marionettebindentityevents"
                        });
                        bindings = Marionette._getValue(bindings, target), _.each(bindings, function(methods, evt) {
                            _.isFunction(methods) ? functionCallback(target, entity, evt, methods) : stringCallback(target, entity, evt, methods)
                        })
                    }
                }
                Marionette.bindEntityEvents = function(target, entity, bindings) {
                    iterateEvents(target, entity, bindings, bindToFunction, bindFromStrings)
                }, Marionette.unbindEntityEvents = function(target, entity, bindings) {
                    iterateEvents(target, entity, bindings, unbindToFunction, unbindFromStrings)
                }, Marionette.proxyBindEntityEvents = function(entity, bindings) {
                    return Marionette.bindEntityEvents(this, entity, bindings)
                }, Marionette.proxyUnbindEntityEvents = function(entity, bindings) {
                    return Marionette.unbindEntityEvents(this, entity, bindings)
                }
            }(Marionette);
        var errorProps = ["description", "fileName", "lineNumber", "name", "message", "number"];
        return Marionette.Error = Marionette.extend.call(Error, {
            urlRoot: "http://marionettejs.com/docs/v" + Marionette.VERSION + "/",
            constructor: function(message, options) {
                _.isObject(message) ? message = (options = message).message : options || (options = {});
                var error = Error.call(this, message);
                _.extend(this, _.pick(error, errorProps), _.pick(options, errorProps)), this.captureStackTrace(), options.url && (this.url = this.urlRoot + options.url)
            },
            captureStackTrace: function() {
                Error.captureStackTrace && Error.captureStackTrace(this, Marionette.Error)
            },
            toString: function() {
                return this.name + ": " + this.message + (this.url ? " See: " + this.url : "")
            }
        }), Marionette.Error.extend = Marionette.extend, Marionette.Callbacks = function() {
            this._deferred = Marionette.Deferred(), this._callbacks = []
        }, _.extend(Marionette.Callbacks.prototype, {
            add: function(callback, contextOverride) {
                var promise = _.result(this._deferred, "promise");
                this._callbacks.push({
                    cb: callback,
                    ctx: contextOverride
                }), promise.then(function(args) {
                    contextOverride && (args.context = contextOverride), callback.call(args.context, args.options)
                })
            },
            run: function(options, context) {
                this._deferred.resolve({
                    options: options,
                    context: context
                })
            },
            reset: function() {
                var callbacks = this._callbacks;
                this._deferred = Marionette.Deferred(), this._callbacks = [], _.each(callbacks, function(cb) {
                    this.add(cb.cb, cb.ctx)
                }, this)
            }
        }), Marionette.Controller = function(options) {
            this.options = options || {}, _.isFunction(this.initialize) && this.initialize(this.options)
        }, Marionette.Controller.extend = Marionette.extend, _.extend(Marionette.Controller.prototype, Backbone.Events, {
            destroy: function() {
                return Marionette._triggerMethod(this, "before:destroy", arguments), Marionette._triggerMethod(this, "destroy", arguments), this.stopListening(), this.off(), this
            },
            triggerMethod: Marionette.triggerMethod,
            mergeOptions: Marionette.mergeOptions,
            getOption: Marionette.proxyGetOption
        }), Marionette.Object = function(options) {
            this.options = _.extend({}, _.result(this, "options"), options), this.initialize.apply(this, arguments)
        }, Marionette.Object.extend = Marionette.extend, _.extend(Marionette.Object.prototype, Backbone.Events, {
            initialize: function() {},
            destroy: function(options) {
                return options = options || {}, this.triggerMethod("before:destroy", options), this.triggerMethod("destroy", options), this.stopListening(), this
            },
            triggerMethod: Marionette.triggerMethod,
            mergeOptions: Marionette.mergeOptions,
            getOption: Marionette.proxyGetOption,
            bindEntityEvents: Marionette.proxyBindEntityEvents,
            unbindEntityEvents: Marionette.proxyUnbindEntityEvents
        }), Marionette.Region = Marionette.Object.extend({
            constructor: function(options) {
                if (this.options = options || {}, this.el = this.getOption("el"), this.el = this.el instanceof Backbone.$ ? this.el[0] : this.el, !this.el) throw new Marionette.Error({
                    name: "NoElError",
                    message: 'An "el" must be specified for a region.'
                });
                this.$el = this.getEl(this.el), Marionette.Object.call(this, options)
            },
            show: function(view, options) {
                if (this._ensureElement()) {
                    this._ensureViewIsIntact(view), Marionette.MonitorDOMRefresh(view);
                    var showOptions = options || {},
                        isDifferentView = view !== this.currentView,
                        preventDestroy = !!showOptions.preventDestroy,
                        forceShow = !!showOptions.forceShow,
                        isChangingView = !!this.currentView,
                        _shouldDestroyView = isDifferentView && !preventDestroy,
                        _shouldShowView = isDifferentView || forceShow;
                    if (isChangingView && this.triggerMethod("before:swapOut", this.currentView, this, options), this.currentView && delete this.currentView._parent, _shouldDestroyView ? this.empty() : isChangingView && _shouldShowView && this.currentView.off("destroy", this.empty, this), _shouldShowView) {
                        view.once("destroy", this.empty, this), view._parent = this, this._renderView(view), isChangingView && this.triggerMethod("before:swap", view, this, options), this.triggerMethod("before:show", view, this, options), Marionette.triggerMethodOn(view, "before:show", view, this, options), isChangingView && this.triggerMethod("swapOut", this.currentView, this, options);
                        var attachedRegion = Marionette.isNodeAttached(this.el),
                            displayedViews = [],
                            attachOptions = _.extend({
                                triggerBeforeAttach: this.triggerBeforeAttach,
                                triggerAttach: this.triggerAttach
                            }, showOptions);
                        return attachedRegion && attachOptions.triggerBeforeAttach && (displayedViews = this._displayedViews(view), this._triggerAttach(displayedViews, "before:")), this.attachHtml(view), this.currentView = view, attachedRegion && attachOptions.triggerAttach && (displayedViews = this._displayedViews(view), this._triggerAttach(displayedViews)), isChangingView && this.triggerMethod("swap", view, this, options), this.triggerMethod("show", view, this, options), Marionette.triggerMethodOn(view, "show", view, this, options), this
                    }
                    return this
                }
            },
            triggerBeforeAttach: !0,
            triggerAttach: !0,
            _triggerAttach: function(views, prefix) {
                var eventName = (prefix || "") + "attach";
                _.each(views, function(view) {
                    Marionette.triggerMethodOn(view, eventName, view, this)
                }, this)
            },
            _displayedViews: function(view) {
                return _.union([view], _.result(view, "_getNestedViews") || [])
            },
            _renderView: function(view) {
                view.supportsRenderLifecycle || Marionette.triggerMethodOn(view, "before:render", view), view.render(), view.supportsRenderLifecycle || Marionette.triggerMethodOn(view, "render", view)
            },
            _ensureElement: function() {
                if (_.isObject(this.el) || (this.$el = this.getEl(this.el), this.el = this.$el[0]), !this.$el || 0 === this.$el.length) {
                    if (this.getOption("allowMissingEl")) return !1;
                    throw new Marionette.Error('An "el" ' + this.$el.selector + " must exist in DOM")
                }
                return !0
            },
            _ensureViewIsIntact: function(view) {
                if (!view) throw new Marionette.Error({
                    name: "ViewNotValid",
                    message: "The view passed is undefined and therefore invalid. You must pass a view instance to show."
                });
                if (view.isDestroyed) throw new Marionette.Error({
                    name: "ViewDestroyedError",
                    message: 'View (cid: "' + view.cid + '") has already been destroyed and cannot be used.'
                })
            },
            getEl: function(el) {
                return Backbone.$(el, Marionette._getValue(this.options.parentEl, this))
            },
            attachHtml: function(view) {
                this.$el.contents().detach(), this.el.appendChild(view.el)
            },
            empty: function(options) {
                var view = this.currentView,
                    preventDestroy = !!(options || {}).preventDestroy;
                return view ? (view.off("destroy", this.empty, this), this.triggerMethod("before:empty", view), preventDestroy || this._destroyView(), this.triggerMethod("empty", view), delete this.currentView, preventDestroy && this.$el.contents().detach(), this) : this
            },
            _destroyView: function() {
                var view = this.currentView;
                view.isDestroyed || (view.supportsDestroyLifecycle || Marionette.triggerMethodOn(view, "before:destroy", view), view.destroy ? view.destroy() : (view.remove(), view.isDestroyed = !0), view.supportsDestroyLifecycle || Marionette.triggerMethodOn(view, "destroy", view))
            },
            attachView: function(view) {
                return this.currentView && delete this.currentView._parent, view._parent = this, this.currentView = view, this
            },
            hasView: function() {
                return !!this.currentView
            },
            reset: function() {
                return this.empty(), this.$el && (this.el = this.$el.selector), delete this.$el, this
            }
        }, {
            buildRegion: function(regionConfig, DefaultRegionClass) {
                if (_.isString(regionConfig)) return this._buildRegionFromSelector(regionConfig, DefaultRegionClass);
                if (regionConfig.selector || regionConfig.el || regionConfig.regionClass) return this._buildRegionFromObject(regionConfig, DefaultRegionClass);
                if (_.isFunction(regionConfig)) return this._buildRegionFromRegionClass(regionConfig);
                throw new Marionette.Error({
                    message: "Improper region configuration type.",
                    url: "marionette.region.html#region-configuration-types"
                })
            },
            _buildRegionFromSelector: function(selector, DefaultRegionClass) {
                return new DefaultRegionClass({
                    el: selector
                })
            },
            _buildRegionFromObject: function(regionConfig, DefaultRegionClass) {
                var RegionClass = regionConfig.regionClass || DefaultRegionClass,
                    options = _.omit(regionConfig, "selector", "regionClass");
                return regionConfig.selector && !options.el && (options.el = regionConfig.selector), new RegionClass(options)
            },
            _buildRegionFromRegionClass: function(RegionClass) {
                return new RegionClass
            }
        }), Marionette.RegionManager = Marionette.Controller.extend({
            constructor: function(options) {
                this._regions = {}, this.length = 0, Marionette.Controller.call(this, options), this.addRegions(this.getOption("regions"))
            },
            addRegions: function(regionDefinitions, defaults) {
                return regionDefinitions = Marionette._getValue(regionDefinitions, this, arguments), _.reduce(regionDefinitions, function(regions, definition, name) {
                    return _.isString(definition) && (definition = {
                        selector: definition
                    }), definition.selector && (definition = _.defaults({}, definition, defaults)), regions[name] = this.addRegion(name, definition), regions
                }, {}, this)
            },
            addRegion: function(name, definition) {
                var region;
                return region = definition instanceof Marionette.Region ? definition : Marionette.Region.buildRegion(definition, Marionette.Region), this.triggerMethod("before:add:region", name, region), region._parent = this, this._store(name, region), this.triggerMethod("add:region", name, region), region
            },
            get: function(name) {
                return this._regions[name]
            },
            getRegions: function() {
                return _.clone(this._regions)
            },
            removeRegion: function(name) {
                var region = this._regions[name];
                return this._remove(name, region), region
            },
            removeRegions: function() {
                var regions = this.getRegions();
                return _.each(this._regions, function(region, name) {
                    this._remove(name, region)
                }, this), regions
            },
            emptyRegions: function() {
                var regions = this.getRegions();
                return _.invoke(regions, "empty"), regions
            },
            destroy: function() {
                return this.removeRegions(), Marionette.Controller.prototype.destroy.apply(this, arguments)
            },
            _store: function(name, region) {
                this._regions[name] || this.length++, this._regions[name] = region
            },
            _remove: function(name, region) {
                this.triggerMethod("before:remove:region", name, region), region.empty(), region.stopListening(), delete region._parent, delete this._regions[name], this.length--, this.triggerMethod("remove:region", name, region)
            }
        }), Marionette.actAsCollection(Marionette.RegionManager.prototype, "_regions"), Marionette.TemplateCache = function(templateId) {
            this.templateId = templateId
        }, _.extend(Marionette.TemplateCache, {
            templateCaches: {},
            get: function(templateId, options) {
                var cachedTemplate = this.templateCaches[templateId];
                return cachedTemplate || (cachedTemplate = new Marionette.TemplateCache(templateId), this.templateCaches[templateId] = cachedTemplate), cachedTemplate.load(options)
            },
            clear: function() {
                var i, args = _.toArray(arguments),
                    length = args.length;
                if (length > 0)
                    for (i = 0; i < length; i++) delete this.templateCaches[args[i]];
                else this.templateCaches = {}
            }
        }), _.extend(Marionette.TemplateCache.prototype, {
            load: function(options) {
                if (this.compiledTemplate) return this.compiledTemplate;
                var template = this.loadTemplate(this.templateId, options);
                return this.compiledTemplate = this.compileTemplate(template, options), this.compiledTemplate
            },
            loadTemplate: function(templateId, options) {
                var $template = Backbone.$(templateId);
                if (!$template.length) throw new Marionette.Error({
                    name: "NoTemplateError",
                    message: 'Could not find template: "' + templateId + '"'
                });
                return $template.html()
            },
            compileTemplate: function(rawTemplate, options) {
                return _.template(rawTemplate, options)
            }
        }), Marionette.Renderer = {
            render: function(template, data) {
                if (!template) throw new Marionette.Error({
                    name: "TemplateNotFoundError",
                    message: "Cannot render the template since its false, null or undefined."
                });
                return (_.isFunction(template) ? template : Marionette.TemplateCache.get(template))(data)
            }
        }, Marionette.View = Backbone.View.extend({
            isDestroyed: !1,
            supportsRenderLifecycle: !0,
            supportsDestroyLifecycle: !0,
            constructor: function(options) {
                this.render = _.bind(this.render, this), options = Marionette._getValue(options, this), this.options = _.extend({}, _.result(this, "options"), options), this._behaviors = Marionette.Behaviors(this), Backbone.View.call(this, this.options), Marionette.MonitorDOMRefresh(this)
            },
            getTemplate: function() {
                return this.getOption("template")
            },
            serializeModel: function(model) {
                return model.toJSON.apply(model, _.rest(arguments))
            },
            mixinTemplateHelpers: function(target) {
                target = target || {};
                var templateHelpers = this.getOption("templateHelpers");
                return templateHelpers = Marionette._getValue(templateHelpers, this), _.extend(target, templateHelpers)
            },
            normalizeUIKeys: function(hash) {
                var uiBindings = _.result(this, "_uiBindings");
                return Marionette.normalizeUIKeys(hash, uiBindings || _.result(this, "ui"))
            },
            normalizeUIValues: function(hash, properties) {
                var ui = _.result(this, "ui"),
                    uiBindings = _.result(this, "_uiBindings");
                return Marionette.normalizeUIValues(hash, uiBindings || ui, properties)
            },
            configureTriggers: function() {
                if (this.triggers) {
                    var triggers = this.normalizeUIKeys(_.result(this, "triggers"));
                    return _.reduce(triggers, function(events, value, key) {
                        return events[key] = this._buildViewTrigger(value), events
                    }, {}, this)
                }
            },
            delegateEvents: function(events) {
                return this._delegateDOMEvents(events), this.bindEntityEvents(this.model, this.getOption("modelEvents")), this.bindEntityEvents(this.collection, this.getOption("collectionEvents")), _.each(this._behaviors, function(behavior) {
                    behavior.bindEntityEvents(this.model, behavior.getOption("modelEvents")), behavior.bindEntityEvents(this.collection, behavior.getOption("collectionEvents"))
                }, this), this
            },
            _delegateDOMEvents: function(eventsArg) {
                var events = Marionette._getValue(eventsArg || this.events, this);
                events = this.normalizeUIKeys(events), _.isUndefined(eventsArg) && (this.events = events);
                var combinedEvents = {},
                    behaviorEvents = _.result(this, "behaviorEvents") || {},
                    triggers = this.configureTriggers(),
                    behaviorTriggers = _.result(this, "behaviorTriggers") || {};
                _.extend(combinedEvents, behaviorEvents, events, triggers, behaviorTriggers), Backbone.View.prototype.delegateEvents.call(this, combinedEvents)
            },
            undelegateEvents: function() {
                return Backbone.View.prototype.undelegateEvents.apply(this, arguments), this.unbindEntityEvents(this.model, this.getOption("modelEvents")), this.unbindEntityEvents(this.collection, this.getOption("collectionEvents")), _.each(this._behaviors, function(behavior) {
                    behavior.unbindEntityEvents(this.model, behavior.getOption("modelEvents")), behavior.unbindEntityEvents(this.collection, behavior.getOption("collectionEvents"))
                }, this), this
            },
            _ensureViewIsIntact: function() {
                if (this.isDestroyed) throw new Marionette.Error({
                    name: "ViewDestroyedError",
                    message: 'View (cid: "' + this.cid + '") has already been destroyed and cannot be used.'
                })
            },
            destroy: function() {
                if (this.isDestroyed) return this;
                var args = _.toArray(arguments);
                return this.triggerMethod.apply(this, ["before:destroy"].concat(args)), this.isDestroyed = !0, this.triggerMethod.apply(this, ["destroy"].concat(args)), this.unbindUIElements(), this.isRendered = !1, this.remove(), _.invoke(this._behaviors, "destroy", args), this
            },
            bindUIElements: function() {
                this._bindUIElements(), _.invoke(this._behaviors, this._bindUIElements)
            },
            _bindUIElements: function() {
                if (this.ui) {
                    this._uiBindings || (this._uiBindings = this.ui);
                    var bindings = _.result(this, "_uiBindings");
                    this.ui = {}, _.each(bindings, function(selector, key) {
                        this.ui[key] = this.$(selector)
                    }, this)
                }
            },
            unbindUIElements: function() {
                this._unbindUIElements(), _.invoke(this._behaviors, this._unbindUIElements)
            },
            _unbindUIElements: function() {
                this.ui && this._uiBindings && (_.each(this.ui, function($el, name) {
                    delete this.ui[name]
                }, this), this.ui = this._uiBindings, delete this._uiBindings)
            },
            _buildViewTrigger: function(triggerDef) {
                var options = _.defaults({}, triggerDef, {
                        preventDefault: !0,
                        stopPropagation: !0
                    }),
                    eventName = _.isObject(triggerDef) ? options.event : triggerDef;
                return function(e) {
                    e && (e.preventDefault && options.preventDefault && e.preventDefault(), e.stopPropagation && options.stopPropagation && e.stopPropagation());
                    var args = {
                        view: this,
                        model: this.model,
                        collection: this.collection
                    };
                    this.triggerMethod(eventName, args)
                }
            },
            setElement: function() {
                var ret = Backbone.View.prototype.setElement.apply(this, arguments);
                return _.invoke(this._behaviors, "proxyViewProperties", this), ret
            },
            triggerMethod: function() {
                var ret = Marionette._triggerMethod(this, arguments);
                return this._triggerEventOnBehaviors(arguments), this._triggerEventOnParentLayout(arguments[0], _.rest(arguments)), ret
            },
            _triggerEventOnBehaviors: function(args) {
                for (var triggerMethod = Marionette._triggerMethod, behaviors = this._behaviors, i = 0, length = behaviors && behaviors.length; i < length; i++) triggerMethod(behaviors[i], args)
            },
            _triggerEventOnParentLayout: function(eventName, args) {
                var layoutView = this._parentLayoutView();
                if (layoutView) {
                    var prefixedEventName = Marionette.getOption(layoutView, "childViewEventPrefix") + ":" + eventName,
                        callArgs = [this].concat(args);
                    Marionette._triggerMethod(layoutView, prefixedEventName, callArgs);
                    var childEvents = Marionette.getOption(layoutView, "childEvents");
                    childEvents = Marionette._getValue(childEvents, layoutView);
                    var normalizedChildEvents = layoutView.normalizeMethods(childEvents);
                    normalizedChildEvents && _.isFunction(normalizedChildEvents[eventName]) && normalizedChildEvents[eventName].apply(layoutView, callArgs)
                }
            },
            _getImmediateChildren: function() {
                return []
            },
            _getNestedViews: function() {
                var children = this._getImmediateChildren();
                return children.length ? _.reduce(children, function(memo, view) {
                    return view._getNestedViews ? memo.concat(view._getNestedViews()) : memo
                }, children) : children
            },
            _parentLayoutView: function() {
                for (var parent = this._parent; parent;) {
                    if (parent instanceof Marionette.LayoutView) return parent;
                    parent = parent._parent
                }
            },
            normalizeMethods: Marionette.normalizeMethods,
            mergeOptions: Marionette.mergeOptions,
            getOption: Marionette.proxyGetOption,
            bindEntityEvents: Marionette.proxyBindEntityEvents,
            unbindEntityEvents: Marionette.proxyUnbindEntityEvents
        }), Marionette.ItemView = Marionette.View.extend({
            constructor: function() {
                Marionette.View.apply(this, arguments)
            },
            serializeData: function() {
                if (!this.model && !this.collection) return {};
                var args = [this.model || this.collection];
                return arguments.length && args.push.apply(args, arguments), this.model ? this.serializeModel.apply(this, args) : {
                    items: this.serializeCollection.apply(this, args)
                }
            },
            serializeCollection: function(collection) {
                return collection.toJSON.apply(collection, _.rest(arguments))
            },
            render: function() {
                return this._ensureViewIsIntact(), this.triggerMethod("before:render", this), this._renderTemplate(), this.isRendered = !0, this.bindUIElements(), this.triggerMethod("render", this), this
            },
            _renderTemplate: function() {
                var template = this.getTemplate();
                if (!1 !== template) {
                    if (!template) throw new Marionette.Error({
                        name: "UndefinedTemplateError",
                        message: "Cannot render the template since it is null or undefined."
                    });
                    var data = this.mixinTemplateHelpers(this.serializeData()),
                        html = Marionette.Renderer.render(template, data, this);
                    return this.attachElContent(html), this
                }
            },
            attachElContent: function(html) {
                return this.$el.html(html), this
            }
        }), Marionette.CollectionView = Marionette.View.extend({
            childViewEventPrefix: "childview",
            sort: !0,
            constructor: function(options) {
                this.once("render", this._initialEvents), this._initChildViewStorage(), Marionette.View.apply(this, arguments), this.on({
                    "before:show": this._onBeforeShowCalled,
                    show: this._onShowCalled,
                    "before:attach": this._onBeforeAttachCalled,
                    attach: this._onAttachCalled
                }), this.initRenderBuffer()
            },
            initRenderBuffer: function() {
                this._bufferedChildren = []
            },
            startBuffering: function() {
                this.initRenderBuffer(), this.isBuffering = !0
            },
            endBuffering: function() {
                var nestedViews, canTriggerAttach = this._isShown && Marionette.isNodeAttached(this.el);
                this.isBuffering = !1, this._isShown && this._triggerMethodMany(this._bufferedChildren, this, "before:show"), canTriggerAttach && this._triggerBeforeAttach && (nestedViews = this._getNestedViews(), this._triggerMethodMany(nestedViews, this, "before:attach")), this.attachBuffer(this, this._createBuffer()), canTriggerAttach && this._triggerAttach && (nestedViews = this._getNestedViews(), this._triggerMethodMany(nestedViews, this, "attach")), this._isShown && this._triggerMethodMany(this._bufferedChildren, this, "show"), this.initRenderBuffer()
            },
            _triggerMethodMany: function(targets, source, eventName) {
                var args = _.drop(arguments, 3);
                _.each(targets, function(target) {
                    Marionette.triggerMethodOn.apply(target, [target, eventName, target, source].concat(args))
                })
            },
            _initialEvents: function() {
                this.collection && (this.listenTo(this.collection, "add", this._onCollectionAdd), this.listenTo(this.collection, "remove", this._onCollectionRemove), this.listenTo(this.collection, "reset", this.render), this.getOption("sort") && this.listenTo(this.collection, "sort", this._sortViews))
            },
            _onCollectionAdd: function(child, collection, opts) {
                var index = void 0 !== opts.at && (opts.index || collection.indexOf(child));
                if ((this.getOption("filter") || !1 === index) && (index = _.indexOf(this._filteredSortedModels(index), child)), this._shouldAddChild(child, index)) {
                    this.destroyEmptyView();
                    var ChildView = this.getChildView(child);
                    this.addChild(child, ChildView, index)
                }
            },
            _onCollectionRemove: function(model) {
                var view = this.children.findByModel(model);
                this.removeChildView(view), this.checkEmpty()
            },
            _onBeforeShowCalled: function() {
                this._triggerBeforeAttach = this._triggerAttach = !1, this.children.each(function(childView) {
                    Marionette.triggerMethodOn(childView, "before:show", childView)
                })
            },
            _onShowCalled: function() {
                this.children.each(function(childView) {
                    Marionette.triggerMethodOn(childView, "show", childView)
                })
            },
            _onBeforeAttachCalled: function() {
                this._triggerBeforeAttach = !0
            },
            _onAttachCalled: function() {
                this._triggerAttach = !0
            },
            render: function() {
                return this._ensureViewIsIntact(), this.triggerMethod("before:render", this), this._renderChildren(), this.isRendered = !0, this.triggerMethod("render", this), this
            },
            reorder: function() {
                var children = this.children,
                    models = this._filteredSortedModels();
                if (_.some(models, function(model) {
                        return !children.findByModel(model)
                    })) this.render();
                else {
                    var elsToReorder = _.map(models, function(model, index) {
                            var view = children.findByModel(model);
                            return view._index = index, view.el
                        }),
                        filteredOutViews = children.filter(function(view) {
                            return !_.contains(elsToReorder, view.el)
                        });
                    this.triggerMethod("before:reorder"), this._appendReorderedChildren(elsToReorder), _.each(filteredOutViews, this.removeChildView, this), this.checkEmpty(), this.triggerMethod("reorder")
                }
            },
            resortView: function() {
                Marionette.getOption(this, "reorderOnSort") ? this.reorder() : this.render()
            },
            _sortViews: function() {
                var models = this._filteredSortedModels();
                _.find(models, function(item, index) {
                    var view = this.children.findByModel(item);
                    return !view || view._index !== index
                }, this) && this.resortView()
            },
            _emptyViewIndex: -1,
            _appendReorderedChildren: function(children) {
                this.$el.append(children)
            },
            _renderChildren: function() {
                this.destroyEmptyView(), this.destroyChildren({
                    checkEmpty: !1
                }), this.isEmpty(this.collection) ? this.showEmptyView() : (this.triggerMethod("before:render:collection", this), this.startBuffering(), this.showCollection(), this.endBuffering(), this.triggerMethod("render:collection", this), this.children.isEmpty() && this.getOption("filter") && this.showEmptyView())
            },
            showCollection: function() {
                var ChildView, models = this._filteredSortedModels();
                _.each(models, function(child, index) {
                    ChildView = this.getChildView(child), this.addChild(child, ChildView, index)
                }, this)
            },
            _filteredSortedModels: function(addedAt) {
                var addedModel, viewComparator = this.getViewComparator(),
                    models = this.collection.models;
                (addedAt = Math.min(Math.max(addedAt, 0), models.length - 1), viewComparator) && (addedAt && (addedModel = models[addedAt], models = models.slice(0, addedAt).concat(models.slice(addedAt + 1))), models = this._sortModelsBy(models, viewComparator), addedModel && models.splice(addedAt, 0, addedModel));
                return this.getOption("filter") && (models = _.filter(models, function(model, index) {
                    return this._shouldAddChild(model, index)
                }, this)), models
            },
            _sortModelsBy: function(models, comparator) {
                return "string" == typeof comparator ? _.sortBy(models, function(model) {
                    return model.get(comparator)
                }, this) : 1 === comparator.length ? _.sortBy(models, comparator, this) : models.sort(_.bind(comparator, this))
            },
            showEmptyView: function() {
                var EmptyView = this.getEmptyView();
                if (EmptyView && !this._showingEmptyView) {
                    this.triggerMethod("before:render:empty"), this._showingEmptyView = !0;
                    var model = new Backbone.Model;
                    this.addEmptyView(model, EmptyView), this.triggerMethod("render:empty")
                }
            },
            destroyEmptyView: function() {
                this._showingEmptyView && (this.triggerMethod("before:remove:empty"), this.destroyChildren(), delete this._showingEmptyView, this.triggerMethod("remove:empty"))
            },
            getEmptyView: function() {
                return this.getOption("emptyView")
            },
            addEmptyView: function(child, EmptyView) {
                var nestedViews, canTriggerAttach = this._isShown && !this.isBuffering && Marionette.isNodeAttached(this.el),
                    emptyViewOptions = this.getOption("emptyViewOptions") || this.getOption("childViewOptions");
                _.isFunction(emptyViewOptions) && (emptyViewOptions = emptyViewOptions.call(this, child, this._emptyViewIndex));
                var view = this.buildChildView(child, EmptyView, emptyViewOptions);
                view._parent = this, this.proxyChildEvents(view), view.once("render", function() {
                    this._isShown && Marionette.triggerMethodOn(view, "before:show", view), canTriggerAttach && this._triggerBeforeAttach && (nestedViews = this._getViewAndNested(view), this._triggerMethodMany(nestedViews, this, "before:attach"))
                }, this), this.children.add(view), this.renderChildView(view, this._emptyViewIndex), canTriggerAttach && this._triggerAttach && (nestedViews = this._getViewAndNested(view), this._triggerMethodMany(nestedViews, this, "attach")), this._isShown && Marionette.triggerMethodOn(view, "show", view)
            },
            getChildView: function(child) {
                var childView = this.getOption("childView");
                if (!childView) throw new Marionette.Error({
                    name: "NoChildViewError",
                    message: 'A "childView" must be specified'
                });
                return childView
            },
            addChild: function(child, ChildView, index) {
                var childViewOptions = this.getOption("childViewOptions");
                childViewOptions = Marionette._getValue(childViewOptions, this, [child, index]);
                var view = this.buildChildView(child, ChildView, childViewOptions);
                return this._updateIndices(view, !0, index), this.triggerMethod("before:add:child", view), this._addChildView(view, index), this.triggerMethod("add:child", view), view._parent = this, view
            },
            _updateIndices: function(view, increment, index) {
                this.getOption("sort") && (increment && (view._index = index), this.children.each(function(laterView) {
                    laterView._index >= view._index && (laterView._index += increment ? 1 : -1)
                }))
            },
            _addChildView: function(view, index) {
                var nestedViews, canTriggerAttach = this._isShown && !this.isBuffering && Marionette.isNodeAttached(this.el);
                this.proxyChildEvents(view), view.once("render", function() {
                    this._isShown && !this.isBuffering && Marionette.triggerMethodOn(view, "before:show", view), canTriggerAttach && this._triggerBeforeAttach && (nestedViews = this._getViewAndNested(view), this._triggerMethodMany(nestedViews, this, "before:attach"))
                }, this), this.children.add(view), this.renderChildView(view, index), canTriggerAttach && this._triggerAttach && (nestedViews = this._getViewAndNested(view), this._triggerMethodMany(nestedViews, this, "attach")), this._isShown && !this.isBuffering && Marionette.triggerMethodOn(view, "show", view)
            },
            renderChildView: function(view, index) {
                return view.supportsRenderLifecycle || Marionette.triggerMethodOn(view, "before:render", view), view.render(), view.supportsRenderLifecycle || Marionette.triggerMethodOn(view, "render", view), this.attachHtml(this, view, index), view
            },
            buildChildView: function(child, ChildViewClass, childViewOptions) {
                var childView = new ChildViewClass(_.extend({
                    model: child
                }, childViewOptions));
                return Marionette.MonitorDOMRefresh(childView), childView
            },
            removeChildView: function(view) {
                return view ? (this.triggerMethod("before:remove:child", view), view.supportsDestroyLifecycle || Marionette.triggerMethodOn(view, "before:destroy", view), view.destroy ? view.destroy() : view.remove(), view.supportsDestroyLifecycle || Marionette.triggerMethodOn(view, "destroy", view), delete view._parent, this.stopListening(view), this.children.remove(view), this.triggerMethod("remove:child", view), this._updateIndices(view, !1), view) : view
            },
            isEmpty: function() {
                return !this.collection || 0 === this.collection.length
            },
            checkEmpty: function() {
                this.isEmpty(this.collection) && this.showEmptyView()
            },
            attachBuffer: function(collectionView, buffer) {
                collectionView.$el.append(buffer)
            },
            _createBuffer: function() {
                var elBuffer = document.createDocumentFragment();
                return _.each(this._bufferedChildren, function(b) {
                    elBuffer.appendChild(b.el)
                }), elBuffer
            },
            attachHtml: function(collectionView, childView, index) {
                collectionView.isBuffering ? collectionView._bufferedChildren.splice(index, 0, childView) : collectionView._insertBefore(childView, index) || collectionView._insertAfter(childView)
            },
            _insertBefore: function(childView, index) {
                var currentView;
                return this.getOption("sort") && index < this.children.length - 1 && (currentView = this.children.find(function(view) {
                    return view._index === index + 1
                })), !!currentView && (currentView.$el.before(childView.el), !0)
            },
            _insertAfter: function(childView) {
                this.$el.append(childView.el)
            },
            _initChildViewStorage: function() {
                this.children = new Backbone.ChildViewContainer
            },
            destroy: function() {
                return this.isDestroyed ? this : (this.triggerMethod("before:destroy:collection"), this.destroyChildren({
                    checkEmpty: !1
                }), this.triggerMethod("destroy:collection"), Marionette.View.prototype.destroy.apply(this, arguments))
            },
            destroyChildren: function(options) {
                var destroyOptions = options || {},
                    shouldCheckEmpty = !0,
                    childViews = this.children.map(_.identity);
                return _.isUndefined(destroyOptions.checkEmpty) || (shouldCheckEmpty = destroyOptions.checkEmpty), this.children.each(this.removeChildView, this), shouldCheckEmpty && this.checkEmpty(), childViews
            },
            _shouldAddChild: function(child, index) {
                var filter = this.getOption("filter");
                return !_.isFunction(filter) || filter.call(this, child, index, this.collection)
            },
            proxyChildEvents: function(view) {
                var prefix = this.getOption("childViewEventPrefix");
                this.listenTo(view, "all", function() {
                    var args = _.toArray(arguments),
                        rootEvent = args[0],
                        childEvents = this.normalizeMethods(_.result(this, "childEvents"));
                    args[0] = prefix + ":" + rootEvent, args.splice(1, 0, view), void 0 !== childEvents && _.isFunction(childEvents[rootEvent]) && childEvents[rootEvent].apply(this, args.slice(1)), this.triggerMethod.apply(this, args)
                })
            },
            _getImmediateChildren: function() {
                return _.values(this.children._views)
            },
            _getViewAndNested: function(view) {
                return [view].concat(_.result(view, "_getNestedViews") || [])
            },
            getViewComparator: function() {
                return this.getOption("viewComparator")
            }
        }), Marionette.CompositeView = Marionette.CollectionView.extend({
            constructor: function() {
                Marionette.CollectionView.apply(this, arguments)
            },
            _initialEvents: function() {
                this.collection && (this.listenTo(this.collection, "add", this._onCollectionAdd), this.listenTo(this.collection, "remove", this._onCollectionRemove), this.listenTo(this.collection, "reset", this._renderChildren), this.getOption("sort") && this.listenTo(this.collection, "sort", this._sortViews))
            },
            getChildView: function(child) {
                return this.getOption("childView") || this.constructor
            },
            serializeData: function() {
                var data = {};
                return this.model && (data = _.partial(this.serializeModel, this.model).apply(this, arguments)), data
            },
            render: function() {
                return this._ensureViewIsIntact(), this._isRendering = !0, this.resetChildViewContainer(), this.triggerMethod("before:render", this), this._renderTemplate(), this._renderChildren(), this._isRendering = !1, this.isRendered = !0, this.triggerMethod("render", this), this
            },
            _renderChildren: function() {
                (this.isRendered || this._isRendering) && Marionette.CollectionView.prototype._renderChildren.call(this)
            },
            _renderTemplate: function() {
                var data = {};
                data = this.serializeData(), data = this.mixinTemplateHelpers(data), this.triggerMethod("before:render:template");
                var template = this.getTemplate(),
                    html = Marionette.Renderer.render(template, data, this);
                this.attachElContent(html), this.bindUIElements(), this.triggerMethod("render:template")
            },
            attachElContent: function(html) {
                return this.$el.html(html), this
            },
            attachBuffer: function(compositeView, buffer) {
                this.getChildViewContainer(compositeView).append(buffer)
            },
            _insertAfter: function(childView) {
                this.getChildViewContainer(this, childView).append(childView.el)
            },
            _appendReorderedChildren: function(children) {
                this.getChildViewContainer(this).append(children)
            },
            getChildViewContainer: function(containerView, childView) {
                if (containerView.$childViewContainer) return containerView.$childViewContainer;
                var container, childViewContainer = Marionette.getOption(containerView, "childViewContainer");
                if (childViewContainer) {
                    var selector = Marionette._getValue(childViewContainer, containerView);
                    if ((container = "@" === selector.charAt(0) && containerView.ui ? containerView.ui[selector.substr(4)] : containerView.$(selector)).length <= 0) throw new Marionette.Error({
                        name: "ChildViewContainerMissingError",
                        message: 'The specified "childViewContainer" was not found: ' + containerView.childViewContainer
                    })
                } else container = containerView.$el;
                return containerView.$childViewContainer = container, container
            },
            resetChildViewContainer: function() {
                this.$childViewContainer && (this.$childViewContainer = void 0)
            }
        }), Marionette.LayoutView = Marionette.ItemView.extend({
            regionClass: Marionette.Region,
            options: {
                destroyImmediate: !1
            },
            childViewEventPrefix: "childview",
            constructor: function(options) {
                options = options || {}, this._firstRender = !0, this._initializeRegions(options), Marionette.ItemView.call(this, options)
            },
            render: function() {
                return this._ensureViewIsIntact(), this._firstRender ? this._firstRender = !1 : this._reInitializeRegions(), Marionette.ItemView.prototype.render.apply(this, arguments)
            },
            destroy: function() {
                return this.isDestroyed ? this : (!0 === this.getOption("destroyImmediate") && this.$el.remove(), this.regionManager.destroy(), Marionette.ItemView.prototype.destroy.apply(this, arguments))
            },
            showChildView: function(regionName, view, options) {
                var region = this.getRegion(regionName);
                return region.show.apply(region, _.rest(arguments))
            },
            getChildView: function(regionName) {
                return this.getRegion(regionName).currentView
            },
            addRegion: function(name, definition) {
                var regions = {};
                return regions[name] = definition, this._buildRegions(regions)[name]
            },
            addRegions: function(regions) {
                return this.regions = _.extend({}, this.regions, regions), this._buildRegions(regions)
            },
            removeRegion: function(name) {
                return delete this.regions[name], this.regionManager.removeRegion(name)
            },
            getRegion: function(region) {
                return this.regionManager.get(region)
            },
            getRegions: function() {
                return this.regionManager.getRegions()
            },
            _buildRegions: function(regions) {
                var defaults = {
                    regionClass: this.getOption("regionClass"),
                    parentEl: _.partial(_.result, this, "el")
                };
                return this.regionManager.addRegions(regions, defaults)
            },
            _initializeRegions: function(options) {
                var regions;
                this._initRegionManager(), regions = Marionette._getValue(this.regions, this, [options]) || {};
                var regionOptions = this.getOption.call(options, "regions");
                regionOptions = Marionette._getValue(regionOptions, this, [options]), _.extend(regions, regionOptions), regions = this.normalizeUIValues(regions, ["selector", "el"]), this.addRegions(regions)
            },
            _reInitializeRegions: function() {
                this.regionManager.invoke("reset")
            },
            getRegionManager: function() {
                return new Marionette.RegionManager
            },
            _initRegionManager: function() {
                this.regionManager = this.getRegionManager(), this.regionManager._parent = this, this.listenTo(this.regionManager, "before:add:region", function(name) {
                    this.triggerMethod("before:add:region", name)
                }), this.listenTo(this.regionManager, "add:region", function(name, region) {
                    this[name] = region, this.triggerMethod("add:region", name, region)
                }), this.listenTo(this.regionManager, "before:remove:region", function(name) {
                    this.triggerMethod("before:remove:region", name)
                }), this.listenTo(this.regionManager, "remove:region", function(name, region) {
                    delete this[name], this.triggerMethod("remove:region", name, region)
                })
            },
            _getImmediateChildren: function() {
                return _.chain(this.regionManager.getRegions()).pluck("currentView").compact().value()
            }
        }), Marionette.Behavior = Marionette.Object.extend({
            constructor: function(options, view) {
                this.view = view, this.defaults = _.result(this, "defaults") || {}, this.options = _.extend({}, this.defaults, options), this.ui = _.extend({}, _.result(view, "ui"), _.result(this, "ui")), Marionette.Object.apply(this, arguments)
            },
            $: function() {
                return this.view.$.apply(this.view, arguments)
            },
            destroy: function() {
                return this.stopListening(), this
            },
            proxyViewProperties: function(view) {
                this.$el = view.$el, this.el = view.el
            }
        }), Marionette.Behaviors = function(Marionette, _) {
            var delegateEventSplitter = /^(\S+)\s*(.*)$/;

            function Behaviors(view, behaviors) {
                return _.isObject(view.behaviors) ? (behaviors = Behaviors.parseBehaviors(view, behaviors || _.result(view, "behaviors")), Behaviors.wrap(view, behaviors, _.keys(methods)), behaviors) : {}
            }
            var methods = {
                behaviorTriggers: function(behaviorTriggers, behaviors) {
                    return new BehaviorTriggersBuilder(this, behaviors).buildBehaviorTriggers()
                },
                behaviorEvents: function(behaviorEvents, behaviors) {
                    var _behaviorsEvents = {};
                    return _.each(behaviors, function(b, i) {
                        var _events = {},
                            behaviorEvents = _.clone(_.result(b, "events")) || {};
                        behaviorEvents = Marionette.normalizeUIKeys(behaviorEvents, getBehaviorsUI(b));
                        var j = 0;
                        _.each(behaviorEvents, function(behaviour, key) {
                            var match = key.match(delegateEventSplitter),
                                eventKey = match[1] + "." + [this.cid, i, j++, " "].join("") + match[2],
                                handler = _.isFunction(behaviour) ? behaviour : b[behaviour];
                            _events[eventKey] = _.bind(handler, b)
                        }, this), _behaviorsEvents = _.extend(_behaviorsEvents, _events)
                    }, this), _behaviorsEvents
                }
            };

            function BehaviorTriggersBuilder(view, behaviors) {
                this._view = view, this._behaviors = behaviors, this._triggers = {}
            }

            function getBehaviorsUI(behavior) {
                return behavior._uiBindings || behavior.ui
            }
            return _.extend(Behaviors, {
                behaviorsLookup: function() {
                    throw new Marionette.Error({
                        message: "You must define where your behaviors are stored.",
                        url: "marionette.behaviors.html#behaviorslookup"
                    })
                },
                getBehaviorClass: function(options, key) {
                    return options.behaviorClass ? options.behaviorClass : Marionette._getValue(Behaviors.behaviorsLookup, this, [options, key])[key]
                },
                parseBehaviors: function(view, behaviors) {
                    return _.chain(behaviors).map(function(options, key) {
                        var behavior = new(Behaviors.getBehaviorClass(options, key))(options, view),
                            nestedBehaviors = Behaviors.parseBehaviors(view, _.result(behavior, "behaviors"));
                        return [behavior].concat(nestedBehaviors)
                    }).flatten().value()
                },
                wrap: function(view, behaviors, methodNames) {
                    _.each(methodNames, function(methodName) {
                        view[methodName] = _.partial(methods[methodName], view[methodName], behaviors)
                    })
                }
            }), _.extend(BehaviorTriggersBuilder.prototype, {
                buildBehaviorTriggers: function() {
                    return _.each(this._behaviors, this._buildTriggerHandlersForBehavior, this), this._triggers
                },
                _buildTriggerHandlersForBehavior: function(behavior, i) {
                    var triggersHash = _.clone(_.result(behavior, "triggers")) || {};
                    triggersHash = Marionette.normalizeUIKeys(triggersHash, getBehaviorsUI(behavior)), _.each(triggersHash, _.bind(this._setHandlerForBehavior, this, behavior, i))
                },
                _setHandlerForBehavior: function(behavior, i, eventName, trigger) {
                    var triggerKey = trigger.replace(/^\S+/, function(triggerName) {
                        return triggerName + ".behaviortriggers" + i
                    });
                    this._triggers[triggerKey] = this._view._buildViewTrigger(eventName)
                }
            }), Behaviors
        }(Marionette, _), Marionette.AppRouter = Backbone.Router.extend({
            constructor: function(options) {
                this.options = options || {}, Backbone.Router.apply(this, arguments);
                var appRoutes = this.getOption("appRoutes"),
                    controller = this._getController();
                this.processAppRoutes(controller, appRoutes), this.on("route", this._processOnRoute, this)
            },
            appRoute: function(route, methodName) {
                var controller = this._getController();
                this._addAppRoute(controller, route, methodName)
            },
            _processOnRoute: function(routeName, routeArgs) {
                if (_.isFunction(this.onRoute)) {
                    var routePath = _.invert(this.getOption("appRoutes"))[routeName];
                    this.onRoute(routeName, routePath, routeArgs)
                }
            },
            processAppRoutes: function(controller, appRoutes) {
                if (appRoutes) {
                    var routeNames = _.keys(appRoutes).reverse();
                    _.each(routeNames, function(route) {
                        this._addAppRoute(controller, route, appRoutes[route])
                    }, this)
                }
            },
            _getController: function() {
                return this.getOption("controller")
            },
            _addAppRoute: function(controller, route, methodName) {
                var method = controller[methodName];
                if (!method) throw new Marionette.Error('Method "' + methodName + '" was not found on the controller');
                this.route(route, methodName, _.bind(method, controller))
            },
            mergeOptions: Marionette.mergeOptions,
            getOption: Marionette.proxyGetOption,
            triggerMethod: Marionette.triggerMethod,
            bindEntityEvents: Marionette.proxyBindEntityEvents,
            unbindEntityEvents: Marionette.proxyUnbindEntityEvents
        }), Marionette.Application = Marionette.Object.extend({
            constructor: function(options) {
                this._initializeRegions(options), this._initCallbacks = new Marionette.Callbacks, this.submodules = {}, _.extend(this, options), this._initChannel(), Marionette.Object.apply(this, arguments)
            },
            execute: function() {
                this.commands.execute.apply(this.commands, arguments)
            },
            request: function() {
                return this.reqres.request.apply(this.reqres, arguments)
            },
            addInitializer: function(initializer) {
                this._initCallbacks.add(initializer)
            },
            start: function(options) {
                this.triggerMethod("before:start", options), this._initCallbacks.run(options, this), this.triggerMethod("start", options)
            },
            addRegions: function(regions) {
                return this._regionManager.addRegions(regions)
            },
            emptyRegions: function() {
                return this._regionManager.emptyRegions()
            },
            removeRegion: function(region) {
                return this._regionManager.removeRegion(region)
            },
            getRegion: function(region) {
                return this._regionManager.get(region)
            },
            getRegions: function() {
                return this._regionManager.getRegions()
            },
            module: function(moduleNames, moduleDefinition) {
                var ModuleClass = Marionette.Module.getClass(moduleDefinition),
                    args = _.toArray(arguments);
                return args.unshift(this), ModuleClass.create.apply(ModuleClass, args)
            },
            getRegionManager: function() {
                return new Marionette.RegionManager
            },
            _initializeRegions: function(options) {
                var regions = _.isFunction(this.regions) ? this.regions(options) : this.regions || {};
                this._initRegionManager();
                var optionRegions = Marionette.getOption(options, "regions");
                return _.isFunction(optionRegions) && (optionRegions = optionRegions.call(this, options)), _.extend(regions, optionRegions), this.addRegions(regions), this
            },
            _initRegionManager: function() {
                this._regionManager = this.getRegionManager(), this._regionManager._parent = this, this.listenTo(this._regionManager, "before:add:region", function() {
                    Marionette._triggerMethod(this, "before:add:region", arguments)
                }), this.listenTo(this._regionManager, "add:region", function(name, region) {
                    this[name] = region, Marionette._triggerMethod(this, "add:region", arguments)
                }), this.listenTo(this._regionManager, "before:remove:region", function() {
                    Marionette._triggerMethod(this, "before:remove:region", arguments)
                }), this.listenTo(this._regionManager, "remove:region", function(name) {
                    delete this[name], Marionette._triggerMethod(this, "remove:region", arguments)
                })
            },
            _initChannel: function() {
                this.channelName = _.result(this, "channelName") || "global", this.channel = _.result(this, "channel") || Backbone.Wreqr.radio.channel(this.channelName), this.vent = _.result(this, "vent") || this.channel.vent, this.commands = _.result(this, "commands") || this.channel.commands, this.reqres = _.result(this, "reqres") || this.channel.reqres
            }
        }), Marionette.Module = function(moduleName, app, options) {
            this.moduleName = moduleName, this.options = _.extend({}, this.options, options), this.initialize = options.initialize || this.initialize, this.submodules = {}, this._setupInitializersAndFinalizers(), this.app = app, _.isFunction(this.initialize) && this.initialize(moduleName, app, this.options)
        }, Marionette.Module.extend = Marionette.extend, _.extend(Marionette.Module.prototype, Backbone.Events, {
            startWithParent: !0,
            initialize: function() {},
            addInitializer: function(callback) {
                this._initializerCallbacks.add(callback)
            },
            addFinalizer: function(callback) {
                this._finalizerCallbacks.add(callback)
            },
            start: function(options) {
                this._isInitialized || (_.each(this.submodules, function(mod) {
                    mod.startWithParent && mod.start(options)
                }), this.triggerMethod("before:start", options), this._initializerCallbacks.run(options, this), this._isInitialized = !0, this.triggerMethod("start", options))
            },
            stop: function() {
                this._isInitialized && (this._isInitialized = !1, this.triggerMethod("before:stop"), _.invoke(this.submodules, "stop"), this._finalizerCallbacks.run(void 0, this), this._initializerCallbacks.reset(), this._finalizerCallbacks.reset(), this.triggerMethod("stop"))
            },
            addDefinition: function(moduleDefinition, customArgs) {
                this._runModuleDefinition(moduleDefinition, customArgs)
            },
            _runModuleDefinition: function(definition, customArgs) {
                if (definition) {
                    var args = _.flatten([this, this.app, Backbone, Marionette, Backbone.$, _, customArgs]);
                    definition.apply(this, args)
                }
            },
            _setupInitializersAndFinalizers: function() {
                this._initializerCallbacks = new Marionette.Callbacks, this._finalizerCallbacks = new Marionette.Callbacks
            },
            triggerMethod: Marionette.triggerMethod
        }), _.extend(Marionette.Module, {
            create: function(app, moduleNames, moduleDefinition) {
                var module = app,
                    customArgs = _.drop(arguments, 3),
                    length = (moduleNames = moduleNames.split(".")).length,
                    moduleDefinitions = [];
                return moduleDefinitions[length - 1] = moduleDefinition, _.each(moduleNames, function(moduleName, i) {
                    var parentModule = module;
                    module = this._getModule(parentModule, moduleName, app, moduleDefinition), this._addModuleDefinition(parentModule, module, moduleDefinitions[i], customArgs)
                }, this), module
            },
            _getModule: function(parentModule, moduleName, app, def, args) {
                var options = _.extend({}, def),
                    ModuleClass = this.getClass(def),
                    module = parentModule[moduleName];
                return module || (module = new ModuleClass(moduleName, app, options), parentModule[moduleName] = module, parentModule.submodules[moduleName] = module), module
            },
            getClass: function(moduleDefinition) {
                var ModuleClass = Marionette.Module;
                return moduleDefinition ? moduleDefinition.prototype instanceof ModuleClass ? moduleDefinition : moduleDefinition.moduleClass || ModuleClass : ModuleClass
            },
            _addModuleDefinition: function(parentModule, module, def, args) {
                var fn = this._getDefine(def),
                    startWithParent = this._getStartWithParent(def, module);
                fn && module.addDefinition(fn, args), this._addStartWithParent(parentModule, module, startWithParent)
            },
            _getStartWithParent: function(def, module) {
                var swp;
                return _.isFunction(def) && def.prototype instanceof Marionette.Module ? (swp = module.constructor.prototype.startWithParent, !!_.isUndefined(swp) || swp) : !_.isObject(def) || (swp = def.startWithParent, !!_.isUndefined(swp) || swp)
            },
            _getDefine: function(def) {
                return !_.isFunction(def) || def.prototype instanceof Marionette.Module ? _.isObject(def) ? def.define : null : def
            },
            _addStartWithParent: function(parentModule, module, startWithParent) {
                module.startWithParent = module.startWithParent && startWithParent, module.startWithParent && !module.startWithParentIsConfigured && (module.startWithParentIsConfigured = !0, parentModule.addInitializer(function(options) {
                    module.startWithParent && module.start(options)
                }))
            }
        }), Marionette
    }, __WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(53), __webpack_require__(43), __webpack_require__(341), __webpack_require__(342)], void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = function(Backbone, _) {
        return root.Marionette = root.Mn = factory(root, Backbone, _)
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)
}, function(module, exports, __webpack_require__) {
    (function(global) {
        ("undefined" != typeof window && !window._babelPolyfill || void 0 !== global && !global._babelPolyfill) && __webpack_require__(135);
        var store = __webpack_require__(337);
        if (window.__INITIAL_STATE__) {
            store.replaceState(window.__INITIAL_STATE__);
            var _ref = store.get("properties") || {},
                ASSET_HOST = _ref.ASSET_HOST,
                PUBLIC_PATH_PREFIX = _ref.PUBLIC_PATH_PREFIX;
            void 0 !== PUBLIC_PATH_PREFIX && (__webpack_require__.p = PUBLIC_PATH_PREFIX + __webpack_require__.p), ASSET_HOST && 0 !== __webpack_require__.p.indexOf("http") && 0 !== __webpack_require__.p.indexOf("//") && (__webpack_require__.p = ASSET_HOST + __webpack_require__.p)
        }
        var app = void 0,
            initialize = function() {
                var m = __webpack_require__(340);
                if (!(app = m.default || m).start) throw new Error("Expected an app.start() method exported by /opt/jenkins_home/workspace/marketing-campaigns_deploy_trigger_bcom/package/app.js");
                setTimeout(function() {
                    app.start()
                }, 0)
            };
        initialize(), module.exports = app
    }).call(exports, __webpack_require__(54))
}, function(module, exports, __webpack_require__) {
    "use strict";
    (function(global) {
        if (__webpack_require__(136), __webpack_require__(333), __webpack_require__(334), global._babelPolyfill) throw new Error("only one instance of babel-polyfill is allowed");
        global._babelPolyfill = !0;
        var DEFINE_PROPERTY = "defineProperty";

        function define(O, key, value) {
            O[key] || Object[DEFINE_PROPERTY](O, key, {
                writable: !0,
                configurable: !0,
                value: value
            })
        }
        define(String.prototype, "padLeft", "".padStart), define(String.prototype, "padRight", "".padEnd), "pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function(key) {
            [][key] && define(Array, key, Function.call.bind([][key]))
        })
    }).call(exports, __webpack_require__(54))
}, function(module, exports, __webpack_require__) {
    __webpack_require__(137), __webpack_require__(140), __webpack_require__(141), __webpack_require__(142), __webpack_require__(143), __webpack_require__(144), __webpack_require__(145), __webpack_require__(146), __webpack_require__(147), __webpack_require__(148), __webpack_require__(149), __webpack_require__(150), __webpack_require__(151), __webpack_require__(152), __webpack_require__(153), __webpack_require__(154), __webpack_require__(155), __webpack_require__(156), __webpack_require__(157), __webpack_require__(158), __webpack_require__(159), __webpack_require__(160), __webpack_require__(161), __webpack_require__(162), __webpack_require__(163), __webpack_require__(164), __webpack_require__(165), __webpack_require__(166), __webpack_require__(167), __webpack_require__(168), __webpack_require__(169), __webpack_require__(170), __webpack_require__(171), __webpack_require__(172), __webpack_require__(173), __webpack_require__(174), __webpack_require__(175), __webpack_require__(176), __webpack_require__(177), __webpack_require__(178), __webpack_require__(179), __webpack_require__(180), __webpack_require__(181), __webpack_require__(182), __webpack_require__(183), __webpack_require__(184), __webpack_require__(185), __webpack_require__(186), __webpack_require__(187), __webpack_require__(188), __webpack_require__(189), __webpack_require__(190), __webpack_require__(191), __webpack_require__(192), __webpack_require__(193), __webpack_require__(194), __webpack_require__(195), __webpack_require__(196), __webpack_require__(197), __webpack_require__(198), __webpack_require__(199), __webpack_require__(200), __webpack_require__(201), __webpack_require__(202), __webpack_require__(203), __webpack_require__(204), __webpack_require__(205), __webpack_require__(206), __webpack_require__(207), __webpack_require__(208), __webpack_require__(209), __webpack_require__(210), __webpack_require__(211), __webpack_require__(212), __webpack_require__(213), __webpack_require__(214), __webpack_require__(215), __webpack_require__(217), __webpack_require__(218), __webpack_require__(220), __webpack_require__(221), __webpack_require__(222), __webpack_require__(223), __webpack_require__(224), __webpack_require__(225), __webpack_require__(226), __webpack_require__(228), __webpack_require__(229), __webpack_require__(230), __webpack_require__(231), __webpack_require__(232), __webpack_require__(233), __webpack_require__(234), __webpack_require__(235), __webpack_require__(236), __webpack_require__(237), __webpack_require__(238), __webpack_require__(239), __webpack_require__(240), __webpack_require__(90), __webpack_require__(241), __webpack_require__(116), __webpack_require__(242), __webpack_require__(117), __webpack_require__(243), __webpack_require__(244), __webpack_require__(245), __webpack_require__(246), __webpack_require__(247), __webpack_require__(120), __webpack_require__(122), __webpack_require__(123), __webpack_require__(248), __webpack_require__(249), __webpack_require__(250), __webpack_require__(251), __webpack_require__(252), __webpack_require__(253), __webpack_require__(254), __webpack_require__(255), __webpack_require__(256), __webpack_require__(257), __webpack_require__(258), __webpack_require__(259), __webpack_require__(260), __webpack_require__(261), __webpack_require__(262), __webpack_require__(263), __webpack_require__(264), __webpack_require__(265), __webpack_require__(266), __webpack_require__(267), __webpack_require__(268), __webpack_require__(269), __webpack_require__(270), __webpack_require__(271), __webpack_require__(272), __webpack_require__(273), __webpack_require__(274), __webpack_require__(275), __webpack_require__(276), __webpack_require__(277), __webpack_require__(278), __webpack_require__(279), __webpack_require__(280), __webpack_require__(281), __webpack_require__(282), __webpack_require__(283), __webpack_require__(284), __webpack_require__(285), __webpack_require__(286), __webpack_require__(287), __webpack_require__(288), __webpack_require__(289), __webpack_require__(290), __webpack_require__(291), __webpack_require__(292), __webpack_require__(293), __webpack_require__(294), __webpack_require__(295), __webpack_require__(296), __webpack_require__(297), __webpack_require__(298), __webpack_require__(299), __webpack_require__(300), __webpack_require__(301), __webpack_require__(302), __webpack_require__(303), __webpack_require__(304), __webpack_require__(305), __webpack_require__(306), __webpack_require__(307), __webpack_require__(308), __webpack_require__(309), __webpack_require__(310), __webpack_require__(311), __webpack_require__(312), __webpack_require__(313), __webpack_require__(314), __webpack_require__(315), __webpack_require__(316), __webpack_require__(317), __webpack_require__(318), __webpack_require__(319), __webpack_require__(320), __webpack_require__(321), __webpack_require__(322), __webpack_require__(323), __webpack_require__(324), __webpack_require__(325), __webpack_require__(326), __webpack_require__(327), __webpack_require__(328), __webpack_require__(329), __webpack_require__(330), __webpack_require__(331), __webpack_require__(332), module.exports = __webpack_require__(18)
}, function(module, exports, __webpack_require__) {
    "use strict";
    var global = __webpack_require__(2),
        has = __webpack_require__(14),
        DESCRIPTORS = __webpack_require__(7),
        $export = __webpack_require__(0),
        redefine = __webpack_require__(12),
        META = __webpack_require__(30).KEY,
        $fails = __webpack_require__(3),
        shared = __webpack_require__(48),
        setToStringTag = __webpack_require__(44),
        uid = __webpack_require__(33),
        wks = __webpack_require__(5),
        wksExt = __webpack_require__(98),
        wksDefine = __webpack_require__(71),
        enumKeys = __webpack_require__(139),
        isArray = __webpack_require__(57),
        anObject = __webpack_require__(1),
        isObject = __webpack_require__(4),
        toObject = __webpack_require__(9),
        toIObject = __webpack_require__(15),
        toPrimitive = __webpack_require__(23),
        createDesc = __webpack_require__(32),
        _create = __webpack_require__(36),
        gOPNExt = __webpack_require__(101),
        $GOPD = __webpack_require__(16),
        $GOPS = __webpack_require__(56),
        $DP = __webpack_require__(8),
        $keys = __webpack_require__(34),
        gOPD = $GOPD.f,
        dP = $DP.f,
        gOPN = gOPNExt.f,
        $Symbol = global.Symbol,
        $JSON = global.JSON,
        _stringify = $JSON && $JSON.stringify,
        HIDDEN = wks("_hidden"),
        TO_PRIMITIVE = wks("toPrimitive"),
        isEnum = {}.propertyIsEnumerable,
        SymbolRegistry = shared("symbol-registry"),
        AllSymbols = shared("symbols"),
        OPSymbols = shared("op-symbols"),
        ObjectProto = Object.prototype,
        USE_NATIVE = "function" == typeof $Symbol && !!$GOPS.f,
        QObject = global.QObject,
        setter = !QObject || !QObject.prototype || !QObject.prototype.findChild,
        setSymbolDesc = DESCRIPTORS && $fails(function() {
            return 7 != _create(dP({}, "a", {
                get: function() {
                    return dP(this, "a", {
                        value: 7
                    }).a
                }
            })).a
        }) ? function(it, key, D) {
            var protoDesc = gOPD(ObjectProto, key);
            protoDesc && delete ObjectProto[key], dP(it, key, D), protoDesc && it !== ObjectProto && dP(ObjectProto, key, protoDesc)
        } : dP,
        wrap = function(tag) {
            var sym = AllSymbols[tag] = _create($Symbol.prototype);
            return sym._k = tag, sym
        },
        isSymbol = USE_NATIVE && "symbol" == typeof $Symbol.iterator ? function(it) {
            return "symbol" == typeof it
        } : function(it) {
            return it instanceof $Symbol
        },
        $defineProperty = function(it, key, D) {
            return it === ObjectProto && $defineProperty(OPSymbols, key, D), anObject(it), key = toPrimitive(key, !0), anObject(D), has(AllSymbols, key) ? (D.enumerable ? (has(it, HIDDEN) && it[HIDDEN][key] && (it[HIDDEN][key] = !1), D = _create(D, {
                enumerable: createDesc(0, !1)
            })) : (has(it, HIDDEN) || dP(it, HIDDEN, createDesc(1, {})), it[HIDDEN][key] = !0), setSymbolDesc(it, key, D)) : dP(it, key, D)
        },
        $defineProperties = function(it, P) {
            anObject(it);
            for (var key, keys = enumKeys(P = toIObject(P)), i = 0, l = keys.length; l > i;) $defineProperty(it, key = keys[i++], P[key]);
            return it
        },
        $propertyIsEnumerable = function(key) {
            var E = isEnum.call(this, key = toPrimitive(key, !0));
            return !(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) && (!(E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]) || E)
        },
        $getOwnPropertyDescriptor = function(it, key) {
            if (it = toIObject(it), key = toPrimitive(key, !0), it !== ObjectProto || !has(AllSymbols, key) || has(OPSymbols, key)) {
                var D = gOPD(it, key);
                return !D || !has(AllSymbols, key) || has(it, HIDDEN) && it[HIDDEN][key] || (D.enumerable = !0), D
            }
        },
        $getOwnPropertyNames = function(it) {
            for (var key, names = gOPN(toIObject(it)), result = [], i = 0; names.length > i;) has(AllSymbols, key = names[i++]) || key == HIDDEN || key == META || result.push(key);
            return result
        },
        $getOwnPropertySymbols = function(it) {
            for (var key, IS_OP = it === ObjectProto, names = gOPN(IS_OP ? OPSymbols : toIObject(it)), result = [], i = 0; names.length > i;) !has(AllSymbols, key = names[i++]) || IS_OP && !has(ObjectProto, key) || result.push(AllSymbols[key]);
            return result
        };
    USE_NATIVE || (redefine(($Symbol = function() {
        if (this instanceof $Symbol) throw TypeError("Symbol is not a constructor!");
        var tag = uid(arguments.length > 0 ? arguments[0] : void 0),
            $set = function(value) {
                this === ObjectProto && $set.call(OPSymbols, value), has(this, HIDDEN) && has(this[HIDDEN], tag) && (this[HIDDEN][tag] = !1), setSymbolDesc(this, tag, createDesc(1, value))
            };
        return DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {
            configurable: !0,
            set: $set
        }), wrap(tag)
    }).prototype, "toString", function() {
        return this._k
    }), $GOPD.f = $getOwnPropertyDescriptor, $DP.f = $defineProperty, __webpack_require__(37).f = gOPNExt.f = $getOwnPropertyNames, __webpack_require__(50).f = $propertyIsEnumerable, $GOPS.f = $getOwnPropertySymbols, DESCRIPTORS && !__webpack_require__(29) && redefine(ObjectProto, "propertyIsEnumerable", $propertyIsEnumerable, !0), wksExt.f = function(name) {
        return wrap(wks(name))
    }), $export($export.G + $export.W + $export.F * !USE_NATIVE, {
        Symbol: $Symbol
    });
    for (var es6Symbols = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), j = 0; es6Symbols.length > j;) wks(es6Symbols[j++]);
    for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);
    $export($export.S + $export.F * !USE_NATIVE, "Symbol", {
        for: function(key) {
            return has(SymbolRegistry, key += "") ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key)
        },
        keyFor: function(sym) {
            if (!isSymbol(sym)) throw TypeError(sym + " is not a symbol!");
            for (var key in SymbolRegistry)
                if (SymbolRegistry[key] === sym) return key
        },
        useSetter: function() {
            setter = !0
        },
        useSimple: function() {
            setter = !1
        }
    }), $export($export.S + $export.F * !USE_NATIVE, "Object", {
        create: function(it, P) {
            return void 0 === P ? _create(it) : $defineProperties(_create(it), P)
        },
        defineProperty: $defineProperty,
        defineProperties: $defineProperties,
        getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
        getOwnPropertyNames: $getOwnPropertyNames,
        getOwnPropertySymbols: $getOwnPropertySymbols
    });
    var FAILS_ON_PRIMITIVES = $fails(function() {
        $GOPS.f(1)
    });
    $export($export.S + $export.F * FAILS_ON_PRIMITIVES, "Object", {
        getOwnPropertySymbols: function(it) {
            return $GOPS.f(toObject(it))
        }
    }), $JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function() {
        var S = $Symbol();
        return "[null]" != _stringify([S]) || "{}" != _stringify({
            a: S
        }) || "{}" != _stringify(Object(S))
    })), "JSON", {
        stringify: function(it) {
            for (var replacer, $replacer, args = [it], i = 1; arguments.length > i;) args.push(arguments[i++]);
            if ($replacer = replacer = args[1], (isObject(replacer) || void 0 !== it) && !isSymbol(it)) return isArray(replacer) || (replacer = function(key, value) {
                if ("function" == typeof $replacer && (value = $replacer.call(this, key, value)), !isSymbol(value)) return value
            }), args[1] = replacer, _stringify.apply($JSON, args)
        }
    }), $Symbol.prototype[TO_PRIMITIVE] || __webpack_require__(11)($Symbol.prototype, TO_PRIMITIVE, $Symbol.prototype.valueOf), setToStringTag($Symbol, "Symbol"), setToStringTag(Math, "Math", !0), setToStringTag(global.JSON, "JSON", !0)
}, function(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(48)("native-function-to-string", Function.toString)
}, function(module, exports, __webpack_require__) {
    var getKeys = __webpack_require__(34),
        gOPS = __webpack_require__(56),
        pIE = __webpack_require__(50);
    module.exports = function(it) {
        var result = getKeys(it),
            getSymbols = gOPS.f;
        if (getSymbols)
            for (var key, symbols = getSymbols(it), isEnum = pIE.f, i = 0; symbols.length > i;) isEnum.call(it, key = symbols[i++]) && result.push(key);
        return result
    }
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.S, "Object", {
        create: __webpack_require__(36)
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.S + $export.F * !__webpack_require__(7), "Object", {
        defineProperty: __webpack_require__(8).f
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.S + $export.F * !__webpack_require__(7), "Object", {
        defineProperties: __webpack_require__(100)
    })
}, function(module, exports, __webpack_require__) {
    var toIObject = __webpack_require__(15),
        $getOwnPropertyDescriptor = __webpack_require__(16).f;
    __webpack_require__(25)("getOwnPropertyDescriptor", function() {
        return function(it, key) {
            return $getOwnPropertyDescriptor(toIObject(it), key)
        }
    })
}, function(module, exports, __webpack_require__) {
    var toObject = __webpack_require__(9),
        $getPrototypeOf = __webpack_require__(17);
    __webpack_require__(25)("getPrototypeOf", function() {
        return function(it) {
            return $getPrototypeOf(toObject(it))
        }
    })
}, function(module, exports, __webpack_require__) {
    var toObject = __webpack_require__(9),
        $keys = __webpack_require__(34);
    __webpack_require__(25)("keys", function() {
        return function(it) {
            return $keys(toObject(it))
        }
    })
}, function(module, exports, __webpack_require__) {
    __webpack_require__(25)("getOwnPropertyNames", function() {
        return __webpack_require__(101).f
    })
}, function(module, exports, __webpack_require__) {
    var isObject = __webpack_require__(4),
        meta = __webpack_require__(30).onFreeze;
    __webpack_require__(25)("freeze", function($freeze) {
        return function(it) {
            return $freeze && isObject(it) ? $freeze(meta(it)) : it
        }
    })
}, function(module, exports, __webpack_require__) {
    var isObject = __webpack_require__(4),
        meta = __webpack_require__(30).onFreeze;
    __webpack_require__(25)("seal", function($seal) {
        return function(it) {
            return $seal && isObject(it) ? $seal(meta(it)) : it
        }
    })
}, function(module, exports, __webpack_require__) {
    var isObject = __webpack_require__(4),
        meta = __webpack_require__(30).onFreeze;
    __webpack_require__(25)("preventExtensions", function($preventExtensions) {
        return function(it) {
            return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it
        }
    })
}, function(module, exports, __webpack_require__) {
    var isObject = __webpack_require__(4);
    __webpack_require__(25)("isFrozen", function($isFrozen) {
        return function(it) {
            return !isObject(it) || !!$isFrozen && $isFrozen(it)
        }
    })
}, function(module, exports, __webpack_require__) {
    var isObject = __webpack_require__(4);
    __webpack_require__(25)("isSealed", function($isSealed) {
        return function(it) {
            return !isObject(it) || !!$isSealed && $isSealed(it)
        }
    })
}, function(module, exports, __webpack_require__) {
    var isObject = __webpack_require__(4);
    __webpack_require__(25)("isExtensible", function($isExtensible) {
        return function(it) {
            return !!isObject(it) && (!$isExtensible || $isExtensible(it))
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.S + $export.F, "Object", {
        assign: __webpack_require__(102)
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.S, "Object", {
        is: __webpack_require__(103)
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.S, "Object", {
        setPrototypeOf: __webpack_require__(75).set
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var classof = __webpack_require__(45),
        test = {};
    test[__webpack_require__(5)("toStringTag")] = "z", test + "" != "[object z]" && __webpack_require__(12)(Object.prototype, "toString", function() {
        return "[object " + classof(this) + "]"
    }, !0)
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.P, "Function", {
        bind: __webpack_require__(104)
    })
}, function(module, exports, __webpack_require__) {
    var dP = __webpack_require__(8).f,
        FProto = Function.prototype,
        nameRE = /^\s*function ([^ (]*)/;
    "name" in FProto || __webpack_require__(7) && dP(FProto, "name", {
        configurable: !0,
        get: function() {
            try {
                return ("" + this).match(nameRE)[1]
            } catch (e) {
                return ""
            }
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var isObject = __webpack_require__(4),
        getPrototypeOf = __webpack_require__(17),
        HAS_INSTANCE = __webpack_require__(5)("hasInstance"),
        FunctionProto = Function.prototype;
    HAS_INSTANCE in FunctionProto || __webpack_require__(8).f(FunctionProto, HAS_INSTANCE, {
        value: function(O) {
            if ("function" != typeof this || !isObject(O)) return !1;
            if (!isObject(this.prototype)) return O instanceof this;
            for (; O = getPrototypeOf(O);)
                if (this.prototype === O) return !0;
            return !1
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        $parseInt = __webpack_require__(106);
    $export($export.G + $export.F * (parseInt != $parseInt), {
        parseInt: $parseInt
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        $parseFloat = __webpack_require__(107);
    $export($export.G + $export.F * (parseFloat != $parseFloat), {
        parseFloat: $parseFloat
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var global = __webpack_require__(2),
        has = __webpack_require__(14),
        cof = __webpack_require__(20),
        inheritIfRequired = __webpack_require__(77),
        toPrimitive = __webpack_require__(23),
        fails = __webpack_require__(3),
        gOPN = __webpack_require__(37).f,
        gOPD = __webpack_require__(16).f,
        dP = __webpack_require__(8).f,
        $trim = __webpack_require__(46).trim,
        $Number = global.Number,
        Base = $Number,
        proto = $Number.prototype,
        BROKEN_COF = "Number" == cof(__webpack_require__(36)(proto)),
        TRIM = "trim" in String.prototype,
        toNumber = function(argument) {
            var it = toPrimitive(argument, !1);
            if ("string" == typeof it && it.length > 2) {
                var third, radix, maxCode, first = (it = TRIM ? it.trim() : $trim(it, 3)).charCodeAt(0);
                if (43 === first || 45 === first) {
                    if (88 === (third = it.charCodeAt(2)) || 120 === third) return NaN
                } else if (48 === first) {
                    switch (it.charCodeAt(1)) {
                        case 66:
                        case 98:
                            radix = 2, maxCode = 49;
                            break;
                        case 79:
                        case 111:
                            radix = 8, maxCode = 55;
                            break;
                        default:
                            return +it
                    }
                    for (var code, digits = it.slice(2), i = 0, l = digits.length; i < l; i++)
                        if ((code = digits.charCodeAt(i)) < 48 || code > maxCode) return NaN;
                    return parseInt(digits, radix)
                }
            }
            return +it
        };
    if (!$Number(" 0o1") || !$Number("0b1") || $Number("+0x1")) {
        $Number = function(value) {
            var it = arguments.length < 1 ? 0 : value,
                that = this;
            return that instanceof $Number && (BROKEN_COF ? fails(function() {
                proto.valueOf.call(that)
            }) : "Number" != cof(that)) ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it)
        };
        for (var key, keys = __webpack_require__(7) ? gOPN(Base) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","), j = 0; keys.length > j; j++) has(Base, key = keys[j]) && !has($Number, key) && dP($Number, key, gOPD(Base, key));
        $Number.prototype = proto, proto.constructor = $Number, __webpack_require__(12)(global, "Number", $Number)
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        toInteger = __webpack_require__(21),
        aNumberValue = __webpack_require__(108),
        repeat = __webpack_require__(78),
        $toFixed = 1..toFixed,
        floor = Math.floor,
        data = [0, 0, 0, 0, 0, 0],
        ERROR = "Number.toFixed: incorrect invocation!",
        multiply = function(n, c) {
            for (var i = -1, c2 = c; ++i < 6;) c2 += n * data[i], data[i] = c2 % 1e7, c2 = floor(c2 / 1e7)
        },
        divide = function(n) {
            for (var i = 6, c = 0; --i >= 0;) c += data[i], data[i] = floor(c / n), c = c % n * 1e7
        },
        numToString = function() {
            for (var i = 6, s = ""; --i >= 0;)
                if ("" !== s || 0 === i || 0 !== data[i]) {
                    var t = String(data[i]);
                    s = "" === s ? t : s + repeat.call("0", 7 - t.length) + t
                } return s
        },
        pow = function(x, n, acc) {
            return 0 === n ? acc : n % 2 == 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc)
        };
    $export($export.P + $export.F * (!!$toFixed && ("0.000" !== 8e-5.toFixed(3) || "1" !== .9.toFixed(0) || "1.25" !== 1.255.toFixed(2) || "1000000000000000128" !== (0xde0b6b3a7640080).toFixed(0)) || !__webpack_require__(3)(function() {
        $toFixed.call({})
    })), "Number", {
        toFixed: function(fractionDigits) {
            var e, z, j, k, x = aNumberValue(this, ERROR),
                f = toInteger(fractionDigits),
                s = "",
                m = "0";
            if (f < 0 || f > 20) throw RangeError(ERROR);
            if (x != x) return "NaN";
            if (x <= -1e21 || x >= 1e21) return String(x);
            if (x < 0 && (s = "-", x = -x), x > 1e-21)
                if (z = (e = function(x) {
                        for (var n = 0, x2 = x; x2 >= 4096;) n += 12, x2 /= 4096;
                        for (; x2 >= 2;) n += 1, x2 /= 2;
                        return n
                    }(x * pow(2, 69, 1)) - 69) < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1), z *= 4503599627370496, (e = 52 - e) > 0) {
                    for (multiply(0, z), j = f; j >= 7;) multiply(1e7, 0), j -= 7;
                    for (multiply(pow(10, j, 1), 0), j = e - 1; j >= 23;) divide(1 << 23), j -= 23;
                    divide(1 << j), multiply(1, 1), divide(2), m = numToString()
                } else multiply(0, z), multiply(1 << -e, 0), m = numToString() + repeat.call("0", f);
            return m = f > 0 ? s + ((k = m.length) <= f ? "0." + repeat.call("0", f - k) + m : m.slice(0, k - f) + "." + m.slice(k - f)) : s + m
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        $fails = __webpack_require__(3),
        aNumberValue = __webpack_require__(108),
        $toPrecision = 1..toPrecision;
    $export($export.P + $export.F * ($fails(function() {
        return "1" !== $toPrecision.call(1, void 0)
    }) || !$fails(function() {
        $toPrecision.call({})
    })), "Number", {
        toPrecision: function(precision) {
            var that = aNumberValue(this, "Number#toPrecision: incorrect invocation!");
            return void 0 === precision ? $toPrecision.call(that) : $toPrecision.call(that, precision)
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.S, "Number", {
        EPSILON: Math.pow(2, -52)
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        _isFinite = __webpack_require__(2).isFinite;
    $export($export.S, "Number", {
        isFinite: function(it) {
            return "number" == typeof it && _isFinite(it)
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.S, "Number", {
        isInteger: __webpack_require__(109)
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.S, "Number", {
        isNaN: function(number) {
            return number != number
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        isInteger = __webpack_require__(109),
        abs = Math.abs;
    $export($export.S, "Number", {
        isSafeInteger: function(number) {
            return isInteger(number) && abs(number) <= 9007199254740991
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.S, "Number", {
        MAX_SAFE_INTEGER: 9007199254740991
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.S, "Number", {
        MIN_SAFE_INTEGER: -9007199254740991
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        $parseFloat = __webpack_require__(107);
    $export($export.S + $export.F * (Number.parseFloat != $parseFloat), "Number", {
        parseFloat: $parseFloat
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        $parseInt = __webpack_require__(106);
    $export($export.S + $export.F * (Number.parseInt != $parseInt), "Number", {
        parseInt: $parseInt
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        log1p = __webpack_require__(110),
        sqrt = Math.sqrt,
        $acosh = Math.acosh;
    $export($export.S + $export.F * !($acosh && 710 == Math.floor($acosh(Number.MAX_VALUE)) && $acosh(1 / 0) == 1 / 0), "Math", {
        acosh: function(x) {
            return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? Math.log(x) + Math.LN2 : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1))
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        $asinh = Math.asinh;
    $export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), "Math", {
        asinh: function asinh(x) {
            return isFinite(x = +x) && 0 != x ? x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1)) : x
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        $atanh = Math.atanh;
    $export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), "Math", {
        atanh: function(x) {
            return 0 == (x = +x) ? x : Math.log((1 + x) / (1 - x)) / 2
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        sign = __webpack_require__(79);
    $export($export.S, "Math", {
        cbrt: function(x) {
            return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3)
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.S, "Math", {
        clz32: function(x) {
            return (x >>>= 0) ? 31 - Math.floor(Math.log(x + .5) * Math.LOG2E) : 32
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        exp = Math.exp;
    $export($export.S, "Math", {
        cosh: function(x) {
            return (exp(x = +x) + exp(-x)) / 2
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        $expm1 = __webpack_require__(80);
    $export($export.S + $export.F * ($expm1 != Math.expm1), "Math", {
        expm1: $expm1
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.S, "Math", {
        fround: __webpack_require__(111)
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        abs = Math.abs;
    $export($export.S, "Math", {
        hypot: function(value1, value2) {
            for (var arg, div, sum = 0, i = 0, aLen = arguments.length, larg = 0; i < aLen;) larg < (arg = abs(arguments[i++])) ? (sum = sum * (div = larg / arg) * div + 1, larg = arg) : sum += arg > 0 ? (div = arg / larg) * div : arg;
            return larg === 1 / 0 ? 1 / 0 : larg * Math.sqrt(sum)
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        $imul = Math.imul;
    $export($export.S + $export.F * __webpack_require__(3)(function() {
        return -5 != $imul(4294967295, 5) || 2 != $imul.length
    }), "Math", {
        imul: function(x, y) {
            var xn = +x,
                yn = +y,
                xl = 65535 & xn,
                yl = 65535 & yn;
            return 0 | xl * yl + ((65535 & xn >>> 16) * yl + xl * (65535 & yn >>> 16) << 16 >>> 0)
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.S, "Math", {
        log10: function(x) {
            return Math.log(x) * Math.LOG10E
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.S, "Math", {
        log1p: __webpack_require__(110)
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.S, "Math", {
        log2: function(x) {
            return Math.log(x) / Math.LN2
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.S, "Math", {
        sign: __webpack_require__(79)
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        expm1 = __webpack_require__(80),
        exp = Math.exp;
    $export($export.S + $export.F * __webpack_require__(3)(function() {
        return -2e-17 != !Math.sinh(-2e-17)
    }), "Math", {
        sinh: function(x) {
            return Math.abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2)
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        expm1 = __webpack_require__(80),
        exp = Math.exp;
    $export($export.S, "Math", {
        tanh: function(x) {
            var a = expm1(x = +x),
                b = expm1(-x);
            return a == 1 / 0 ? 1 : b == 1 / 0 ? -1 : (a - b) / (exp(x) + exp(-x))
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.S, "Math", {
        trunc: function(it) {
            return (it > 0 ? Math.floor : Math.ceil)(it)
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        toAbsoluteIndex = __webpack_require__(35),
        fromCharCode = String.fromCharCode,
        $fromCodePoint = String.fromCodePoint;
    $export($export.S + $export.F * (!!$fromCodePoint && 1 != $fromCodePoint.length), "String", {
        fromCodePoint: function(x) {
            for (var code, res = [], aLen = arguments.length, i = 0; aLen > i;) {
                if (code = +arguments[i++], toAbsoluteIndex(code, 1114111) !== code) throw RangeError(code + " is not a valid code point");
                res.push(code < 65536 ? fromCharCode(code) : fromCharCode(55296 + ((code -= 65536) >> 10), code % 1024 + 56320))
            }
            return res.join("")
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        toIObject = __webpack_require__(15),
        toLength = __webpack_require__(6);
    $export($export.S, "String", {
        raw: function(callSite) {
            for (var tpl = toIObject(callSite.raw), len = toLength(tpl.length), aLen = arguments.length, res = [], i = 0; len > i;) res.push(String(tpl[i++])), i < aLen && res.push(String(arguments[i]));
            return res.join("")
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    __webpack_require__(46)("trim", function($trim) {
        return function() {
            return $trim(this, 3)
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $at = __webpack_require__(58)(!0);
    __webpack_require__(81)(String, "String", function(iterated) {
        this._t = String(iterated), this._i = 0
    }, function() {
        var point, O = this._t,
            index = this._i;
        return index >= O.length ? {
            value: void 0,
            done: !0
        } : (point = $at(O, index), this._i += point.length, {
            value: point,
            done: !1
        })
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        $at = __webpack_require__(58)(!1);
    $export($export.P, "String", {
        codePointAt: function(pos) {
            return $at(this, pos)
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        toLength = __webpack_require__(6),
        context = __webpack_require__(83),
        $endsWith = "".endsWith;
    $export($export.P + $export.F * __webpack_require__(84)("endsWith"), "String", {
        endsWith: function(searchString) {
            var that = context(this, searchString, "endsWith"),
                endPosition = arguments.length > 1 ? arguments[1] : void 0,
                len = toLength(that.length),
                end = void 0 === endPosition ? len : Math.min(toLength(endPosition), len),
                search = String(searchString);
            return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        context = __webpack_require__(83);
    $export($export.P + $export.F * __webpack_require__(84)("includes"), "String", {
        includes: function(searchString) {
            return !!~context(this, searchString, "includes").indexOf(searchString, arguments.length > 1 ? arguments[1] : void 0)
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.P, "String", {
        repeat: __webpack_require__(78)
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        toLength = __webpack_require__(6),
        context = __webpack_require__(83),
        $startsWith = "".startsWith;
    $export($export.P + $export.F * __webpack_require__(84)("startsWith"), "String", {
        startsWith: function(searchString) {
            var that = context(this, searchString, "startsWith"),
                index = toLength(Math.min(arguments.length > 1 ? arguments[1] : void 0, that.length)),
                search = String(searchString);
            return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    __webpack_require__(13)("anchor", function(createHTML) {
        return function(name) {
            return createHTML(this, "a", "name", name)
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    __webpack_require__(13)("big", function(createHTML) {
        return function() {
            return createHTML(this, "big", "", "")
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    __webpack_require__(13)("blink", function(createHTML) {
        return function() {
            return createHTML(this, "blink", "", "")
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    __webpack_require__(13)("bold", function(createHTML) {
        return function() {
            return createHTML(this, "b", "", "")
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    __webpack_require__(13)("fixed", function(createHTML) {
        return function() {
            return createHTML(this, "tt", "", "")
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    __webpack_require__(13)("fontcolor", function(createHTML) {
        return function(color) {
            return createHTML(this, "font", "color", color)
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    __webpack_require__(13)("fontsize", function(createHTML) {
        return function(size) {
            return createHTML(this, "font", "size", size)
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    __webpack_require__(13)("italics", function(createHTML) {
        return function() {
            return createHTML(this, "i", "", "")
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    __webpack_require__(13)("link", function(createHTML) {
        return function(url) {
            return createHTML(this, "a", "href", url)
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    __webpack_require__(13)("small", function(createHTML) {
        return function() {
            return createHTML(this, "small", "", "")
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    __webpack_require__(13)("strike", function(createHTML) {
        return function() {
            return createHTML(this, "strike", "", "")
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    __webpack_require__(13)("sub", function(createHTML) {
        return function() {
            return createHTML(this, "sub", "", "")
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    __webpack_require__(13)("sup", function(createHTML) {
        return function() {
            return createHTML(this, "sup", "", "")
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.S, "Date", {
        now: function() {
            return (new Date).getTime()
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        toObject = __webpack_require__(9),
        toPrimitive = __webpack_require__(23);
    $export($export.P + $export.F * __webpack_require__(3)(function() {
        return null !== new Date(NaN).toJSON() || 1 !== Date.prototype.toJSON.call({
            toISOString: function() {
                return 1
            }
        })
    }), "Date", {
        toJSON: function(key) {
            var O = toObject(this),
                pv = toPrimitive(O);
            return "number" != typeof pv || isFinite(pv) ? O.toISOString() : null
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        toISOString = __webpack_require__(216);
    $export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), "Date", {
        toISOString: toISOString
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var fails = __webpack_require__(3),
        getTime = Date.prototype.getTime,
        $toISOString = Date.prototype.toISOString,
        lz = function(num) {
            return num > 9 ? num : "0" + num
        };
    module.exports = fails(function() {
        return "0385-07-25T07:06:39.999Z" != $toISOString.call(new Date(-5e13 - 1))
    }) || !fails(function() {
        $toISOString.call(new Date(NaN))
    }) ? function() {
        if (!isFinite(getTime.call(this))) throw RangeError("Invalid time value");
        var d = this,
            y = d.getUTCFullYear(),
            m = d.getUTCMilliseconds(),
            s = y < 0 ? "-" : y > 9999 ? "+" : "";
        return s + ("00000" + Math.abs(y)).slice(s ? -6 : -4) + "-" + lz(d.getUTCMonth() + 1) + "-" + lz(d.getUTCDate()) + "T" + lz(d.getUTCHours()) + ":" + lz(d.getUTCMinutes()) + ":" + lz(d.getUTCSeconds()) + "." + (m > 99 ? m : "0" + lz(m)) + "Z"
    } : $toISOString
}, function(module, exports, __webpack_require__) {
    var DateProto = Date.prototype,
        $toString = DateProto.toString,
        getTime = DateProto.getTime;
    new Date(NaN) + "" != "Invalid Date" && __webpack_require__(12)(DateProto, "toString", function() {
        var value = getTime.call(this);
        return value == value ? $toString.call(this) : "Invalid Date"
    })
}, function(module, exports, __webpack_require__) {
    var TO_PRIMITIVE = __webpack_require__(5)("toPrimitive"),
        proto = Date.prototype;
    TO_PRIMITIVE in proto || __webpack_require__(11)(proto, TO_PRIMITIVE, __webpack_require__(219))
}, function(module, exports, __webpack_require__) {
    "use strict";
    var anObject = __webpack_require__(1),
        toPrimitive = __webpack_require__(23);
    module.exports = function(hint) {
        if ("string" !== hint && "number" !== hint && "default" !== hint) throw TypeError("Incorrect hint");
        return toPrimitive(anObject(this), "number" != hint)
    }
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.S, "Array", {
        isArray: __webpack_require__(57)
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var ctx = __webpack_require__(19),
        $export = __webpack_require__(0),
        toObject = __webpack_require__(9),
        call = __webpack_require__(112),
        isArrayIter = __webpack_require__(85),
        toLength = __webpack_require__(6),
        createProperty = __webpack_require__(86),
        getIterFn = __webpack_require__(87);
    $export($export.S + $export.F * !__webpack_require__(60)(function(iter) {
        Array.from(iter)
    }), "Array", {
        from: function(arrayLike) {
            var length, result, step, iterator, O = toObject(arrayLike),
                C = "function" == typeof this ? this : Array,
                aLen = arguments.length,
                mapfn = aLen > 1 ? arguments[1] : void 0,
                mapping = void 0 !== mapfn,
                index = 0,
                iterFn = getIterFn(O);
            if (mapping && (mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : void 0, 2)), void 0 == iterFn || C == Array && isArrayIter(iterFn))
                for (result = new C(length = toLength(O.length)); length > index; index++) createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
            else
                for (iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++) createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], !0) : step.value);
            return result.length = index, result
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        createProperty = __webpack_require__(86);
    $export($export.S + $export.F * __webpack_require__(3)(function() {
        function F() {}
        return !(Array.of.call(F) instanceof F)
    }), "Array", {
        of: function() {
            for (var index = 0, aLen = arguments.length, result = new("function" == typeof this ? this : Array)(aLen); aLen > index;) createProperty(result, index, arguments[index++]);
            return result.length = aLen, result
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        toIObject = __webpack_require__(15),
        arrayJoin = [].join;
    $export($export.P + $export.F * (__webpack_require__(49) != Object || !__webpack_require__(22)(arrayJoin)), "Array", {
        join: function(separator) {
            return arrayJoin.call(toIObject(this), void 0 === separator ? "," : separator)
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        html = __webpack_require__(74),
        cof = __webpack_require__(20),
        toAbsoluteIndex = __webpack_require__(35),
        toLength = __webpack_require__(6),
        arraySlice = [].slice;
    $export($export.P + $export.F * __webpack_require__(3)(function() {
        html && arraySlice.call(html)
    }), "Array", {
        slice: function(begin, end) {
            var len = toLength(this.length),
                klass = cof(this);
            if (end = void 0 === end ? len : end, "Array" == klass) return arraySlice.call(this, begin, end);
            for (var start = toAbsoluteIndex(begin, len), upTo = toAbsoluteIndex(end, len), size = toLength(upTo - start), cloned = new Array(size), i = 0; i < size; i++) cloned[i] = "String" == klass ? this.charAt(start + i) : this[start + i];
            return cloned
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        aFunction = __webpack_require__(10),
        toObject = __webpack_require__(9),
        fails = __webpack_require__(3),
        $sort = [].sort,
        test = [1, 2, 3];
    $export($export.P + $export.F * (fails(function() {
        test.sort(void 0)
    }) || !fails(function() {
        test.sort(null)
    }) || !__webpack_require__(22)($sort)), "Array", {
        sort: function(comparefn) {
            return void 0 === comparefn ? $sort.call(toObject(this)) : $sort.call(toObject(this), aFunction(comparefn))
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        $forEach = __webpack_require__(26)(0),
        STRICT = __webpack_require__(22)([].forEach, !0);
    $export($export.P + $export.F * !STRICT, "Array", {
        forEach: function(callbackfn) {
            return $forEach(this, callbackfn, arguments[1])
        }
    })
}, function(module, exports, __webpack_require__) {
    var isObject = __webpack_require__(4),
        isArray = __webpack_require__(57),
        SPECIES = __webpack_require__(5)("species");
    module.exports = function(original) {
        var C;
        return isArray(original) && ("function" != typeof(C = original.constructor) || C !== Array && !isArray(C.prototype) || (C = void 0), isObject(C) && null === (C = C[SPECIES]) && (C = void 0)), void 0 === C ? Array : C
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        $map = __webpack_require__(26)(1);
    $export($export.P + $export.F * !__webpack_require__(22)([].map, !0), "Array", {
        map: function(callbackfn) {
            return $map(this, callbackfn, arguments[1])
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        $filter = __webpack_require__(26)(2);
    $export($export.P + $export.F * !__webpack_require__(22)([].filter, !0), "Array", {
        filter: function(callbackfn) {
            return $filter(this, callbackfn, arguments[1])
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        $some = __webpack_require__(26)(3);
    $export($export.P + $export.F * !__webpack_require__(22)([].some, !0), "Array", {
        some: function(callbackfn) {
            return $some(this, callbackfn, arguments[1])
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        $every = __webpack_require__(26)(4);
    $export($export.P + $export.F * !__webpack_require__(22)([].every, !0), "Array", {
        every: function(callbackfn) {
            return $every(this, callbackfn, arguments[1])
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        $reduce = __webpack_require__(113);
    $export($export.P + $export.F * !__webpack_require__(22)([].reduce, !0), "Array", {
        reduce: function(callbackfn) {
            return $reduce(this, callbackfn, arguments.length, arguments[1], !1)
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        $reduce = __webpack_require__(113);
    $export($export.P + $export.F * !__webpack_require__(22)([].reduceRight, !0), "Array", {
        reduceRight: function(callbackfn) {
            return $reduce(this, callbackfn, arguments.length, arguments[1], !0)
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        $indexOf = __webpack_require__(55)(!1),
        $native = [].indexOf,
        NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;
    $export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(22)($native)), "Array", {
        indexOf: function(searchElement) {
            return NEGATIVE_ZERO ? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1])
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        toIObject = __webpack_require__(15),
        toInteger = __webpack_require__(21),
        toLength = __webpack_require__(6),
        $native = [].lastIndexOf,
        NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;
    $export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(22)($native)), "Array", {
        lastIndexOf: function(searchElement) {
            if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
            var O = toIObject(this),
                length = toLength(O.length),
                index = length - 1;
            for (arguments.length > 1 && (index = Math.min(index, toInteger(arguments[1]))), index < 0 && (index = length + index); index >= 0; index--)
                if (index in O && O[index] === searchElement) return index || 0;
            return -1
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.P, "Array", {
        copyWithin: __webpack_require__(114)
    }), __webpack_require__(31)("copyWithin")
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.P, "Array", {
        fill: __webpack_require__(89)
    }), __webpack_require__(31)("fill")
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        $find = __webpack_require__(26)(5),
        forced = !0;
    "find" in [] && Array(1).find(function() {
        forced = !1
    }), $export($export.P + $export.F * forced, "Array", {
        find: function(callbackfn) {
            return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0)
        }
    }), __webpack_require__(31)("find")
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        $find = __webpack_require__(26)(6),
        KEY = "findIndex",
        forced = !0;
    KEY in [] && Array(1)[KEY](function() {
        forced = !1
    }), $export($export.P + $export.F * forced, "Array", {
        findIndex: function(callbackfn) {
            return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0)
        }
    }), __webpack_require__(31)(KEY)
}, function(module, exports, __webpack_require__) {
    __webpack_require__(38)("Array")
}, function(module, exports, __webpack_require__) {
    var global = __webpack_require__(2),
        inheritIfRequired = __webpack_require__(77),
        dP = __webpack_require__(8).f,
        gOPN = __webpack_require__(37).f,
        isRegExp = __webpack_require__(59),
        $flags = __webpack_require__(51),
        $RegExp = global.RegExp,
        Base = $RegExp,
        proto = $RegExp.prototype,
        re1 = /a/g,
        re2 = /a/g,
        CORRECT_NEW = new $RegExp(re1) !== re1;
    if (__webpack_require__(7) && (!CORRECT_NEW || __webpack_require__(3)(function() {
            return re2[__webpack_require__(5)("match")] = !1, $RegExp(re1) != re1 || $RegExp(re2) == re2 || "/a/i" != $RegExp(re1, "i")
        }))) {
        $RegExp = function(p, f) {
            var tiRE = this instanceof $RegExp,
                piRE = isRegExp(p),
                fiU = void 0 === f;
            return !tiRE && piRE && p.constructor === $RegExp && fiU ? p : inheritIfRequired(CORRECT_NEW ? new Base(piRE && !fiU ? p.source : p, f) : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f), tiRE ? this : proto, $RegExp)
        };
        for (var proxy = function(key) {
                key in $RegExp || dP($RegExp, key, {
                    configurable: !0,
                    get: function() {
                        return Base[key]
                    },
                    set: function(it) {
                        Base[key] = it
                    }
                })
            }, keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
        proto.constructor = $RegExp, $RegExp.prototype = proto, __webpack_require__(12)(global, "RegExp", $RegExp)
    }
    __webpack_require__(38)("RegExp")
}, function(module, exports, __webpack_require__) {
    "use strict";
    __webpack_require__(117);
    var anObject = __webpack_require__(1),
        $flags = __webpack_require__(51),
        DESCRIPTORS = __webpack_require__(7),
        $toString = /./.toString,
        define = function(fn) {
            __webpack_require__(12)(RegExp.prototype, "toString", fn, !0)
        };
    __webpack_require__(3)(function() {
        return "/a/b" != $toString.call({
            source: "a",
            flags: "b"
        })
    }) ? define(function() {
        var R = anObject(this);
        return "/".concat(R.source, "/", "flags" in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : void 0)
    }) : "toString" != $toString.name && define(function() {
        return $toString.call(this)
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var anObject = __webpack_require__(1),
        toLength = __webpack_require__(6),
        advanceStringIndex = __webpack_require__(92),
        regExpExec = __webpack_require__(61);
    __webpack_require__(62)("match", 1, function(defined, MATCH, $match, maybeCallNative) {
        return [function(regexp) {
            var O = defined(this),
                fn = void 0 == regexp ? void 0 : regexp[MATCH];
            return void 0 !== fn ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O))
        }, function(regexp) {
            var res = maybeCallNative($match, regexp, this);
            if (res.done) return res.value;
            var rx = anObject(regexp),
                S = String(this);
            if (!rx.global) return regExpExec(rx, S);
            var fullUnicode = rx.unicode;
            rx.lastIndex = 0;
            for (var result, A = [], n = 0; null !== (result = regExpExec(rx, S));) {
                var matchStr = String(result[0]);
                A[n] = matchStr, "" === matchStr && (rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode)), n++
            }
            return 0 === n ? null : A
        }]
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var anObject = __webpack_require__(1),
        toObject = __webpack_require__(9),
        toLength = __webpack_require__(6),
        toInteger = __webpack_require__(21),
        advanceStringIndex = __webpack_require__(92),
        regExpExec = __webpack_require__(61),
        max = Math.max,
        min = Math.min,
        floor = Math.floor,
        SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g,
        SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;
    __webpack_require__(62)("replace", 2, function(defined, REPLACE, $replace, maybeCallNative) {
        return [function(searchValue, replaceValue) {
            var O = defined(this),
                fn = void 0 == searchValue ? void 0 : searchValue[REPLACE];
            return void 0 !== fn ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue)
        }, function(regexp, replaceValue) {
            var res = maybeCallNative($replace, regexp, this, replaceValue);
            if (res.done) return res.value;
            var rx = anObject(regexp),
                S = String(this),
                functionalReplace = "function" == typeof replaceValue;
            functionalReplace || (replaceValue = String(replaceValue));
            var global = rx.global;
            if (global) {
                var fullUnicode = rx.unicode;
                rx.lastIndex = 0
            }
            for (var results = [];;) {
                var result = regExpExec(rx, S);
                if (null === result) break;
                if (results.push(result), !global) break;
                "" === String(result[0]) && (rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode))
            }
            for (var it, accumulatedResult = "", nextSourcePosition = 0, i = 0; i < results.length; i++) {
                result = results[i];
                for (var matched = String(result[0]), position = max(min(toInteger(result.index), S.length), 0), captures = [], j = 1; j < result.length; j++) captures.push(void 0 === (it = result[j]) ? it : String(it));
                var namedCaptures = result.groups;
                if (functionalReplace) {
                    var replacerArgs = [matched].concat(captures, position, S);
                    void 0 !== namedCaptures && replacerArgs.push(namedCaptures);
                    var replacement = String(replaceValue.apply(void 0, replacerArgs))
                } else replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
                position >= nextSourcePosition && (accumulatedResult += S.slice(nextSourcePosition, position) + replacement, nextSourcePosition = position + matched.length)
            }
            return accumulatedResult + S.slice(nextSourcePosition)
        }];

        function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
            var tailPos = position + matched.length,
                m = captures.length,
                symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
            return void 0 !== namedCaptures && (namedCaptures = toObject(namedCaptures), symbols = SUBSTITUTION_SYMBOLS), $replace.call(replacement, symbols, function(match, ch) {
                var capture;
                switch (ch.charAt(0)) {
                    case "$":
                        return "$";
                    case "&":
                        return matched;
                    case "`":
                        return str.slice(0, position);
                    case "'":
                        return str.slice(tailPos);
                    case "<":
                        capture = namedCaptures[ch.slice(1, -1)];
                        break;
                    default:
                        var n = +ch;
                        if (0 === n) return match;
                        if (n > m) {
                            var f = floor(n / 10);
                            return 0 === f ? match : f <= m ? void 0 === captures[f - 1] ? ch.charAt(1) : captures[f - 1] + ch.charAt(1) : match
                        }
                        capture = captures[n - 1]
                }
                return void 0 === capture ? "" : capture
            })
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var anObject = __webpack_require__(1),
        sameValue = __webpack_require__(103),
        regExpExec = __webpack_require__(61);
    __webpack_require__(62)("search", 1, function(defined, SEARCH, $search, maybeCallNative) {
        return [function(regexp) {
            var O = defined(this),
                fn = void 0 == regexp ? void 0 : regexp[SEARCH];
            return void 0 !== fn ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O))
        }, function(regexp) {
            var res = maybeCallNative($search, regexp, this);
            if (res.done) return res.value;
            var rx = anObject(regexp),
                S = String(this),
                previousLastIndex = rx.lastIndex;
            sameValue(previousLastIndex, 0) || (rx.lastIndex = 0);
            var result = regExpExec(rx, S);
            return sameValue(rx.lastIndex, previousLastIndex) || (rx.lastIndex = previousLastIndex), null === result ? -1 : result.index
        }]
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var isRegExp = __webpack_require__(59),
        anObject = __webpack_require__(1),
        speciesConstructor = __webpack_require__(52),
        advanceStringIndex = __webpack_require__(92),
        toLength = __webpack_require__(6),
        callRegExpExec = __webpack_require__(61),
        regexpExec = __webpack_require__(91),
        fails = __webpack_require__(3),
        $min = Math.min,
        $push = [].push,
        SUPPORTS_Y = !fails(function() {
            RegExp(4294967295, "y")
        });
    __webpack_require__(62)("split", 2, function(defined, SPLIT, $split, maybeCallNative) {
        var internalSplit;
        return internalSplit = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function(separator, limit) {
            var string = String(this);
            if (void 0 === separator && 0 === limit) return [];
            if (!isRegExp(separator)) return $split.call(string, separator, limit);
            for (var match, lastIndex, lastLength, output = [], flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.unicode ? "u" : "") + (separator.sticky ? "y" : ""), lastLastIndex = 0, splitLimit = void 0 === limit ? 4294967295 : limit >>> 0, separatorCopy = new RegExp(separator.source, flags + "g");
                (match = regexpExec.call(separatorCopy, string)) && !((lastIndex = separatorCopy.lastIndex) > lastLastIndex && (output.push(string.slice(lastLastIndex, match.index)), match.length > 1 && match.index < string.length && $push.apply(output, match.slice(1)), lastLength = match[0].length, lastLastIndex = lastIndex, output.length >= splitLimit));) separatorCopy.lastIndex === match.index && separatorCopy.lastIndex++;
            return lastLastIndex === string.length ? !lastLength && separatorCopy.test("") || output.push("") : output.push(string.slice(lastLastIndex)), output.length > splitLimit ? output.slice(0, splitLimit) : output
        } : "0".split(void 0, 0).length ? function(separator, limit) {
            return void 0 === separator && 0 === limit ? [] : $split.call(this, separator, limit)
        } : $split, [function(separator, limit) {
            var O = defined(this),
                splitter = void 0 == separator ? void 0 : separator[SPLIT];
            return void 0 !== splitter ? splitter.call(separator, O, limit) : internalSplit.call(String(O), separator, limit)
        }, function(regexp, limit) {
            var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
            if (res.done) return res.value;
            var rx = anObject(regexp),
                S = String(this),
                C = speciesConstructor(rx, RegExp),
                unicodeMatching = rx.unicode,
                flags = (rx.ignoreCase ? "i" : "") + (rx.multiline ? "m" : "") + (rx.unicode ? "u" : "") + (SUPPORTS_Y ? "y" : "g"),
                splitter = new C(SUPPORTS_Y ? rx : "^(?:" + rx.source + ")", flags),
                lim = void 0 === limit ? 4294967295 : limit >>> 0;
            if (0 === lim) return [];
            if (0 === S.length) return null === callRegExpExec(splitter, S) ? [S] : [];
            for (var p = 0, q = 0, A = []; q < S.length;) {
                splitter.lastIndex = SUPPORTS_Y ? q : 0;
                var e, z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
                if (null === z || (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p) q = advanceStringIndex(S, q, unicodeMatching);
                else {
                    if (A.push(S.slice(p, q)), A.length === lim) return A;
                    for (var i = 1; i <= z.length - 1; i++)
                        if (A.push(z[i]), A.length === lim) return A;
                    q = p = e
                }
            }
            return A.push(S.slice(p)), A
        }]
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper, LIBRARY = __webpack_require__(29),
        global = __webpack_require__(2),
        ctx = __webpack_require__(19),
        classof = __webpack_require__(45),
        $export = __webpack_require__(0),
        isObject = __webpack_require__(4),
        aFunction = __webpack_require__(10),
        anInstance = __webpack_require__(39),
        forOf = __webpack_require__(40),
        speciesConstructor = __webpack_require__(52),
        task = __webpack_require__(93).set,
        microtask = __webpack_require__(94)(),
        newPromiseCapabilityModule = __webpack_require__(95),
        perform = __webpack_require__(118),
        userAgent = __webpack_require__(63),
        promiseResolve = __webpack_require__(119),
        TypeError = global.TypeError,
        process = global.process,
        versions = process && process.versions,
        v8 = versions && versions.v8 || "",
        $Promise = global.Promise,
        isNode = "process" == classof(process),
        empty = function() {},
        newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f,
        USE_NATIVE = !! function() {
            try {
                var promise = $Promise.resolve(1),
                    FakePromise = (promise.constructor = {})[__webpack_require__(5)("species")] = function(exec) {
                        exec(empty, empty)
                    };
                return (isNode || "function" == typeof PromiseRejectionEvent) && promise.then(empty) instanceof FakePromise && 0 !== v8.indexOf("6.6") && -1 === userAgent.indexOf("Chrome/66")
            } catch (e) {}
        }(),
        isThenable = function(it) {
            var then;
            return !(!isObject(it) || "function" != typeof(then = it.then)) && then
        },
        notify = function(promise, isReject) {
            if (!promise._n) {
                promise._n = !0;
                var chain = promise._c;
                microtask(function() {
                    for (var value = promise._v, ok = 1 == promise._s, i = 0, run = function(reaction) {
                            var result, then, exited, handler = ok ? reaction.ok : reaction.fail,
                                resolve = reaction.resolve,
                                reject = reaction.reject,
                                domain = reaction.domain;
                            try {
                                handler ? (ok || (2 == promise._h && onHandleUnhandled(promise), promise._h = 1), !0 === handler ? result = value : (domain && domain.enter(), result = handler(value), domain && (domain.exit(), exited = !0)), result === reaction.promise ? reject(TypeError("Promise-chain cycle")) : (then = isThenable(result)) ? then.call(result, resolve, reject) : resolve(result)) : reject(value)
                            } catch (e) {
                                domain && !exited && domain.exit(), reject(e)
                            }
                        }; chain.length > i;) run(chain[i++]);
                    promise._c = [], promise._n = !1, isReject && !promise._h && onUnhandled(promise)
                })
            }
        },
        onUnhandled = function(promise) {
            task.call(global, function() {
                var result, handler, console, value = promise._v,
                    unhandled = isUnhandled(promise);
                if (unhandled && (result = perform(function() {
                        isNode ? process.emit("unhandledRejection", value, promise) : (handler = global.onunhandledrejection) ? handler({
                            promise: promise,
                            reason: value
                        }) : (console = global.console) && console.error && console.error("Unhandled promise rejection", value)
                    }), promise._h = isNode || isUnhandled(promise) ? 2 : 1), promise._a = void 0, unhandled && result.e) throw result.v
            })
        },
        isUnhandled = function(promise) {
            return 1 !== promise._h && 0 === (promise._a || promise._c).length
        },
        onHandleUnhandled = function(promise) {
            task.call(global, function() {
                var handler;
                isNode ? process.emit("rejectionHandled", promise) : (handler = global.onrejectionhandled) && handler({
                    promise: promise,
                    reason: promise._v
                })
            })
        },
        $reject = function(value) {
            var promise = this;
            promise._d || (promise._d = !0, (promise = promise._w || promise)._v = value, promise._s = 2, promise._a || (promise._a = promise._c.slice()), notify(promise, !0))
        },
        $resolve = function(value) {
            var then, promise = this;
            if (!promise._d) {
                promise._d = !0, promise = promise._w || promise;
                try {
                    if (promise === value) throw TypeError("Promise can't be resolved itself");
                    (then = isThenable(value)) ? microtask(function() {
                        var wrapper = {
                            _w: promise,
                            _d: !1
                        };
                        try {
                            then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1))
                        } catch (e) {
                            $reject.call(wrapper, e)
                        }
                    }): (promise._v = value, promise._s = 1, notify(promise, !1))
                } catch (e) {
                    $reject.call({
                        _w: promise,
                        _d: !1
                    }, e)
                }
            }
        };
    USE_NATIVE || ($Promise = function(executor) {
        anInstance(this, $Promise, "Promise", "_h"), aFunction(executor), Internal.call(this);
        try {
            executor(ctx($resolve, this, 1), ctx($reject, this, 1))
        } catch (err) {
            $reject.call(this, err)
        }
    }, (Internal = function(executor) {
        this._c = [], this._a = void 0, this._s = 0, this._d = !1, this._v = void 0, this._h = 0, this._n = !1
    }).prototype = __webpack_require__(41)($Promise.prototype, {
        then: function(onFulfilled, onRejected) {
            var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
            return reaction.ok = "function" != typeof onFulfilled || onFulfilled, reaction.fail = "function" == typeof onRejected && onRejected, reaction.domain = isNode ? process.domain : void 0, this._c.push(reaction), this._a && this._a.push(reaction), this._s && notify(this, !1), reaction.promise
        },
        catch: function(onRejected) {
            return this.then(void 0, onRejected)
        }
    }), OwnPromiseCapability = function() {
        var promise = new Internal;
        this.promise = promise, this.resolve = ctx($resolve, promise, 1), this.reject = ctx($reject, promise, 1)
    }, newPromiseCapabilityModule.f = newPromiseCapability = function(C) {
        return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C)
    }), $export($export.G + $export.W + $export.F * !USE_NATIVE, {
        Promise: $Promise
    }), __webpack_require__(44)($Promise, "Promise"), __webpack_require__(38)("Promise"), Wrapper = __webpack_require__(18).Promise, $export($export.S + $export.F * !USE_NATIVE, "Promise", {
        reject: function(r) {
            var capability = newPromiseCapability(this);
            return (0, capability.reject)(r), capability.promise
        }
    }), $export($export.S + $export.F * (LIBRARY || !USE_NATIVE), "Promise", {
        resolve: function(x) {
            return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x)
        }
    }), $export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(60)(function(iter) {
        $Promise.all(iter).catch(empty)
    })), "Promise", {
        all: function(iterable) {
            var C = this,
                capability = newPromiseCapability(C),
                resolve = capability.resolve,
                reject = capability.reject,
                result = perform(function() {
                    var values = [],
                        index = 0,
                        remaining = 1;
                    forOf(iterable, !1, function(promise) {
                        var $index = index++,
                            alreadyCalled = !1;
                        values.push(void 0), remaining++, C.resolve(promise).then(function(value) {
                            alreadyCalled || (alreadyCalled = !0, values[$index] = value, --remaining || resolve(values))
                        }, reject)
                    }), --remaining || resolve(values)
                });
            return result.e && reject(result.v), capability.promise
        },
        race: function(iterable) {
            var C = this,
                capability = newPromiseCapability(C),
                reject = capability.reject,
                result = perform(function() {
                    forOf(iterable, !1, function(promise) {
                        C.resolve(promise).then(capability.resolve, reject)
                    })
                });
            return result.e && reject(result.v), capability.promise
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var weak = __webpack_require__(124),
        validate = __webpack_require__(42);
    __webpack_require__(64)("WeakSet", function(get) {
        return function() {
            return get(this, arguments.length > 0 ? arguments[0] : void 0)
        }
    }, {
        add: function(value) {
            return weak.def(validate(this, "WeakSet"), value, !0)
        }
    }, weak, !1, !0)
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        $typed = __webpack_require__(65),
        buffer = __webpack_require__(96),
        anObject = __webpack_require__(1),
        toAbsoluteIndex = __webpack_require__(35),
        toLength = __webpack_require__(6),
        isObject = __webpack_require__(4),
        ArrayBuffer = __webpack_require__(2).ArrayBuffer,
        speciesConstructor = __webpack_require__(52),
        $ArrayBuffer = buffer.ArrayBuffer,
        $DataView = buffer.DataView,
        $isView = $typed.ABV && ArrayBuffer.isView,
        $slice = $ArrayBuffer.prototype.slice,
        VIEW = $typed.VIEW;
    $export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), {
        ArrayBuffer: $ArrayBuffer
    }), $export($export.S + $export.F * !$typed.CONSTR, "ArrayBuffer", {
        isView: function(it) {
            return $isView && $isView(it) || isObject(it) && VIEW in it
        }
    }), $export($export.P + $export.U + $export.F * __webpack_require__(3)(function() {
        return !new $ArrayBuffer(2).slice(1, void 0).byteLength
    }), "ArrayBuffer", {
        slice: function(start, end) {
            if (void 0 !== $slice && void 0 === end) return $slice.call(anObject(this), start);
            for (var len = anObject(this).byteLength, first = toAbsoluteIndex(start, len), fin = toAbsoluteIndex(void 0 === end ? len : end, len), result = new(speciesConstructor(this, $ArrayBuffer))(toLength(fin - first)), viewS = new $DataView(this), viewT = new $DataView(result), index = 0; first < fin;) viewT.setUint8(index++, viewS.getUint8(first++));
            return result
        }
    }), __webpack_require__(38)("ArrayBuffer")
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.G + $export.W + $export.F * !__webpack_require__(65).ABV, {
        DataView: __webpack_require__(96).DataView
    })
}, function(module, exports, __webpack_require__) {
    __webpack_require__(27)("Int8", 1, function(init) {
        return function(data, byteOffset, length) {
            return init(this, data, byteOffset, length)
        }
    })
}, function(module, exports, __webpack_require__) {
    __webpack_require__(27)("Uint8", 1, function(init) {
        return function(data, byteOffset, length) {
            return init(this, data, byteOffset, length)
        }
    })
}, function(module, exports, __webpack_require__) {
    __webpack_require__(27)("Uint8", 1, function(init) {
        return function(data, byteOffset, length) {
            return init(this, data, byteOffset, length)
        }
    }, !0)
}, function(module, exports, __webpack_require__) {
    __webpack_require__(27)("Int16", 2, function(init) {
        return function(data, byteOffset, length) {
            return init(this, data, byteOffset, length)
        }
    })
}, function(module, exports, __webpack_require__) {
    __webpack_require__(27)("Uint16", 2, function(init) {
        return function(data, byteOffset, length) {
            return init(this, data, byteOffset, length)
        }
    })
}, function(module, exports, __webpack_require__) {
    __webpack_require__(27)("Int32", 4, function(init) {
        return function(data, byteOffset, length) {
            return init(this, data, byteOffset, length)
        }
    })
}, function(module, exports, __webpack_require__) {
    __webpack_require__(27)("Uint32", 4, function(init) {
        return function(data, byteOffset, length) {
            return init(this, data, byteOffset, length)
        }
    })
}, function(module, exports, __webpack_require__) {
    __webpack_require__(27)("Float32", 4, function(init) {
        return function(data, byteOffset, length) {
            return init(this, data, byteOffset, length)
        }
    })
}, function(module, exports, __webpack_require__) {
    __webpack_require__(27)("Float64", 8, function(init) {
        return function(data, byteOffset, length) {
            return init(this, data, byteOffset, length)
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        aFunction = __webpack_require__(10),
        anObject = __webpack_require__(1),
        rApply = (__webpack_require__(2).Reflect || {}).apply,
        fApply = Function.apply;
    $export($export.S + $export.F * !__webpack_require__(3)(function() {
        rApply(function() {})
    }), "Reflect", {
        apply: function(target, thisArgument, argumentsList) {
            var T = aFunction(target),
                L = anObject(argumentsList);
            return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L)
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        create = __webpack_require__(36),
        aFunction = __webpack_require__(10),
        anObject = __webpack_require__(1),
        isObject = __webpack_require__(4),
        fails = __webpack_require__(3),
        bind = __webpack_require__(104),
        rConstruct = (__webpack_require__(2).Reflect || {}).construct,
        NEW_TARGET_BUG = fails(function() {
            function F() {}
            return !(rConstruct(function() {}, [], F) instanceof F)
        }),
        ARGS_BUG = !fails(function() {
            rConstruct(function() {})
        });
    $export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), "Reflect", {
        construct: function(Target, args) {
            aFunction(Target), anObject(args);
            var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
            if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
            if (Target == newTarget) {
                switch (args.length) {
                    case 0:
                        return new Target;
                    case 1:
                        return new Target(args[0]);
                    case 2:
                        return new Target(args[0], args[1]);
                    case 3:
                        return new Target(args[0], args[1], args[2]);
                    case 4:
                        return new Target(args[0], args[1], args[2], args[3])
                }
                var $args = [null];
                return $args.push.apply($args, args), new(bind.apply(Target, $args))
            }
            var proto = newTarget.prototype,
                instance = create(isObject(proto) ? proto : Object.prototype),
                result = Function.apply.call(Target, instance, args);
            return isObject(result) ? result : instance
        }
    })
}, function(module, exports, __webpack_require__) {
    var dP = __webpack_require__(8),
        $export = __webpack_require__(0),
        anObject = __webpack_require__(1),
        toPrimitive = __webpack_require__(23);
    $export($export.S + $export.F * __webpack_require__(3)(function() {
        Reflect.defineProperty(dP.f({}, 1, {
            value: 1
        }), 1, {
            value: 2
        })
    }), "Reflect", {
        defineProperty: function(target, propertyKey, attributes) {
            anObject(target), propertyKey = toPrimitive(propertyKey, !0), anObject(attributes);
            try {
                return dP.f(target, propertyKey, attributes), !0
            } catch (e) {
                return !1
            }
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        gOPD = __webpack_require__(16).f,
        anObject = __webpack_require__(1);
    $export($export.S, "Reflect", {
        deleteProperty: function(target, propertyKey) {
            var desc = gOPD(anObject(target), propertyKey);
            return !(desc && !desc.configurable) && delete target[propertyKey]
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        anObject = __webpack_require__(1),
        Enumerate = function(iterated) {
            this._t = anObject(iterated), this._i = 0;
            var key, keys = this._k = [];
            for (key in iterated) keys.push(key)
        };
    __webpack_require__(82)(Enumerate, "Object", function() {
        var key, keys = this._k;
        do {
            if (this._i >= keys.length) return {
                value: void 0,
                done: !0
            }
        } while (!((key = keys[this._i++]) in this._t));
        return {
            value: key,
            done: !1
        }
    }), $export($export.S, "Reflect", {
        enumerate: function(target) {
            return new Enumerate(target)
        }
    })
}, function(module, exports, __webpack_require__) {
    var gOPD = __webpack_require__(16),
        getPrototypeOf = __webpack_require__(17),
        has = __webpack_require__(14),
        $export = __webpack_require__(0),
        isObject = __webpack_require__(4),
        anObject = __webpack_require__(1);
    $export($export.S, "Reflect", {
        get: function get(target, propertyKey) {
            var desc, proto, receiver = arguments.length < 3 ? target : arguments[2];
            return anObject(target) === receiver ? target[propertyKey] : (desc = gOPD.f(target, propertyKey)) ? has(desc, "value") ? desc.value : void 0 !== desc.get ? desc.get.call(receiver) : void 0 : isObject(proto = getPrototypeOf(target)) ? get(proto, propertyKey, receiver) : void 0
        }
    })
}, function(module, exports, __webpack_require__) {
    var gOPD = __webpack_require__(16),
        $export = __webpack_require__(0),
        anObject = __webpack_require__(1);
    $export($export.S, "Reflect", {
        getOwnPropertyDescriptor: function(target, propertyKey) {
            return gOPD.f(anObject(target), propertyKey)
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        getProto = __webpack_require__(17),
        anObject = __webpack_require__(1);
    $export($export.S, "Reflect", {
        getPrototypeOf: function(target) {
            return getProto(anObject(target))
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.S, "Reflect", {
        has: function(target, propertyKey) {
            return propertyKey in target
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        anObject = __webpack_require__(1),
        $isExtensible = Object.isExtensible;
    $export($export.S, "Reflect", {
        isExtensible: function(target) {
            return anObject(target), !$isExtensible || $isExtensible(target)
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.S, "Reflect", {
        ownKeys: __webpack_require__(126)
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        anObject = __webpack_require__(1),
        $preventExtensions = Object.preventExtensions;
    $export($export.S, "Reflect", {
        preventExtensions: function(target) {
            anObject(target);
            try {
                return $preventExtensions && $preventExtensions(target), !0
            } catch (e) {
                return !1
            }
        }
    })
}, function(module, exports, __webpack_require__) {
    var dP = __webpack_require__(8),
        gOPD = __webpack_require__(16),
        getPrototypeOf = __webpack_require__(17),
        has = __webpack_require__(14),
        $export = __webpack_require__(0),
        createDesc = __webpack_require__(32),
        anObject = __webpack_require__(1),
        isObject = __webpack_require__(4);
    $export($export.S, "Reflect", {
        set: function set(target, propertyKey, V) {
            var existingDescriptor, proto, receiver = arguments.length < 4 ? target : arguments[3],
                ownDesc = gOPD.f(anObject(target), propertyKey);
            if (!ownDesc) {
                if (isObject(proto = getPrototypeOf(target))) return set(proto, propertyKey, V, receiver);
                ownDesc = createDesc(0)
            }
            if (has(ownDesc, "value")) {
                if (!1 === ownDesc.writable || !isObject(receiver)) return !1;
                if (existingDescriptor = gOPD.f(receiver, propertyKey)) {
                    if (existingDescriptor.get || existingDescriptor.set || !1 === existingDescriptor.writable) return !1;
                    existingDescriptor.value = V, dP.f(receiver, propertyKey, existingDescriptor)
                } else dP.f(receiver, propertyKey, createDesc(0, V));
                return !0
            }
            return void 0 !== ownDesc.set && (ownDesc.set.call(receiver, V), !0)
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        setProto = __webpack_require__(75);
    setProto && $export($export.S, "Reflect", {
        setPrototypeOf: function(target, proto) {
            setProto.check(target, proto);
            try {
                return setProto.set(target, proto), !0
            } catch (e) {
                return !1
            }
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        $includes = __webpack_require__(55)(!0);
    $export($export.P, "Array", {
        includes: function(el) {
            return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0)
        }
    }), __webpack_require__(31)("includes")
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        flattenIntoArray = __webpack_require__(127),
        toObject = __webpack_require__(9),
        toLength = __webpack_require__(6),
        aFunction = __webpack_require__(10),
        arraySpeciesCreate = __webpack_require__(88);
    $export($export.P, "Array", {
        flatMap: function(callbackfn) {
            var sourceLen, A, O = toObject(this);
            return aFunction(callbackfn), sourceLen = toLength(O.length), A = arraySpeciesCreate(O, 0), flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]), A
        }
    }), __webpack_require__(31)("flatMap")
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        flattenIntoArray = __webpack_require__(127),
        toObject = __webpack_require__(9),
        toLength = __webpack_require__(6),
        toInteger = __webpack_require__(21),
        arraySpeciesCreate = __webpack_require__(88);
    $export($export.P, "Array", {
        flatten: function() {
            var depthArg = arguments[0],
                O = toObject(this),
                sourceLen = toLength(O.length),
                A = arraySpeciesCreate(O, 0);
            return flattenIntoArray(A, O, O, sourceLen, 0, void 0 === depthArg ? 1 : toInteger(depthArg)), A
        }
    }), __webpack_require__(31)("flatten")
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        $at = __webpack_require__(58)(!0);
    $export($export.P, "String", {
        at: function(pos) {
            return $at(this, pos)
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        $pad = __webpack_require__(128),
        userAgent = __webpack_require__(63),
        WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);
    $export($export.P + $export.F * WEBKIT_BUG, "String", {
        padStart: function(maxLength) {
            return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : void 0, !0)
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        $pad = __webpack_require__(128),
        userAgent = __webpack_require__(63),
        WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);
    $export($export.P + $export.F * WEBKIT_BUG, "String", {
        padEnd: function(maxLength) {
            return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : void 0, !1)
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    __webpack_require__(46)("trimLeft", function($trim) {
        return function() {
            return $trim(this, 1)
        }
    }, "trimStart")
}, function(module, exports, __webpack_require__) {
    "use strict";
    __webpack_require__(46)("trimRight", function($trim) {
        return function() {
            return $trim(this, 2)
        }
    }, "trimEnd")
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        defined = __webpack_require__(24),
        toLength = __webpack_require__(6),
        isRegExp = __webpack_require__(59),
        getFlags = __webpack_require__(51),
        RegExpProto = RegExp.prototype,
        $RegExpStringIterator = function(regexp, string) {
            this._r = regexp, this._s = string
        };
    __webpack_require__(82)($RegExpStringIterator, "RegExp String", function() {
        var match = this._r.exec(this._s);
        return {
            value: match,
            done: null === match
        }
    }), $export($export.P, "String", {
        matchAll: function(regexp) {
            if (defined(this), !isRegExp(regexp)) throw TypeError(regexp + " is not a regexp!");
            var S = String(this),
                flags = "flags" in RegExpProto ? String(regexp.flags) : getFlags.call(regexp),
                rx = new RegExp(regexp.source, ~flags.indexOf("g") ? flags : "g" + flags);
            return rx.lastIndex = toLength(regexp.lastIndex), new $RegExpStringIterator(rx, S)
        }
    })
}, function(module, exports, __webpack_require__) {
    __webpack_require__(71)("asyncIterator")
}, function(module, exports, __webpack_require__) {
    __webpack_require__(71)("observable")
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        ownKeys = __webpack_require__(126),
        toIObject = __webpack_require__(15),
        gOPD = __webpack_require__(16),
        createProperty = __webpack_require__(86);
    $export($export.S, "Object", {
        getOwnPropertyDescriptors: function(object) {
            for (var key, desc, O = toIObject(object), getDesc = gOPD.f, keys = ownKeys(O), result = {}, i = 0; keys.length > i;) void 0 !== (desc = getDesc(O, key = keys[i++])) && createProperty(result, key, desc);
            return result
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        $values = __webpack_require__(129)(!1);
    $export($export.S, "Object", {
        values: function(it) {
            return $values(it)
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        $entries = __webpack_require__(129)(!0);
    $export($export.S, "Object", {
        entries: function(it) {
            return $entries(it)
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        toObject = __webpack_require__(9),
        aFunction = __webpack_require__(10),
        $defineProperty = __webpack_require__(8);
    __webpack_require__(7) && $export($export.P + __webpack_require__(66), "Object", {
        __defineGetter__: function(P, getter) {
            $defineProperty.f(toObject(this), P, {
                get: aFunction(getter),
                enumerable: !0,
                configurable: !0
            })
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        toObject = __webpack_require__(9),
        aFunction = __webpack_require__(10),
        $defineProperty = __webpack_require__(8);
    __webpack_require__(7) && $export($export.P + __webpack_require__(66), "Object", {
        __defineSetter__: function(P, setter) {
            $defineProperty.f(toObject(this), P, {
                set: aFunction(setter),
                enumerable: !0,
                configurable: !0
            })
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        toObject = __webpack_require__(9),
        toPrimitive = __webpack_require__(23),
        getPrototypeOf = __webpack_require__(17),
        getOwnPropertyDescriptor = __webpack_require__(16).f;
    __webpack_require__(7) && $export($export.P + __webpack_require__(66), "Object", {
        __lookupGetter__: function(P) {
            var D, O = toObject(this),
                K = toPrimitive(P, !0);
            do {
                if (D = getOwnPropertyDescriptor(O, K)) return D.get
            } while (O = getPrototypeOf(O))
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        toObject = __webpack_require__(9),
        toPrimitive = __webpack_require__(23),
        getPrototypeOf = __webpack_require__(17),
        getOwnPropertyDescriptor = __webpack_require__(16).f;
    __webpack_require__(7) && $export($export.P + __webpack_require__(66), "Object", {
        __lookupSetter__: function(P) {
            var D, O = toObject(this),
                K = toPrimitive(P, !0);
            do {
                if (D = getOwnPropertyDescriptor(O, K)) return D.set
            } while (O = getPrototypeOf(O))
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.P + $export.R, "Map", {
        toJSON: __webpack_require__(130)("Map")
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.P + $export.R, "Set", {
        toJSON: __webpack_require__(130)("Set")
    })
}, function(module, exports, __webpack_require__) {
    __webpack_require__(67)("Map")
}, function(module, exports, __webpack_require__) {
    __webpack_require__(67)("Set")
}, function(module, exports, __webpack_require__) {
    __webpack_require__(67)("WeakMap")
}, function(module, exports, __webpack_require__) {
    __webpack_require__(67)("WeakSet")
}, function(module, exports, __webpack_require__) {
    __webpack_require__(68)("Map")
}, function(module, exports, __webpack_require__) {
    __webpack_require__(68)("Set")
}, function(module, exports, __webpack_require__) {
    __webpack_require__(68)("WeakMap")
}, function(module, exports, __webpack_require__) {
    __webpack_require__(68)("WeakSet")
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.G, {
        global: __webpack_require__(2)
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.S, "System", {
        global: __webpack_require__(2)
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        cof = __webpack_require__(20);
    $export($export.S, "Error", {
        isError: function(it) {
            return "Error" === cof(it)
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.S, "Math", {
        clamp: function(x, lower, upper) {
            return Math.min(upper, Math.max(lower, x))
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.S, "Math", {
        DEG_PER_RAD: Math.PI / 180
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        RAD_PER_DEG = 180 / Math.PI;
    $export($export.S, "Math", {
        degrees: function(radians) {
            return radians * RAD_PER_DEG
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        scale = __webpack_require__(132),
        fround = __webpack_require__(111);
    $export($export.S, "Math", {
        fscale: function(x, inLow, inHigh, outLow, outHigh) {
            return fround(scale(x, inLow, inHigh, outLow, outHigh))
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.S, "Math", {
        iaddh: function(x0, x1, y0, y1) {
            var $x0 = x0 >>> 0,
                $y0 = y0 >>> 0;
            return (x1 >>> 0) + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.S, "Math", {
        isubh: function(x0, x1, y0, y1) {
            var $x0 = x0 >>> 0,
                $y0 = y0 >>> 0;
            return (x1 >>> 0) - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.S, "Math", {
        imulh: function(u, v) {
            var $u = +u,
                $v = +v,
                u0 = 65535 & $u,
                v0 = 65535 & $v,
                u1 = $u >> 16,
                v1 = $v >> 16,
                t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
            return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (65535 & t) >> 16)
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.S, "Math", {
        RAD_PER_DEG: 180 / Math.PI
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        DEG_PER_RAD = Math.PI / 180;
    $export($export.S, "Math", {
        radians: function(degrees) {
            return degrees * DEG_PER_RAD
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.S, "Math", {
        scale: __webpack_require__(132)
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.S, "Math", {
        umulh: function(u, v) {
            var $u = +u,
                $v = +v,
                u0 = 65535 & $u,
                v0 = 65535 & $v,
                u1 = $u >>> 16,
                v1 = $v >>> 16,
                t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
            return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (65535 & t) >>> 16)
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0);
    $export($export.S, "Math", {
        signbit: function(x) {
            return (x = +x) != x ? x : 0 == x ? 1 / x == 1 / 0 : x > 0
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        core = __webpack_require__(18),
        global = __webpack_require__(2),
        speciesConstructor = __webpack_require__(52),
        promiseResolve = __webpack_require__(119);
    $export($export.P + $export.R, "Promise", {
        finally: function(onFinally) {
            var C = speciesConstructor(this, core.Promise || global.Promise),
                isFunction = "function" == typeof onFinally;
            return this.then(isFunction ? function(x) {
                return promiseResolve(C, onFinally()).then(function() {
                    return x
                })
            } : onFinally, isFunction ? function(e) {
                return promiseResolve(C, onFinally()).then(function() {
                    throw e
                })
            } : onFinally)
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        newPromiseCapability = __webpack_require__(95),
        perform = __webpack_require__(118);
    $export($export.S, "Promise", {
        try: function(callbackfn) {
            var promiseCapability = newPromiseCapability.f(this),
                result = perform(callbackfn);
            return (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v), promiseCapability.promise
        }
    })
}, function(module, exports, __webpack_require__) {
    var metadata = __webpack_require__(28),
        anObject = __webpack_require__(1),
        toMetaKey = metadata.key,
        ordinaryDefineOwnMetadata = metadata.set;
    metadata.exp({
        defineMetadata: function(metadataKey, metadataValue, target, targetKey) {
            ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey))
        }
    })
}, function(module, exports, __webpack_require__) {
    var metadata = __webpack_require__(28),
        anObject = __webpack_require__(1),
        toMetaKey = metadata.key,
        getOrCreateMetadataMap = metadata.map,
        store = metadata.store;
    metadata.exp({
        deleteMetadata: function(metadataKey, target) {
            var targetKey = arguments.length < 3 ? void 0 : toMetaKey(arguments[2]),
                metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, !1);
            if (void 0 === metadataMap || !metadataMap.delete(metadataKey)) return !1;
            if (metadataMap.size) return !0;
            var targetMetadata = store.get(target);
            return targetMetadata.delete(targetKey), !!targetMetadata.size || store.delete(target)
        }
    })
}, function(module, exports, __webpack_require__) {
    var metadata = __webpack_require__(28),
        anObject = __webpack_require__(1),
        getPrototypeOf = __webpack_require__(17),
        ordinaryHasOwnMetadata = metadata.has,
        ordinaryGetOwnMetadata = metadata.get,
        toMetaKey = metadata.key,
        ordinaryGetMetadata = function(MetadataKey, O, P) {
            if (ordinaryHasOwnMetadata(MetadataKey, O, P)) return ordinaryGetOwnMetadata(MetadataKey, O, P);
            var parent = getPrototypeOf(O);
            return null !== parent ? ordinaryGetMetadata(MetadataKey, parent, P) : void 0
        };
    metadata.exp({
        getMetadata: function(metadataKey, target) {
            return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? void 0 : toMetaKey(arguments[2]))
        }
    })
}, function(module, exports, __webpack_require__) {
    var Set = __webpack_require__(122),
        from = __webpack_require__(131),
        metadata = __webpack_require__(28),
        anObject = __webpack_require__(1),
        getPrototypeOf = __webpack_require__(17),
        ordinaryOwnMetadataKeys = metadata.keys,
        toMetaKey = metadata.key,
        ordinaryMetadataKeys = function(O, P) {
            var oKeys = ordinaryOwnMetadataKeys(O, P),
                parent = getPrototypeOf(O);
            if (null === parent) return oKeys;
            var pKeys = ordinaryMetadataKeys(parent, P);
            return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys
        };
    metadata.exp({
        getMetadataKeys: function(target) {
            return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? void 0 : toMetaKey(arguments[1]))
        }
    })
}, function(module, exports, __webpack_require__) {
    var metadata = __webpack_require__(28),
        anObject = __webpack_require__(1),
        ordinaryGetOwnMetadata = metadata.get,
        toMetaKey = metadata.key;
    metadata.exp({
        getOwnMetadata: function(metadataKey, target) {
            return ordinaryGetOwnMetadata(metadataKey, anObject(target), arguments.length < 3 ? void 0 : toMetaKey(arguments[2]))
        }
    })
}, function(module, exports, __webpack_require__) {
    var metadata = __webpack_require__(28),
        anObject = __webpack_require__(1),
        ordinaryOwnMetadataKeys = metadata.keys,
        toMetaKey = metadata.key;
    metadata.exp({
        getOwnMetadataKeys: function(target) {
            return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? void 0 : toMetaKey(arguments[1]))
        }
    })
}, function(module, exports, __webpack_require__) {
    var metadata = __webpack_require__(28),
        anObject = __webpack_require__(1),
        getPrototypeOf = __webpack_require__(17),
        ordinaryHasOwnMetadata = metadata.has,
        toMetaKey = metadata.key,
        ordinaryHasMetadata = function(MetadataKey, O, P) {
            if (ordinaryHasOwnMetadata(MetadataKey, O, P)) return !0;
            var parent = getPrototypeOf(O);
            return null !== parent && ordinaryHasMetadata(MetadataKey, parent, P)
        };
    metadata.exp({
        hasMetadata: function(metadataKey, target) {
            return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? void 0 : toMetaKey(arguments[2]))
        }
    })
}, function(module, exports, __webpack_require__) {
    var metadata = __webpack_require__(28),
        anObject = __webpack_require__(1),
        ordinaryHasOwnMetadata = metadata.has,
        toMetaKey = metadata.key;
    metadata.exp({
        hasOwnMetadata: function(metadataKey, target) {
            return ordinaryHasOwnMetadata(metadataKey, anObject(target), arguments.length < 3 ? void 0 : toMetaKey(arguments[2]))
        }
    })
}, function(module, exports, __webpack_require__) {
    var $metadata = __webpack_require__(28),
        anObject = __webpack_require__(1),
        aFunction = __webpack_require__(10),
        toMetaKey = $metadata.key,
        ordinaryDefineOwnMetadata = $metadata.set;
    $metadata.exp({
        metadata: function(metadataKey, metadataValue) {
            return function(target, targetKey) {
                ordinaryDefineOwnMetadata(metadataKey, metadataValue, (void 0 !== targetKey ? anObject : aFunction)(target), toMetaKey(targetKey))
            }
        }
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        microtask = __webpack_require__(94)(),
        process = __webpack_require__(2).process,
        isNode = "process" == __webpack_require__(20)(process);
    $export($export.G, {
        asap: function(fn) {
            var domain = isNode && process.domain;
            microtask(domain ? domain.bind(fn) : fn)
        }
    })
}, function(module, exports, __webpack_require__) {
    "use strict";
    var $export = __webpack_require__(0),
        global = __webpack_require__(2),
        core = __webpack_require__(18),
        microtask = __webpack_require__(94)(),
        OBSERVABLE = __webpack_require__(5)("observable"),
        aFunction = __webpack_require__(10),
        anObject = __webpack_require__(1),
        anInstance = __webpack_require__(39),
        redefineAll = __webpack_require__(41),
        hide = __webpack_require__(11),
        forOf = __webpack_require__(40),
        RETURN = forOf.RETURN,
        getMethod = function(fn) {
            return null == fn ? void 0 : aFunction(fn)
        },
        cleanupSubscription = function(subscription) {
            var cleanup = subscription._c;
            cleanup && (subscription._c = void 0, cleanup())
        },
        subscriptionClosed = function(subscription) {
            return void 0 === subscription._o
        },
        closeSubscription = function(subscription) {
            subscriptionClosed(subscription) || (subscription._o = void 0, cleanupSubscription(subscription))
        },
        Subscription = function(observer, subscriber) {
            anObject(observer), this._c = void 0, this._o = observer, observer = new SubscriptionObserver(this);
            try {
                var cleanup = subscriber(observer),
                    subscription = cleanup;
                null != cleanup && ("function" == typeof cleanup.unsubscribe ? cleanup = function() {
                    subscription.unsubscribe()
                } : aFunction(cleanup), this._c = cleanup)
            } catch (e) {
                return void observer.error(e)
            }
            subscriptionClosed(this) && cleanupSubscription(this)
        };
    Subscription.prototype = redefineAll({}, {
        unsubscribe: function() {
            closeSubscription(this)
        }
    });
    var SubscriptionObserver = function(subscription) {
        this._s = subscription
    };
    SubscriptionObserver.prototype = redefineAll({}, {
        next: function(value) {
            var subscription = this._s;
            if (!subscriptionClosed(subscription)) {
                var observer = subscription._o;
                try {
                    var m = getMethod(observer.next);
                    if (m) return m.call(observer, value)
                } catch (e) {
                    try {
                        closeSubscription(subscription)
                    } finally {
                        throw e
                    }
                }
            }
        },
        error: function(value) {
            var subscription = this._s;
            if (subscriptionClosed(subscription)) throw value;
            var observer = subscription._o;
            subscription._o = void 0;
            try {
                var m = getMethod(observer.error);
                if (!m) throw value;
                value = m.call(observer, value)
            } catch (e) {
                try {
                    cleanupSubscription(subscription)
                } finally {
                    throw e
                }
            }
            return cleanupSubscription(subscription), value
        },
        complete: function(value) {
            var subscription = this._s;
            if (!subscriptionClosed(subscription)) {
                var observer = subscription._o;
                subscription._o = void 0;
                try {
                    var m = getMethod(observer.complete);
                    value = m ? m.call(observer, value) : void 0
                } catch (e) {
                    try {
                        cleanupSubscription(subscription)
                    } finally {
                        throw e
                    }
                }
                return cleanupSubscription(subscription), value
            }
        }
    });
    var $Observable = function(subscriber) {
        anInstance(this, $Observable, "Observable", "_f")._f = aFunction(subscriber)
    };
    redefineAll($Observable.prototype, {
        subscribe: function(observer) {
            return new Subscription(observer, this._f)
        },
        forEach: function(fn) {
            var that = this;
            return new(core.Promise || global.Promise)(function(resolve, reject) {
                aFunction(fn);
                var subscription = that.subscribe({
                    next: function(value) {
                        try {
                            return fn(value)
                        } catch (e) {
                            reject(e), subscription.unsubscribe()
                        }
                    },
                    error: reject,
                    complete: resolve
                })
            })
        }
    }), redefineAll($Observable, {
        from: function(x) {
            var C = "function" == typeof this ? this : $Observable,
                method = getMethod(anObject(x)[OBSERVABLE]);
            if (method) {
                var observable = anObject(method.call(x));
                return observable.constructor === C ? observable : new C(function(observer) {
                    return observable.subscribe(observer)
                })
            }
            return new C(function(observer) {
                var done = !1;
                return microtask(function() {
                        if (!done) {
                            try {
                                if (forOf(x, !1, function(it) {
                                        if (observer.next(it), done) return RETURN
                                    }) === RETURN) return
                            } catch (e) {
                                if (done) throw e;
                                return void observer.error(e)
                            }
                            observer.complete()
                        }
                    }),
                    function() {
                        done = !0
                    }
            })
        },
        of: function() {
            for (var i = 0, l = arguments.length, items = new Array(l); i < l;) items[i] = arguments[i++];
            return new("function" == typeof this ? this : $Observable)(function(observer) {
                var done = !1;
                return microtask(function() {
                        if (!done) {
                            for (var j = 0; j < items.length; ++j)
                                if (observer.next(items[j]), done) return;
                            observer.complete()
                        }
                    }),
                    function() {
                        done = !0
                    }
            })
        }
    }), hide($Observable.prototype, OBSERVABLE, function() {
        return this
    }), $export($export.G, {
        Observable: $Observable
    }), __webpack_require__(38)("Observable")
}, function(module, exports, __webpack_require__) {
    var global = __webpack_require__(2),
        $export = __webpack_require__(0),
        userAgent = __webpack_require__(63),
        slice = [].slice,
        MSIE = /MSIE .\./.test(userAgent),
        wrap = function(set) {
            return function(fn, time) {
                var boundArgs = arguments.length > 2,
                    args = !!boundArgs && slice.call(arguments, 2);
                return set(boundArgs ? function() {
                    ("function" == typeof fn ? fn : Function(fn)).apply(this, args)
                } : fn, time)
            }
        };
    $export($export.G + $export.B + $export.F * MSIE, {
        setTimeout: wrap(global.setTimeout),
        setInterval: wrap(global.setInterval)
    })
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        $task = __webpack_require__(93);
    $export($export.G + $export.B, {
        setImmediate: $task.set,
        clearImmediate: $task.clear
    })
}, function(module, exports, __webpack_require__) {
    for (var $iterators = __webpack_require__(90), getKeys = __webpack_require__(34), redefine = __webpack_require__(12), global = __webpack_require__(2), hide = __webpack_require__(11), Iterators = __webpack_require__(47), wks = __webpack_require__(5), ITERATOR = wks("iterator"), TO_STRING_TAG = wks("toStringTag"), ArrayValues = Iterators.Array, DOMIterables = {
            CSSRuleList: !0,
            CSSStyleDeclaration: !1,
            CSSValueList: !1,
            ClientRectList: !1,
            DOMRectList: !1,
            DOMStringList: !1,
            DOMTokenList: !0,
            DataTransferItemList: !1,
            FileList: !1,
            HTMLAllCollection: !1,
            HTMLCollection: !1,
            HTMLFormElement: !1,
            HTMLSelectElement: !1,
            MediaList: !0,
            MimeTypeArray: !1,
            NamedNodeMap: !1,
            NodeList: !0,
            PaintRequestList: !1,
            Plugin: !1,
            PluginArray: !1,
            SVGLengthList: !1,
            SVGNumberList: !1,
            SVGPathSegList: !1,
            SVGPointList: !1,
            SVGStringList: !1,
            SVGTransformList: !1,
            SourceBufferList: !1,
            StyleSheetList: !0,
            TextTrackCueList: !1,
            TextTrackList: !1,
            TouchList: !1
        }, collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
        var key, NAME = collections[i],
            explicit = DOMIterables[NAME],
            Collection = global[NAME],
            proto = Collection && Collection.prototype;
        if (proto && (proto[ITERATOR] || hide(proto, ITERATOR, ArrayValues), proto[TO_STRING_TAG] || hide(proto, TO_STRING_TAG, NAME), Iterators[NAME] = ArrayValues, explicit))
            for (key in $iterators) proto[key] || redefine(proto, key, $iterators[key], !0)
    }
}, function(module, exports) {
    ! function(global) {
        "use strict";
        var undefined, Op = Object.prototype,
            hasOwn = Op.hasOwnProperty,
            $Symbol = "function" == typeof Symbol ? Symbol : {},
            iteratorSymbol = $Symbol.iterator || "@@iterator",
            asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
            toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag",
            inModule = "object" == typeof module,
            runtime = global.regeneratorRuntime;
        if (runtime) inModule && (module.exports = runtime);
        else {
            (runtime = global.regeneratorRuntime = inModule ? module.exports : {}).wrap = wrap;
            var GenStateSuspendedStart = "suspendedStart",
                GenStateSuspendedYield = "suspendedYield",
                GenStateExecuting = "executing",
                GenStateCompleted = "completed",
                ContinueSentinel = {},
                IteratorPrototype = {};
            IteratorPrototype[iteratorSymbol] = function() {
                return this
            };
            var getProto = Object.getPrototypeOf,
                NativeIteratorPrototype = getProto && getProto(getProto(values([])));
            NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
            var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
            GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype, GeneratorFunctionPrototype.constructor = GeneratorFunction, GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction", runtime.isGeneratorFunction = function(genFun) {
                var ctor = "function" == typeof genFun && genFun.constructor;
                return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name))
            }, runtime.mark = function(genFun) {
                return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, toStringTagSymbol in genFun || (genFun[toStringTagSymbol] = "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun
            }, runtime.awrap = function(arg) {
                return {
                    __await: arg
                }
            }, defineIteratorMethods(AsyncIterator.prototype), AsyncIterator.prototype[asyncIteratorSymbol] = function() {
                return this
            }, runtime.AsyncIterator = AsyncIterator, runtime.async = function(innerFn, outerFn, self, tryLocsList) {
                var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
                return runtime.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
                    return result.done ? result.value : iter.next()
                })
            }, defineIteratorMethods(Gp), Gp[toStringTagSymbol] = "Generator", Gp[iteratorSymbol] = function() {
                return this
            }, Gp.toString = function() {
                return "[object Generator]"
            }, runtime.keys = function(object) {
                var keys = [];
                for (var key in object) keys.push(key);
                return keys.reverse(),
                    function next() {
                        for (; keys.length;) {
                            var key = keys.pop();
                            if (key in object) return next.value = key, next.done = !1, next
                        }
                        return next.done = !0, next
                    }
            }, runtime.values = values, Context.prototype = {
                constructor: Context,
                reset: function(skipTempReset) {
                    if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
                        for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined)
                },
                stop: function() {
                    this.done = !0;
                    var rootRecord = this.tryEntries[0].completion;
                    if ("throw" === rootRecord.type) throw rootRecord.arg;
                    return this.rval
                },
                dispatchException: function(exception) {
                    if (this.done) throw exception;
                    var context = this;

                    function handle(loc, caught) {
                        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught
                    }
                    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                        var entry = this.tryEntries[i],
                            record = entry.completion;
                        if ("root" === entry.tryLoc) return handle("end");
                        if (entry.tryLoc <= this.prev) {
                            var hasCatch = hasOwn.call(entry, "catchLoc"),
                                hasFinally = hasOwn.call(entry, "finallyLoc");
                            if (hasCatch && hasFinally) {
                                if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
                                if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc)
                            } else if (hasCatch) {
                                if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0)
                            } else {
                                if (!hasFinally) throw new Error("try statement without catch or finally");
                                if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc)
                            }
                        }
                    }
                },
                abrupt: function(type, arg) {
                    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                        var entry = this.tryEntries[i];
                        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                            var finallyEntry = entry;
                            break
                        }
                    }
                    finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
                    var record = finallyEntry ? finallyEntry.completion : {};
                    return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record)
                },
                complete: function(record, afterLoc) {
                    if ("throw" === record.type) throw record.arg;
                    return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel
                },
                finish: function(finallyLoc) {
                    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                        var entry = this.tryEntries[i];
                        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel
                    }
                },
                catch: function(tryLoc) {
                    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                        var entry = this.tryEntries[i];
                        if (entry.tryLoc === tryLoc) {
                            var record = entry.completion;
                            if ("throw" === record.type) {
                                var thrown = record.arg;
                                resetTryEntry(entry)
                            }
                            return thrown
                        }
                    }
                    throw new Error("illegal catch attempt")
                },
                delegateYield: function(iterable, resultName, nextLoc) {
                    return this.delegate = {
                        iterator: values(iterable),
                        resultName: resultName,
                        nextLoc: nextLoc
                    }, "next" === this.method && (this.arg = undefined), ContinueSentinel
                }
            }
        }

        function wrap(innerFn, outerFn, self, tryLocsList) {
            var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
                generator = Object.create(protoGenerator.prototype),
                context = new Context(tryLocsList || []);
            return generator._invoke = function(innerFn, self, context) {
                var state = GenStateSuspendedStart;
                return function(method, arg) {
                    if (state === GenStateExecuting) throw new Error("Generator is already running");
                    if (state === GenStateCompleted) {
                        if ("throw" === method) throw arg;
                        return doneResult()
                    }
                    for (context.method = method, context.arg = arg;;) {
                        var delegate = context.delegate;
                        if (delegate) {
                            var delegateResult = maybeInvokeDelegate(delegate, context);
                            if (delegateResult) {
                                if (delegateResult === ContinueSentinel) continue;
                                return delegateResult
                            }
                        }
                        if ("next" === context.method) context.sent = context._sent = context.arg;
                        else if ("throw" === context.method) {
                            if (state === GenStateSuspendedStart) throw state = GenStateCompleted, context.arg;
                            context.dispatchException(context.arg)
                        } else "return" === context.method && context.abrupt("return", context.arg);
                        state = GenStateExecuting;
                        var record = tryCatch(innerFn, self, context);
                        if ("normal" === record.type) {
                            if (state = context.done ? GenStateCompleted : GenStateSuspendedYield, record.arg === ContinueSentinel) continue;
                            return {
                                value: record.arg,
                                done: context.done
                            }
                        }
                        "throw" === record.type && (state = GenStateCompleted, context.method = "throw", context.arg = record.arg)
                    }
                }
            }(innerFn, self, context), generator
        }

        function tryCatch(fn, obj, arg) {
            try {
                return {
                    type: "normal",
                    arg: fn.call(obj, arg)
                }
            } catch (err) {
                return {
                    type: "throw",
                    arg: err
                }
            }
        }

        function Generator() {}

        function GeneratorFunction() {}

        function GeneratorFunctionPrototype() {}

        function defineIteratorMethods(prototype) {
            ["next", "throw", "return"].forEach(function(method) {
                prototype[method] = function(arg) {
                    return this._invoke(method, arg)
                }
            })
        }

        function AsyncIterator(generator) {
            var previousPromise;
            this._invoke = function(method, arg) {
                function callInvokeWithMethodAndArg() {
                    return new Promise(function(resolve, reject) {
                        ! function invoke(method, arg, resolve, reject) {
                            var record = tryCatch(generator[method], generator, arg);
                            if ("throw" !== record.type) {
                                var result = record.arg,
                                    value = result.value;
                                return value && "object" == typeof value && hasOwn.call(value, "__await") ? Promise.resolve(value.__await).then(function(value) {
                                    invoke("next", value, resolve, reject)
                                }, function(err) {
                                    invoke("throw", err, resolve, reject)
                                }) : Promise.resolve(value).then(function(unwrapped) {
                                    result.value = unwrapped, resolve(result)
                                }, reject)
                            }
                            reject(record.arg)
                        }(method, arg, resolve, reject)
                    })
                }
                return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg()
            }
        }

        function maybeInvokeDelegate(delegate, context) {
            var method = delegate.iterator[context.method];
            if (method === undefined) {
                if (context.delegate = null, "throw" === context.method) {
                    if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
                    context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method")
                }
                return ContinueSentinel
            }
            var record = tryCatch(method, delegate.iterator, context.arg);
            if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
            var info = record.arg;
            return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel)
        }

        function pushTryEntry(locs) {
            var entry = {
                tryLoc: locs[0]
            };
            1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry)
        }

        function resetTryEntry(entry) {
            var record = entry.completion || {};
            record.type = "normal", delete record.arg, entry.completion = record
        }

        function Context(tryLocsList) {
            this.tryEntries = [{
                tryLoc: "root"
            }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0)
        }

        function values(iterable) {
            if (iterable) {
                var iteratorMethod = iterable[iteratorSymbol];
                if (iteratorMethod) return iteratorMethod.call(iterable);
                if ("function" == typeof iterable.next) return iterable;
                if (!isNaN(iterable.length)) {
                    var i = -1,
                        next = function next() {
                            for (; ++i < iterable.length;)
                                if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
                            return next.value = undefined, next.done = !0, next
                        };
                    return next.next = next
                }
            }
            return {
                next: doneResult
            }
        }

        function doneResult() {
            return {
                value: undefined,
                done: !0
            }
        }
    }(function() {
        return this
    }() || Function("return this")())
}, function(module, exports, __webpack_require__) {
    __webpack_require__(335), module.exports = __webpack_require__(18).RegExp.escape
}, function(module, exports, __webpack_require__) {
    var $export = __webpack_require__(0),
        $re = __webpack_require__(336)(/[\\^$*+?.()|[\]{}]/g, "\\$&");
    $export($export.S, "RegExp", {
        escape: function(it) {
            return $re(it)
        }
    })
}, function(module, exports) {
    module.exports = function(regExp, replace) {
        var replacer = replace === Object(replace) ? function(part) {
            return replace[part]
        } : replace;
        return function(it) {
            return String(it).replace(regExp, replacer)
        }
    }
}, function(module, exports, __webpack_require__) {
    var Store = __webpack_require__(338);
    module.exports = new Store
}, function(module, exports, __webpack_require__) {
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor)
            }
        }
        return function(Constructor, protoProps, staticProps) {
            return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor
        }
    }();
    var _ = __webpack_require__(43),
        _require = __webpack_require__(339),
        getChildProperty = _require.getChildProperty,
        setChildProperty = _require.setChildProperty;
    module.exports = function() {
        function Store() {
            var store = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            ! function(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
            }(this, Store), this.store = store
        }
        return _createClass(Store, [{
            key: "get",
            value: function(propPath) {
                var data = propPath ? getChildProperty(this.store, propPath) : this.store;
                return _.clone(data)
            }
        }, {
            key: "set",
            value: function(propPath, data) {
                if (!propPath) throw new Error('store.set() must be called with a "propPath"');
                setChildProperty(_.clone(data), propPath, this.store)
            }
        }, {
            key: "replaceState",
            value: function(state) {
                var _this = this;
                this.store = {}, Object.keys(state).forEach(function(key) {
                    _this.set(key, state[key])
                })
            }
        }]), Store
    }()
}, function(module, exports) {
    var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
    };
    module.exports = function() {
        var hasOwnProperty, hasDontEnumBug, dontEnums, dontEnumsLength;
        return Object.keys || (Object.keys = (hasOwnProperty = Object.prototype.hasOwnProperty, hasDontEnumBug = !Object.prototype.propertyIsEnumerable({
            toString: null
        }, "toString"), dontEnumsLength = (dontEnums = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"]).length, function(obj) {
            if ("object" !== (void 0 === obj ? "undefined" : _typeof(obj)) && ("function" != typeof obj || null === obj)) throw new TypeError("Object.keys called on non-object");
            var result = [],
                i = void 0;
            if (Object.keys(obj).forEach(function(prop) {
                    hasOwnProperty.call(obj, prop) && result.push(prop)
                }), hasDontEnumBug)
                for (i = 0; i < dontEnumsLength; i++) hasOwnProperty.call(obj, dontEnums[i]) && result.push(dontEnums[i]);
            return result
        })), {
            hasChildProperty: function(object, pPath) {
                var propPath = pPath,
                    obj = object,
                    i = 0,
                    part = void 0;
                if (!obj || "object" !== (void 0 === obj ? "undefined" : _typeof(obj)) || !propPath || "string" != typeof propPath) return !1;
                for (var path = (propPath = propPath.replace(/^\./, "")).split("."), length = path.length; i < length; i++) {
                    if (part = path[i], !obj || !Object.prototype.hasOwnProperty.call(obj, part)) return !1;
                    obj = obj[part]
                }
                return !0
            },
            getChildProperty: function(object, pPath) {
                var propPath = pPath,
                    obj = object,
                    i = 0,
                    part = void 0;
                if (obj && "object" === (void 0 === obj ? "undefined" : _typeof(obj)) && propPath && "string" == typeof propPath) {
                    for (var path = (propPath = (propPath = propPath.replace(/\[(\w+)\]/g, ".$1")).replace(/^\./, "")).split("."), length = path.length; i < length; i++) {
                        if (part = path[i], !("object" === (void 0 === obj ? "undefined" : _typeof(obj)) && part in obj)) return;
                        obj = obj[part]
                    }
                    return obj
                }
            },
            setChildProperty: function(value, pPath, object) {
                var obj = object,
                    propPath = pPath,
                    i = 0,
                    part = void 0;
                if (obj = obj || {}, propPath && "string" == typeof propPath) {
                    for (var path = (propPath = propPath.replace(/^\./, "")).split("."), length = path.length - 1; i < length; i++)(part = path[i]) in obj || (obj[part] = {}), obj = obj[part];
                    return obj[path[length]] = value, obj
                }
            }
        }
    }()
}, function(module, exports, __webpack_require__) {
    Object.defineProperty(exports, "__esModule", {
        value: !0
    });
    var _jquery2 = _interopRequireDefault(__webpack_require__(69)),
        _backbone2 = _interopRequireDefault(__webpack_require__(53)),
        _backbone4 = _interopRequireDefault(__webpack_require__(133));
    __webpack_require__(343);
    var _thanksgiving2 = _interopRequireDefault(__webpack_require__(345));
    __webpack_require__(349);
    var _package2 = _interopRequireDefault(__webpack_require__(350));

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        }
    }
    __webpack_require__.p = _package2.default.version + "/";
    var PageApp = new _backbone4.default.Application;
    PageApp.getMeta = function() {
        return null
    }, PageApp.on("start", function() {
        _backbone2.default.history && (PageApp.Feature = new _thanksgiving2.default, (0, _jquery2.default)("#main").length > 0 && PageApp.Feature.init())
    }), exports.default = PageApp
}, function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__, factory;
    factory = function(Backbone, _) {
        "use strict";
        var CommandStorage, Channel, previousWreqr = Backbone.Wreqr,
            Wreqr = Backbone.Wreqr = {};
        return Backbone.Wreqr.VERSION = "1.3.6", Backbone.Wreqr.noConflict = function() {
            return Backbone.Wreqr = previousWreqr, this
        }, Wreqr.Handlers = function(Backbone, _) {
            var Handlers = function(options) {
                this.options = options, this._wreqrHandlers = {}, _.isFunction(this.initialize) && this.initialize(options)
            };
            return Handlers.extend = Backbone.Model.extend, _.extend(Handlers.prototype, Backbone.Events, {
                setHandlers: function(handlers) {
                    _.each(handlers, function(handler, name) {
                        var context = null;
                        _.isObject(handler) && !_.isFunction(handler) && (context = handler.context, handler = handler.callback), this.setHandler(name, handler, context)
                    }, this)
                },
                setHandler: function(name, handler, context) {
                    var config = {
                        callback: handler,
                        context: context
                    };
                    this._wreqrHandlers[name] = config, this.trigger("handler:add", name, handler, context)
                },
                hasHandler: function(name) {
                    return !!this._wreqrHandlers[name]
                },
                getHandler: function(name) {
                    var config = this._wreqrHandlers[name];
                    if (config) return function() {
                        return config.callback.apply(config.context, arguments)
                    }
                },
                removeHandler: function(name) {
                    delete this._wreqrHandlers[name]
                },
                removeAllHandlers: function() {
                    this._wreqrHandlers = {}
                }
            }), Handlers
        }(Backbone, _), Wreqr.CommandStorage = (CommandStorage = function(options) {
            this.options = options, this._commands = {}, _.isFunction(this.initialize) && this.initialize(options)
        }, _.extend(CommandStorage.prototype, Backbone.Events, {
            getCommands: function(commandName) {
                var commands = this._commands[commandName];
                return commands || (commands = {
                    command: commandName,
                    instances: []
                }, this._commands[commandName] = commands), commands
            },
            addCommand: function(commandName, args) {
                this.getCommands(commandName).instances.push(args)
            },
            clearCommands: function(commandName) {
                this.getCommands(commandName).instances = []
            }
        }), CommandStorage), Wreqr.Commands = function(Wreqr, _) {
            return Wreqr.Handlers.extend({
                storageType: Wreqr.CommandStorage,
                constructor: function(options) {
                    this.options = options || {}, this._initializeStorage(this.options), this.on("handler:add", this._executeCommands, this), Wreqr.Handlers.prototype.constructor.apply(this, arguments)
                },
                execute: function(name) {
                    name = arguments[0];
                    var args = _.rest(arguments);
                    this.hasHandler(name) ? this.getHandler(name).apply(this, args) : this.storage.addCommand(name, args)
                },
                _executeCommands: function(name, handler, context) {
                    var command = this.storage.getCommands(name);
                    _.each(command.instances, function(args) {
                        handler.apply(context, args)
                    }), this.storage.clearCommands(name)
                },
                _initializeStorage: function(options) {
                    var storage, StorageType = options.storageType || this.storageType;
                    storage = _.isFunction(StorageType) ? new StorageType : StorageType, this.storage = storage
                }
            })
        }(Wreqr, _), Wreqr.RequestResponse = function(Wreqr, _) {
            return Wreqr.Handlers.extend({
                request: function(name) {
                    if (this.hasHandler(name)) return this.getHandler(name).apply(this, _.rest(arguments))
                }
            })
        }(Wreqr, _), Wreqr.EventAggregator = function(Backbone, _) {
            var EA = function() {};
            return EA.extend = Backbone.Model.extend, _.extend(EA.prototype, Backbone.Events), EA
        }(Backbone, _), Wreqr.Channel = (Channel = function(channelName) {
            this.vent = new Backbone.Wreqr.EventAggregator, this.reqres = new Backbone.Wreqr.RequestResponse, this.commands = new Backbone.Wreqr.Commands, this.channelName = channelName
        }, _.extend(Channel.prototype, {
            reset: function() {
                return this.vent.off(), this.vent.stopListening(), this.reqres.removeAllHandlers(), this.commands.removeAllHandlers(), this
            },
            connectEvents: function(hash, context) {
                return this._connect("vent", hash, context), this
            },
            connectCommands: function(hash, context) {
                return this._connect("commands", hash, context), this
            },
            connectRequests: function(hash, context) {
                return this._connect("reqres", hash, context), this
            },
            _connect: function(type, hash, context) {
                if (hash) {
                    context = context || this;
                    var method = "vent" === type ? "on" : "setHandler";
                    _.each(hash, function(fn, eventName) {
                        this[type][method](eventName, _.bind(fn, context))
                    }, this)
                }
            }
        }), Channel), Wreqr.radio = function(Wreqr, _) {
            var Radio = function() {
                this._channels = {}, this.vent = {}, this.commands = {}, this.reqres = {}, this._proxyMethods()
            };
            _.extend(Radio.prototype, {
                channel: function(channelName) {
                    if (!channelName) throw new Error("Channel must receive a name");
                    return this._getChannel(channelName)
                },
                _getChannel: function(channelName) {
                    var channel = this._channels[channelName];
                    return channel || (channel = new Wreqr.Channel(channelName), this._channels[channelName] = channel), channel
                },
                _proxyMethods: function() {
                    _.each(["vent", "commands", "reqres"], function(system) {
                        _.each(messageSystems[system], function(method) {
                            this[system][method] = proxyMethod(this, system, method)
                        }, this)
                    }, this)
                }
            });
            var messageSystems = {
                    vent: ["on", "off", "trigger", "once", "stopListening", "listenTo", "listenToOnce"],
                    commands: ["execute", "setHandler", "setHandlers", "removeHandler", "removeAllHandlers"],
                    reqres: ["request", "setHandler", "setHandlers", "removeHandler", "removeAllHandlers"]
                },
                proxyMethod = function(radio, system, method) {
                    return function(channelName) {
                        var messageSystem = radio._getChannel(channelName)[system];
                        return messageSystem[method].apply(messageSystem, _.rest(arguments))
                    }
                };
            return new Radio
        }(Wreqr, _), Backbone.Wreqr
    }, __WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(53), __webpack_require__(43)], void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = function(Backbone, _) {
        return factory(Backbone, _)
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)
}, function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__, factory;
    factory = function(Backbone, _) {
        "use strict";
        var previousChildViewContainer = Backbone.ChildViewContainer;
        return Backbone.ChildViewContainer = function(Backbone, _) {
            var Container = function(views) {
                this._views = {}, this._indexByModel = {}, this._indexByCustom = {}, this._updateLength(), _.each(views, this.add, this)
            };
            _.extend(Container.prototype, {
                add: function(view, customIndex) {
                    var viewCid = view.cid;
                    return this._views[viewCid] = view, view.model && (this._indexByModel[view.model.cid] = viewCid), customIndex && (this._indexByCustom[customIndex] = viewCid), this._updateLength(), this
                },
                findByModel: function(model) {
                    return this.findByModelCid(model.cid)
                },
                findByModelCid: function(modelCid) {
                    var viewCid = this._indexByModel[modelCid];
                    return this.findByCid(viewCid)
                },
                findByCustom: function(index) {
                    var viewCid = this._indexByCustom[index];
                    return this.findByCid(viewCid)
                },
                findByIndex: function(index) {
                    return _.values(this._views)[index]
                },
                findByCid: function(cid) {
                    return this._views[cid]
                },
                remove: function(view) {
                    var viewCid = view.cid;
                    return view.model && delete this._indexByModel[view.model.cid], _.any(this._indexByCustom, function(cid, key) {
                        if (cid === viewCid) return delete this._indexByCustom[key], !0
                    }, this), delete this._views[viewCid], this._updateLength(), this
                },
                call: function(method) {
                    this.apply(method, _.tail(arguments))
                },
                apply: function(method, args) {
                    _.each(this._views, function(view) {
                        _.isFunction(view[method]) && view[method].apply(view, args || [])
                    })
                },
                _updateLength: function() {
                    this.length = _.size(this._views)
                }
            });
            return _.each(["forEach", "each", "map", "find", "detect", "filter", "select", "reject", "every", "all", "some", "any", "include", "contains", "invoke", "toArray", "first", "initial", "rest", "last", "without", "isEmpty", "pluck", "reduce"], function(method) {
                Container.prototype[method] = function() {
                    var args = [_.values(this._views)].concat(_.toArray(arguments));
                    return _[method].apply(_, args)
                }
            }), Container
        }(0, _), Backbone.ChildViewContainer.VERSION = "0.1.11", Backbone.ChildViewContainer.noConflict = function() {
            return Backbone.ChildViewContainer = previousChildViewContainer, this
        }, Backbone.ChildViewContainer
    }, __WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(53), __webpack_require__(43)], void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = function(Backbone, _) {
        return factory(Backbone, _)
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)
}, function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__, factory;
    factory = function(Marionette, Radio, _) {
        "use strict";
        Marionette.Application.prototype._initChannel = function() {
            this.channelName = _.result(this, "channelName") || "global", this.channel = _.result(this, "channel") || Radio.channel(this.channelName)
        }
    }, __WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(133), __webpack_require__(344), __webpack_require__(43)], void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof(__WEBPACK_AMD_DEFINE_FACTORY__ = factory) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)
}, function(module, exports, __webpack_require__) {
    var factory;
    factory = function(_, Backbone) {
        "use strict";
        _ = "default" in _ ? _.default : _, Backbone = "default" in Backbone ? Backbone.default : Backbone;
        var babelHelpers = {};
        babelHelpers.typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol ? "symbol" : typeof obj
        };
        var previousRadio = Backbone.Radio,
            Radio = Backbone.Radio = {};
        Radio.VERSION = "1.0.4", Radio.noConflict = function() {
            return Backbone.Radio = previousRadio, this
        }, Radio.DEBUG = !1, Radio._debugText = function(warning, eventName, channelName) {
            return warning + (channelName ? " on the " + channelName + " channel" : "") + ': "' + eventName + '"'
        }, Radio.debugLog = function(warning, eventName, channelName) {
            Radio.DEBUG && console && console.warn && console.warn(Radio._debugText(warning, eventName, channelName))
        };
        var eventSplitter = /\s+/;

        function removeHandler(store, name, callback, context) {
            var event = store[name];
            if (!(callback && callback !== event.callback && callback !== event.callback._callback || context && context !== event.context)) return delete store[name], !0
        }
        Radio._eventsApi = function(obj, action, name, rest) {
            if (!name) return !1;
            var results = {};
            if ("object" === (void 0 === name ? "undefined" : babelHelpers.typeof(name))) {
                for (var key in name) {
                    var result = obj[action].apply(obj, [key, name[key]].concat(rest));
                    eventSplitter.test(key) ? _.extend(results, result) : results[key] = result
                }
                return results
            }
            if (eventSplitter.test(name)) {
                for (var names = name.split(eventSplitter), i = 0, l = names.length; i < l; i++) results[names[i]] = obj[action].apply(obj, [names[i]].concat(rest));
                return results
            }
            return !1
        }, Radio._callHandler = function(callback, context, args) {
            var a1 = args[0],
                a2 = args[1],
                a3 = args[2];
            switch (args.length) {
                case 0:
                    return callback.call(context);
                case 1:
                    return callback.call(context, a1);
                case 2:
                    return callback.call(context, a1, a2);
                case 3:
                    return callback.call(context, a1, a2, a3);
                default:
                    return callback.apply(context, args)
            }
        };
        var channel, args, _logs = {};

        function _partial(channelName) {
            return _logs[channelName] || (_logs[channelName] = _.bind(Radio.log, Radio, channelName))
        }

        function makeCallback(callback) {
            return _.isFunction(callback) ? callback : function() {
                return callback
            }
        }
        _.extend(Radio, {
            log: function(channelName, eventName) {
                if ("undefined" != typeof console) {
                    var args = _.toArray(arguments).slice(2);
                    console.log("[" + channelName + '] "' + eventName + '"', args)
                }
            },
            tuneIn: function(channelName) {
                var channel = Radio.channel(channelName);
                return channel._tunedIn = !0, channel.on("all", _partial(channelName)), this
            },
            tuneOut: function(channelName) {
                var channel = Radio.channel(channelName);
                return channel._tunedIn = !1, channel.off("all", _partial(channelName)), delete _logs[channelName], this
            }
        }), Radio.Requests = {
            request: function(name) {
                var args = _.toArray(arguments).slice(1),
                    results = Radio._eventsApi(this, "request", name, args);
                if (results) return results;
                var channelName = this.channelName,
                    requests = this._requests;
                if (channelName && this._tunedIn && Radio.log.apply(this, [channelName, name].concat(args)), requests && (requests[name] || requests.default)) {
                    var handler = requests[name] || requests.default;
                    return args = requests[name] ? args : arguments, Radio._callHandler(handler.callback, handler.context, args)
                }
                Radio.debugLog("An unhandled request was fired", name, channelName)
            },
            reply: function(name, callback, context) {
                return Radio._eventsApi(this, "reply", name, [callback, context]) ? this : (this._requests || (this._requests = {}), this._requests[name] && Radio.debugLog("A request was overwritten", name, this.channelName), this._requests[name] = {
                    callback: makeCallback(callback),
                    context: context || this
                }, this)
            },
            replyOnce: function(name, callback, context) {
                if (Radio._eventsApi(this, "replyOnce", name, [callback, context])) return this;
                var self = this,
                    once = _.once(function() {
                        return self.stopReplying(name), makeCallback(callback).apply(this, arguments)
                    });
                return this.reply(name, once, context)
            },
            stopReplying: function(name, callback, context) {
                return Radio._eventsApi(this, "stopReplying", name) ? this : (name || callback || context ? function(store, name, callback, context) {
                    store || (store = {});
                    for (var names = name ? [name] : _.keys(store), matched = !1, i = 0, length = names.length; i < length; i++) store[name = names[i]] && removeHandler(store, name, callback, context) && (matched = !0);
                    return matched
                }(this._requests, name, callback, context) || Radio.debugLog("Attempted to remove the unregistered request", name, this.channelName) : delete this._requests, this)
            }
        }, Radio._channels = {}, Radio.channel = function(channelName) {
            if (!channelName) throw new Error("You must provide a name for the channel.");
            return Radio._channels[channelName] ? Radio._channels[channelName] : Radio._channels[channelName] = new Radio.Channel(channelName)
        }, Radio.Channel = function(channelName) {
            this.channelName = channelName
        }, _.extend(Radio.Channel.prototype, Backbone.Events, Radio.Requests, {
            reset: function() {
                return this.off(), this.stopListening(), this.stopReplying(), this
            }
        });
        var systems = [Backbone.Events, Radio.Requests];
        return _.each(systems, function(system) {
            _.each(system, function(method, methodName) {
                Radio[methodName] = function(channelName) {
                    return args = _.toArray(arguments).slice(1), (channel = this.channel(channelName))[methodName].apply(channel, args)
                }
            })
        }), Radio.reset = function(channelName) {
            var channels = channelName ? [this._channels[channelName]] : this._channels;
            _.each(channels, function(channel) {
                channel.reset()
            })
        }, Radio
    }, module.exports = factory(__webpack_require__(43), __webpack_require__(53))
}, function(module, exports, __webpack_require__) {
    Object.defineProperty(exports, "__esModule", {
        value: !0
    });
    var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor)
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor
            }
        }(),
        _jquery2 = _interopRequireDefault(__webpack_require__(69)),
        _swiperBundle2 = _interopRequireDefault(__webpack_require__(346)),
        _brightcove2 = _interopRequireDefault(__webpack_require__(347));

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        }
    }
    var Feature = function() {
        function Feature() {
            ! function(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
            }(this, Feature), this.example = "example"
        }
        return _createClass(Feature, [{
            key: "closeQuickview",
            value: function() {
                (0, _jquery2.default)(".quick-view__close").trigger("click")
            }
        }, {
            key: "init",
            value: function() {
                this.example = "initialized", this.mediumLargeBreakpoint = 1e3, this.mobileSlides = [], this.tabletSlides = [], this.desktopSlides = [], this.maxProductsPerApiCall = 12, this.minimumQuickviewWidth = 1e3, this.productDataLoaded = !1, this.animateProductDrawer = !0, this.swiperIsOut = !1, this.productIds = [], this.productData = [], this.swiperOptions = {
                    speed: 800,
                    preventClicksPropagation: !0,
                    preventClicks: !0,
                    preloadImages: !1,
                    hashNavigation: !0,
                    lazy: {
                        loadPrevNext: !0,
                        loadPrevNextAmount: 7
                    },
                    navigation: {
                        nextEl: ".hfth-button-next",
                        prevEl: ".hfth-button-prev"
                    },
                    keyboard: {
                        enabled: !0,
                        onlyInViewport: !1
                    }
                }, this.initSwiper(), this.captureSlides(), this.initSize(), this.addListeners()
            }
        }, {
            key: "checkAllSlidesNew",
            value: function() {
                (0, _jquery2.default)(".swiper-slide").each(function() {
                    (0, _jquery2.default)(this).find(".api-product").length && ((0, _jquery2.default)(this).addClass("hasProducts"), (0, _jquery2.default)(this).find(".hfth-page").addClass("hasProducts"))
                })
            }
        }, {
            key: "checkForProductsNew",
            value: function() {
                var _this2 = this,
                    _this = this,
                    activeSlide = this.s.slides[this.s.activeIndex],
                    productArray = [];
                (0, _jquery2.default)(activeSlide).find(".api-product").length && (0, _jquery2.default)(activeSlide).find(".api-product").each(function(index, element) {
                    var newProduct = (0, _jquery2.default)(element).data("id"); - 1 === productArray.indexOf(newProduct) && productArray.push(newProduct)
                }), productArray.length ? this.loadAllProductData(productArray, activeSlide).then(function(res) {
                    var productData = JSON.parse(res.result),
                        html = "",
                        numAvailableProducts = 0;
                    _jquery2.default.each(productData, function(key, value) {
                        value.product.availability.available && numAvailableProducts < 8 && (console.log("hfth console: value: " + value.product), numAvailableProducts += 1, html += _this.buildProduct(value.product))
                    }), 0 === numAvailableProducts && (0, _jquery2.default)("#main-product-drawer").removeClass("products-init"), (0, _jquery2.default)("#main-product-drawer .products").html(html), (0, _jquery2.default)("#main-product-drawer img").one("load", function() {
                        _this2.setProductDrawerHeight(), _this2.checkDrawerAnimation()
                    }).each(function() {
                        this.complete && (0, _jquery2.default)(this).trigger("load")
                    }), _this2.setProductDrawerHeight(), _this2.checkProductLinks(), (0, _jquery2.default)(activeSlide).hasClass("hasProducts") ? (0, _jquery2.default)("#main-product-drawer").addClass("products-init") : (0, _jquery2.default)("#main-product-drawer").removeClass("products-init"), (0, _jquery2.default)("#main-product-drawer .api-product").on("click", function() {
                        _this.fireLinkTag("hfth-product-click:" + (0, _jquery2.default)(this).find("a").data("id"))
                    })
                }) : (0, _jquery2.default)("#main-product-drawer").removeClass("products-init")
            }
        }, {
            key: "getProductURL",
            value: function(productData) {
            	return './json/product-1.json'
                //return "https://bloomingdales.com/xapi/discover/v1/product?productIds=" + productArray.toString()
            }
        }, {
            key: "loadAllProductData",
            value: function(productArray, activeSlide) {
            	var productData = (0, _jquery2.default)(activeSlide).data('product-data');
            	if(productData === undefined) {
            		productData = './json/product-1.json';
            	}
                var url = productData;
                return new Promise(function(resolve) {
                    fetch(url, {
                        method: "GET"
                    }).then(function(response) {
                        return response.text()
                    }).then(function(result) {
                        resolve({
                            result: result
                        })
                    }).catch(function(error) {
                        return console.log("hfth console error", error)
                    })
                })
            }
        }, {
            key: "captureSlides",
            value: function() {
                var _this = this;
                (0, _jquery2.default)("#slider-mobile").find(".swiper-slide").each(function() {
                    var el = (0, _jquery2.default)(this).prop("outerHTML");
                    _this.mobileSlides.push(el)
                }), (0, _jquery2.default)("#slider-mobile").remove(), (0, _jquery2.default)("#slider-tablet").find(".swiper-slide").each(function() {
                    var el = (0, _jquery2.default)(this).prop("outerHTML");
                    _this.tabletSlides.push(el)
                }), (0, _jquery2.default)("#slider-tablet").remove(), (0, _jquery2.default)("#slider-desktop").find(".swiper-slide").each(function() {
                    var el = (0, _jquery2.default)(this).prop("outerHTML");
                    _this.desktopSlides.push(el)
                }), (0, _jquery2.default)("#slider-desktop").remove()
            }
        }, {
            key: "initSize",
            value: function() {
                var _this3 = this;
                arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                window.addEventListener("resize", this.debounce(function(ms) {
                    _this3.triggerWindowResize()
                })), this.triggerWindowResize()
            }
        }, {
            key: "triggerWindowResize",
            value: function() {
                this.setContainerSize(), this.checkSize(), this.checkProductLinks(), this.setTextBoxes(), this.checkRecipeOverlay(), this.setProductDrawerHeight()
            }
        }, {
            key: "debounce",
            value: function(func) {
                var ms = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 50,
                    timer = void 0;
                return function(event) {
                    timer && clearTimeout(timer), timer = setTimeout(func, ms, event)
                }
            }
        }, {
            key: "setContainerSize",
            value: function() {
                (0, _jquery2.default)(".hfth-container").height(window.innerHeight)
            }
        }, {
            key: "checkRecipeOverlay",
            value: function() {
                var wHeight = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : (0, _jquery2.default)(window).height(),
                    navHeight = (0, _jquery2.default)(".hfth-nav").height();
                (0, _jquery2.default)(".recipe-overlay").height(wHeight - navHeight), (0, _jquery2.default)(".recipe-overlay").css("top", navHeight)
            }
        }, {
            key: "checkSize",
            value: function() {
                var wWidth = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : (0, _jquery2.default)(window).width();
                console.log("hfth console checkSize: " + this.currentState);
                var w = wWidth;
                this.isMobile() || w < 600 ? 3 !== this.currentState && (console.log("hfth console: checkSize: 3"), this.setState(3, this.mobileSlides)) : w > this.mediumLargeBreakpoint ? 2 !== this.currentState && (console.log("hfth console: checkSize: 2"), this.setState(2, this.desktopSlides)) : 1 !== this.currentState && (console.log("hfth console: checkSize: 1"), this.setState(1, this.tabletSlides)), this.closeQuickview()
            }
        }, {
            key: "isMobile",
            value: function() {
                var a, forceTrue = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
                    check = !1;
                return a = navigator.userAgent || navigator.vendor || window.opera, (forceTrue || /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) && (check = !0), check
            }
        }, {
            key: "removeSizeClasses",
            value: function() {
                (0, _jquery2.default)("#main").removeClass("hfth-mobile"), (0, _jquery2.default)("#main").removeClass("hfth-tablet"), (0, _jquery2.default)("#main").removeClass("hfth-desktop")
            }
        }, {
            key: "fireLinkTag",
            value: function(event, pageName) {
                var activeSlide = this.s.slides[this.s.activeIndex],
                    currentPage = (0, _jquery2.default)(activeSlide).data("hash"),
                    page = void 0;
                page = void 0 === pageName ? currentPage : pageName;
                try {
                    window.utag.link({
                        event_name: event + ":" + page
                    })
                } catch (error) {
                    console.log(error)
                }
            }
        }, {
            key: "fireLinkTagOnly",
            value: function(event) {
                try {
                    window.utag.link({
                        event_name: event
                    })
                } catch (error) {
                    console.log(error)
                }
            }
        }, {
            key: "fireViewTag",
            value: function(page) {
                try {
                    window.utag.link({
                        event_name: "hfth-view:" + page
                    })
                } catch (error) {
                    console.log(error)
                }
            }
        }, {
            key: "setState",
            value: function(index, slideArray) {
                switch (console.log("hfth console: setState: " + index), this.currentState = index, this.s.params.shortSwipes = !1, this.removeSizeClasses(), index) {
                    case 3:
                        (0, _jquery2.default)("#main").addClass("hfth-mobile"), this.s.params.shortSwipes = !0, this.s.params.threshold = 0, this.s.params.speed = 300, (0, _jquery2.default)(".hfth-swipe-to-navigate").removeClass("hide-it"), this.animateSwipeScreen();
                        break;
                    case 2:
                        (0, _jquery2.default)("#main").addClass("hfth-desktop"), this.s.params.shortSwipes = !1, this.s.params.threshold = 10, (0, _jquery2.default)(".hfth-swipe-to-navigate").addClass("hide-it");
                        break;
                    case 1:
                        (0, _jquery2.default)("#main").addClass("hfth-tablet"), this.s.params.shortSwipes = !0, this.s.params.threshold = 0, (0, _jquery2.default)(".hfth-swipe-to-navigate").addClass("hide-it");
                        break;
                    default:
                        console.log("hfth console switch statement default")
                }
                this.currentHash = this.getHash(), this.s.removeAllSlides(), this.s.appendSlide(slideArray), this.s.init(), this.checkAllSlidesNew(), this.checkForVideo(), location.hash = "#" + this.currentHash;
                var hashValue = this.getHash(),
                    hashTranslatedIndex = this.getIndexFromHash(hashValue);
                hashTranslatedIndex > -1 && this.s.slideTo(hashTranslatedIndex, 0), this.setSlideListeners(), this.setTextBoxes(), this.addProductClasses(), this.checkForProductsNew()
            }
        }, {
            key: "checkDrawerAnimation",
            value: function() {
                var _this4 = this;
                this.animateProductDrawer && !this.swiperIsOut && (0, _jquery2.default)("#main-product-drawer .api-product").length && (this.animateProductDrawer = !1, this.openDrawer(), setTimeout(function() {
                    _this4.closeDrawer()
                }, 2e3))
            }
        }, {
            key: "animateSwipeScreen",
            value: function() {
                var _this5 = this,
                    timer1 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1e3,
                    timer2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1500;
                this.swiperIsOut = !0, setTimeout(function() {
                    (0, _jquery2.default)(".hfth-swipe-to-navigate").addClass("close"), setTimeout(function() {
                        (0, _jquery2.default)(".hfth-swipe-to-navigate").addClass("hide-it"), _this5.swiperIsOut = !1, _this5.checkDrawerAnimation()
                    }, timer1)
                }, timer2)
            }
        }, {
            key: "slideToHash",
            value: function(hash) {
                var hashTranslatedIndex = this.getIndexFromHash(hash);
                hashTranslatedIndex >= 0 && hashTranslatedIndex !== this.s.activeIndex && this.s.slideTo(hashTranslatedIndex, 1e3)
            }
        }, {
            key: "getIndexFromHash",
            value: function(hash) {
                var indexMatched = -1;
                return (0, _jquery2.default)(".swiper-slide").each(function(index) {
                    console.log("hfth console: hash from each: " + (0, _jquery2.default)(this).data("hash") + " " + hash), (0, _jquery2.default)(this).data("hash") === hash && -1 === indexMatched && (indexMatched = index)
                }), indexMatched
            }
        }, {
            key: "initSwiper",
            value: function() {
                var _this6 = this;
                this.s = new _swiperBundle2.default(".swiper", this.swiperOptions), this.s.on("slideChange", function() {
                    _this6.setTextBoxes(), _this6.closeDrawer(), _this6.closeQuickview()
                }), this.s.on("activeIndexChange", function() {
                    _this6.slideIndex = _this6.s.activeIndex, _this6.setNavSection(), _this6.pauseVideos(), _this6.checkForVideo(), _this6.checkForProductsNew(), _this6.closeRecipeOverlay(0), console.log("hfth console: activeIndexChange: " + _this6.s.activeIndex)
                }), this.s.on("slideChangeTransitionEnd", function() {
                    var activeSlide = _this6.s.slides[_this6.s.activeIndex];
                    _this6.fireViewTag((0, _jquery2.default)(activeSlide).data("hash"))
                })
            }
        }, {
            key: "pauseVideos",
            value: function() {
                (0, _jquery2.default)("video").trigger("pause")
            }
        }, {
            key: "addProductClasses",
            value: function() {
                var activeSlide = this.s.slides[this.s.activeIndex];
                (0, _jquery2.default)(activeSlide).hasClass("hasProducts") || (0, _jquery2.default)("#main-product-drawer").removeClass("products-init")
            }
        }, {
            key: "checkForVideo",
            value: function() {
                var activeSlide = this.s.slides[this.s.activeIndex],
                    nextSlide = this.s.slides[this.s.activeIndex + 1],
                    prevSlide = this.s.slides[this.s.activeIndex - 1];
                (0, _jquery2.default)(activeSlide).find(".video-div").length && this.checkSlideForVideo(activeSlide), (0, _jquery2.default)(nextSlide).find(".video-div").length && this.checkSlideForVideo(nextSlide), (0, _jquery2.default)(prevSlide).find(".video-div").length && this.checkSlideForVideo(prevSlide)
            }
        }, {
            key: "checkSlideForVideo",
            value: function(el) {
                var videoDiv = (0, _jquery2.default)(el).find(".video-div");
                videoDiv.hasClass("video-loaded") ? videoDiv.data("autoplay") && (0, _jquery2.default)(el).find("video").trigger("play") : (new _brightcove2.default({}, this).loadVideo(videoDiv), videoDiv.addClass("video-loaded"))
            }
        }, {
            key: "setNavSection",
            value: function() {
                var activeSlide = this.s.slides[this.s.activeIndex],
                    sectionName = (0, _jquery2.default)(activeSlide).data("section");
                (0, _jquery2.default)(".nav-links a.active").removeClass("active"), (0, _jquery2.default)(".nav-links a").filter(function() {
                    return (0, _jquery2.default)(this).text() === sectionName
                }).addClass("active"), (0, _jquery2.default)(".filter-select option").prop("selected", !1), (0, _jquery2.default)(".filter-select option").filter(function() {
                    return (0, _jquery2.default)(this).text() === sectionName
                }).prop("selected", !0)
            }
        }, {
            key: "setProductDrawerHeight",
            value: function() {
                var drawerHeight = (0, _jquery2.default)("#main-product-drawer .products").height() + (0, _jquery2.default)("#main-product-drawer .product-drawer-title").height(),
                    maxTabletHeight = (0, _jquery2.default)(window).height() - 40,
                    maxMobileHeight = (0, _jquery2.default)(window).height() - (0, _jquery2.default)(".hfth-nav").height() - 40,
                    mobileHeight = drawerHeight;
                mobileHeight > maxMobileHeight && (mobileHeight = maxMobileHeight);
                var tabletHeight = drawerHeight;
                tabletHeight > maxTabletHeight && (tabletHeight = maxTabletHeight), document.getElementById("main-product-drawer").style.setProperty("--product-drawer-height", drawerHeight + 30 + "px"), document.getElementById("main-product-drawer").style.setProperty("--product-drawer-height-mobile", mobileHeight + 40 + "px"), document.getElementById("main-product-drawer").style.setProperty("--product-drawer-height-tablet", tabletHeight + 40 + "px")
            }
        }, {
            key: "checkProductLinks",
            value: function() {
                (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : (0, _jquery2.default)(window).width()) < this.minimumQuickviewWidth ? (0, _jquery2.default)(".qvDesktop").removeClass("qvLauncher") : (0, _jquery2.default)(".qvDesktop").addClass("qvLauncher")
            }
        }, {
            key: "setQvListeners",
            value: function() {
                (0, _jquery2.default)(".api-product a").off(), (0, _jquery2.default)(".api-product a").on("click", function(e) {
                    (0, _jquery2.default)(this).hasClass("qvLauncher") && (e.preventDefault(), (0, _jquery2.default)("#item-" + (0, _jquery2.default)(this).data("id")).trigger("click"))
                })
            }
        }, {
            key: "buildProduct",
            value: function(productData) {
                return console.log("hfth console: " + JSON.stringify(productData)), '<div class="api-product" tabindex="-1"><a href="https://www.bloomingdales.com/shop/product/?ID=' + productData.id + '" utag="" class="qvDesktop qvLauncher" data-id="' + productData.id + '" tabindex="-1">\n      <div class="product-photo-outer" tabindex="-1">\n        <img class="product-photo" src="' + this.getImage(productData.imagery) + '" tabindex="-1" />\n        <img class="size-photo" src="https://images.ctfassets.net/m3h9iuk14rnq/1DP4ZgGH9tGkpxSgskBXvf/ecf0e532c0291d8b574831df17d998c8/productPlaceholder.gif" tabindex="-1" />\n      </div>\n      <div class="product-text-outer" tabindex="-1">\n        <p class="product-title brand-name" tabindex="-1">' + productData.detail.brand + '</p>\n        <p class="price" tabindex="-1">' + this.getPrice(productData.pricing.price) + "</p>\n      </div>\n    </a></div>"
            }
        }, {
            key: "getImage",
            value: function(imagery) {
                return imagery.urlTemplate.replace("[IMAGEFILEPATH]", imagery.primaryImage.filePath)
            }
        }, {
            key: "getPrice",
            value: function(price) {
                return console.log("price: " + JSON.stringify(price)), price.tieredPrice[price.tieredPrice.length - 1].label.replace("[PRICE]", price.tieredPrice[price.tieredPrice.length - 1].values[0].formattedValue)
            }
        }, {
            key: "getHash",
            value: function() {
                return window.location.hash.substr(1)
            }
        }, {
            key: "setSlideListeners",
            value: function() {
                var _this7 = this;
                console.log("hfth console: setSlideListeners");
                var _this = this;
                (0, _jquery2.default)("#main-product-drawer .product-drawer-title").off(), (0, _jquery2.default)("#main-product-drawer .product-drawer-title").on("mousedown", function(e) {
                    e.stopPropagation(), _this7.toggleDrawer()
                });
                var numLoaded = 0;
                (0, _jquery2.default)(".swiper-slide img").one("load", function() {
                    _this.setTextBoxes(), numLoaded += 1, console.log("hfth console: numLoaded: " + numLoaded)
                }).each(function() {
                    this.complete && (0, _jquery2.default)(this).trigger("load")
                }), (0, _jquery2.default)(".launch-recipe").on("click", function(e) {
                    e.preventDefault(), _this.pauseVideos(), "#" !== (0, _jquery2.default)(this).attr("href") && _this.openRecipeOverlay((0, _jquery2.default)(this).attr("href"))
                }), (0, _jquery2.default)(".watch-video-link").on("click", function(e) {
                    e.preventDefault(), "#" !== (0, _jquery2.default)(this).attr("href") && _this.slideToHash((0, _jquery2.default)(this).attr("href"))
                }), (0, _jquery2.default)(".recipe-index-item a").on("click", function(e) {
                    e.preventDefault(), "#" !== (0, _jquery2.default)(this).attr("href") && _this.slideToHash((0, _jquery2.default)(this).attr("href").replace("#", ""))
                }), (0, _jquery2.default)(".hfth-button-prev").on("click", function() {
                    var activeSlide = _this7.s.slides[_this7.s.previousIndex],
                        page = (0, _jquery2.default)(activeSlide).data("hash");
                    _this7.fireLinkTag("hfth-previous-arrow-click", page)
                }), (0, _jquery2.default)(".hfth-button-next").on("click", function() {
                    var activeSlide = _this7.s.slides[_this7.s.previousIndex],
                        page = (0, _jquery2.default)(activeSlide).data("hash");
                    _this7.fireLinkTag("hfth-next-arrow-click", page)
                }), (0, _jquery2.default)(".hfth-track").on("click", function() {
                    (0, _jquery2.default)(this).data("utag") && _this.fireLinkTag((0, _jquery2.default)(this).data("utag"))
                }), (0, _jquery2.default)("#product-drawer-cover").on("click", function() {
                    _this7.fireLinkTag("hfth-product-drawer-close"), _this7.closeDrawer()
                })
            }
        }, {
            key: "addListeners",
            value: function() {
                var _this8 = this,
                    _this = this;
                (0, _jquery2.default)(".nav-links a").on("click", function(e) {
                    e.preventDefault();
                    var h = (0, _jquery2.default)(this).attr("href").replace("#", "");
                    _this.slideToHash(h), _this.fireLinkTagOnly("hfth-nav-click-" + h)
                }), (0, _jquery2.default)(".nav-tagline a").on("click", function(e) {
                    e.preventDefault(), _this.slideToHash((0, _jquery2.default)(this).attr("href").replace("#", "")), _this.fireLinkTagOnly("hfth-tagline-click")
                }), (0, _jquery2.default)(".filter-select select").on("change", function() {
                    _this.slideToHash(this.value), _this.fireLinkTagOnly("hfth-dropdown-select-" + this.value)
                }), (0, _jquery2.default)(".recipe-overlay .close-btn").on("click", function() {
                    _this8.closeRecipeOverlay(), _this.fireLinkTag("hfth-close-recipe-overlay")
                }), (0, _jquery2.default)(".logo a").on("click", function() {
                    _this8.fireLinkTagOnly("hfth-bloomingdales-logo-click")
                })
            }
        }, {
            key: "openRecipeOverlay",
            value: function(id) {
                (0, _jquery2.default)("#" + id).addClass("open"), (0, _jquery2.default)("#" + id).removeClass("init")
            }
        }, {
            key: "closeRecipeOverlay",
            value: function() {
                var speed = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 500;
                (0, _jquery2.default)(".recipe-overlay").removeClass("open"), setTimeout(function() {
                    (0, _jquery2.default)(".recipe-overlay").addClass("init")
                }, speed)
            }
        }, {
            key: "calculateProportion",
            value: function(w, h) {
                return w / h
            }
        }, {
            key: "setTextBoxes",
            value: function() {
                console.log("hfth console: setTextBoxes");
                var _this = this;
                (0, _jquery2.default)(".module-1").each(function() {
                    if ((0, _jquery2.default)(this).find("img").length) {
                        var img = void 0;
                        img = (0, _jquery2.default)(this).hasClass("reverse") ? (0, _jquery2.default)(this).find(".right .img img")[0] : (0, _jquery2.default)(this).find(".left .img img")[0];
                        var imgSize = _this.getImgSizeInfo(img);
                        (0, _jquery2.default)(this).find(".copy").width(imgSize.width)
                    }
                }), (0, _jquery2.default)(".module-2").has("video").not(".tablet").each(function() {
                    var imgHeight = (0, _jquery2.default)(this).find(".page-inner").height() - ((0, _jquery2.default)(this).find(".copy-top").height() + (0, _jquery2.default)(this).find(".copy-bottom").height());
                    (0, _jquery2.default)(this).find(".img").height(imgHeight);
                    var dim = _this.calculateAspectRatioFit(1365, 720, (0, _jquery2.default)(this).find(".img").width(), (0, _jquery2.default)(this).find(".img").height());
                    (0, _jquery2.default)(this).find("video").width(dim.width + 4).height(dim.height + 4), (0, _jquery2.default)(this).find(".video-div").width(dim.width).height(dim.height).css("margin", "0 auto"), (0, _jquery2.default)(this).find(".plyr").width(dim.width).height(dim.height).addClass("isLoaded"), (0, _jquery2.default)(this).find(".img").height(dim.width), (0, _jquery2.default)(this).find(".img").height(dim.height), (0, _jquery2.default)(this).hasClass("tablet") || ((0, _jquery2.default)(this).find(".copy-top").width(dim.width), (0, _jquery2.default)(this).find(".copy-bottom").width(dim.width))
                }), (0, _jquery2.default)(".module-2").not(".tablet").each(function() {
                    if ((0, _jquery2.default)(this).find("img").length) {
                        var img = (0, _jquery2.default)(this).find(".img img")[0],
                            imgSize = _this.getImgSizeInfo(img);
                        (0, _jquery2.default)(this).find(".copy-top").width(imgSize.width), (0, _jquery2.default)(this).find(".copy-bottom").width(imgSize.width)
                    }
                }), (0, _jquery2.default)(".module-cover").not(".tablet").not(".mobile").each(function() {
                    console.log("hfth console: module-cover resize")
                }), (0, _jquery2.default)(".module-1-tablet").each(function() {
                    console.log("hfth console: module-1-tablet resize")
                }), (0, _jquery2.default)(".module-juicy").not(".tablet").not(".mobile").each(function() {})
            }
        }, {
            key: "calculateAspectRatioFit",
            value: function(srcWidth, srcHeight, maxWidth, maxHeight) {
                var ratio = Math.min(maxWidth / srcWidth, maxHeight / srcHeight);
                return {
                    width: srcWidth * ratio,
                    height: srcHeight * ratio
                }
            }
        }, {
            key: "toggleDrawer",
            value: function() {
                (0, _jquery2.default)("#main-product-drawer").hasClass("open") ? (this.fireLinkTag("hfth-product-drawer-close"), this.closeDrawer()) : (this.fireLinkTag("hfth-product-drawer-open"), this.openDrawer())
            }
        }, {
            key: "openDrawer",
            value: function() {
                (0, _jquery2.default)("#product-drawer-cover").removeClass("init"), (0, _jquery2.default)("#product-drawer-cover").addClass("open"), (0, _jquery2.default)("#main-product-drawer").addClass("open")
            }
        }, {
            key: "closeDrawer",
            value: function() {
                (0, _jquery2.default)("#main-product-drawer").removeClass("open"), (0, _jquery2.default)("#product-drawer-cover").removeClass("open"), setTimeout(function() {
                    (0, _jquery2.default)("#product-drawer-cover").addClass("init")
                }, 500)
            }
        }, {
            key: "getRenderedSize",
            value: function(contains, cWidth, cHeight, width, height) {
                var oRatio = width / height,
                    cRatio = cWidth / cHeight;
                return function() {
                    return (contains ? oRatio > cRatio : oRatio < cRatio) ? (this.width = cWidth, this.height = cWidth / oRatio) : (this.width = cHeight * oRatio, this.height = cHeight), this
                }.call({})
            }
        }, {
            key: "getImgSizeInfo",
            value: function(img) {
                return this.getRenderedSize(!0, img.width, img.height, img.naturalWidth, img.naturalHeight)
            }
        }, {
            key: "getVideoSizeInfo",
            value: function(img) {
                return this.getRenderedSize(!0, img.width, img.height, img.videoWidth, img.videoHeight)
            }
        }]), Feature
    }();
    exports.default = Feature
}, function(module, exports, __webpack_require__) {
    var t;
    t = function() {
        "use strict";

        function e(e) {
            return null !== e && "object" == typeof e && "constructor" in e && e.constructor === Object
        }

        function t(s = {}, a = {}) {
            Object.keys(a).forEach(i => {
                void 0 === s[i] ? s[i] = a[i] : e(a[i]) && e(s[i]) && Object.keys(a[i]).length > 0 && t(s[i], a[i])
            })
        }
        const s = {
            body: {},
            addEventListener() {},
            removeEventListener() {},
            activeElement: {
                blur() {},
                nodeName: ""
            },
            querySelector: () => null,
            querySelectorAll: () => [],
            getElementById: () => null,
            createEvent: () => ({
                initEvent() {}
            }),
            createElement: () => ({
                children: [],
                childNodes: [],
                style: {},
                setAttribute() {},
                getElementsByTagName: () => []
            }),
            createElementNS: () => ({}),
            importNode: () => null,
            location: {
                hash: "",
                host: "",
                hostname: "",
                href: "",
                origin: "",
                pathname: "",
                protocol: "",
                search: ""
            }
        };

        function a() {
            const e = "undefined" != typeof document ? document : {};
            return t(e, s), e
        }
        const i = {
            document: s,
            navigator: {
                userAgent: ""
            },
            location: {
                hash: "",
                host: "",
                hostname: "",
                href: "",
                origin: "",
                pathname: "",
                protocol: "",
                search: ""
            },
            history: {
                replaceState() {},
                pushState() {},
                go() {},
                back() {}
            },
            CustomEvent: function() {
                return this
            },
            addEventListener() {},
            removeEventListener() {},
            getComputedStyle: () => ({
                getPropertyValue: () => ""
            }),
            Image() {},
            Date() {},
            screen: {},
            setTimeout() {},
            clearTimeout() {},
            matchMedia: () => ({}),
            requestAnimationFrame: e => "undefined" == typeof setTimeout ? (e(), null) : setTimeout(e, 0),
            cancelAnimationFrame(e) {
                "undefined" != typeof setTimeout && clearTimeout(e)
            }
        };

        function r() {
            const e = "undefined" != typeof window ? window : {};
            return t(e, i), e
        }
        class n extends Array {
            constructor(e) {
                super(...e || []),
                    function(e) {
                        const t = e.__proto__;
                        Object.defineProperty(e, "__proto__", {
                            get: () => t,
                            set(e) {
                                t.__proto__ = e
                            }
                        })
                    }(this)
            }
        }

        function l(e = []) {
            const t = [];
            return e.forEach(e => {
                Array.isArray(e) ? t.push(...l(e)) : t.push(e)
            }), t
        }

        function o(e, t) {
            return Array.prototype.filter.call(e, t)
        }

        function d(e, t) {
            const s = r(),
                i = a();
            let l = [];
            if (!t && e instanceof n) return e;
            if (!e) return new n(l);
            if ("string" == typeof e) {
                const s = e.trim();
                if (s.indexOf("<") >= 0 && s.indexOf(">") >= 0) {
                    let e = "div";
                    0 === s.indexOf("<li") && (e = "ul"), 0 === s.indexOf("<tr") && (e = "tbody"), 0 !== s.indexOf("<td") && 0 !== s.indexOf("<th") || (e = "tr"), 0 === s.indexOf("<tbody") && (e = "table"), 0 === s.indexOf("<option") && (e = "select");
                    const t = i.createElement(e);
                    t.innerHTML = s;
                    for (let e = 0; e < t.childNodes.length; e += 1) l.push(t.childNodes[e])
                } else l = function(e, t) {
                    if ("string" != typeof e) return [e];
                    const s = [],
                        a = t.querySelectorAll(e);
                    for (let e = 0; e < a.length; e += 1) s.push(a[e]);
                    return s
                }(e.trim(), t || i)
            } else if (e.nodeType || e === s || e === i) l.push(e);
            else if (Array.isArray(e)) {
                if (e instanceof n) return e;
                l = e
            }
            return new n(function(e) {
                const t = [];
                for (let s = 0; s < e.length; s += 1) - 1 === t.indexOf(e[s]) && t.push(e[s]);
                return t
            }(l))
        }
        d.fn = n.prototype;
        const c = {
            addClass: function(...e) {
                const t = l(e.map(e => e.split(" ")));
                return this.forEach(e => {
                    e.classList.add(...t)
                }), this
            },
            removeClass: function(...e) {
                const t = l(e.map(e => e.split(" ")));
                return this.forEach(e => {
                    e.classList.remove(...t)
                }), this
            },
            hasClass: function(...e) {
                const t = l(e.map(e => e.split(" ")));
                return o(this, e => t.filter(t => e.classList.contains(t)).length > 0).length > 0
            },
            toggleClass: function(...e) {
                const t = l(e.map(e => e.split(" ")));
                this.forEach(e => {
                    t.forEach(t => {
                        e.classList.toggle(t)
                    })
                })
            },
            attr: function(e, t) {
                if (1 === arguments.length && "string" == typeof e) return this[0] ? this[0].getAttribute(e) : void 0;
                for (let s = 0; s < this.length; s += 1)
                    if (2 === arguments.length) this[s].setAttribute(e, t);
                    else
                        for (const t in e) this[s][t] = e[t], this[s].setAttribute(t, e[t]);
                return this
            },
            removeAttr: function(e) {
                for (let t = 0; t < this.length; t += 1) this[t].removeAttribute(e);
                return this
            },
            transform: function(e) {
                for (let t = 0; t < this.length; t += 1) this[t].style.transform = e;
                return this
            },
            transition: function(e) {
                for (let t = 0; t < this.length; t += 1) this[t].style.transitionDuration = "string" != typeof e ? `${e}ms` : e;
                return this
            },
            on: function(...e) {
                let [t, s, a, i] = e;

                function r(e) {
                    const t = e.target;
                    if (!t) return;
                    const i = e.target.dom7EventData || [];
                    if (i.indexOf(e) < 0 && i.unshift(e), d(t).is(s)) a.apply(t, i);
                    else {
                        const e = d(t).parents();
                        for (let t = 0; t < e.length; t += 1) d(e[t]).is(s) && a.apply(e[t], i)
                    }
                }

                function n(e) {
                    const t = e && e.target && e.target.dom7EventData || [];
                    t.indexOf(e) < 0 && t.unshift(e), a.apply(this, t)
                }
                "function" == typeof e[1] && ([t, a, i] = e, s = void 0), i || (i = !1);
                const l = t.split(" ");
                let o;
                for (let e = 0; e < this.length; e += 1) {
                    const t = this[e];
                    if (s)
                        for (o = 0; o < l.length; o += 1) {
                            const e = l[o];
                            t.dom7LiveListeners || (t.dom7LiveListeners = {}), t.dom7LiveListeners[e] || (t.dom7LiveListeners[e] = []), t.dom7LiveListeners[e].push({
                                listener: a,
                                proxyListener: r
                            }), t.addEventListener(e, r, i)
                        } else
                            for (o = 0; o < l.length; o += 1) {
                                const e = l[o];
                                t.dom7Listeners || (t.dom7Listeners = {}), t.dom7Listeners[e] || (t.dom7Listeners[e] = []), t.dom7Listeners[e].push({
                                    listener: a,
                                    proxyListener: n
                                }), t.addEventListener(e, n, i)
                            }
                }
                return this
            },
            off: function(...e) {
                let [t, s, a, i] = e;
                "function" == typeof e[1] && ([t, a, i] = e, s = void 0), i || (i = !1);
                const r = t.split(" ");
                for (let e = 0; e < r.length; e += 1) {
                    const t = r[e];
                    for (let e = 0; e < this.length; e += 1) {
                        const r = this[e];
                        let n;
                        if (!s && r.dom7Listeners ? n = r.dom7Listeners[t] : s && r.dom7LiveListeners && (n = r.dom7LiveListeners[t]), n && n.length)
                            for (let e = n.length - 1; e >= 0; e -= 1) {
                                const s = n[e];
                                a && s.listener === a || a && s.listener && s.listener.dom7proxy && s.listener.dom7proxy === a ? (r.removeEventListener(t, s.proxyListener, i), n.splice(e, 1)) : a || (r.removeEventListener(t, s.proxyListener, i), n.splice(e, 1))
                            }
                    }
                }
                return this
            },
            trigger: function(...e) {
                const t = r(),
                    s = e[0].split(" "),
                    a = e[1];
                for (let i = 0; i < s.length; i += 1) {
                    const r = s[i];
                    for (let s = 0; s < this.length; s += 1) {
                        const i = this[s];
                        if (t.CustomEvent) {
                            const s = new t.CustomEvent(r, {
                                detail: a,
                                bubbles: !0,
                                cancelable: !0
                            });
                            i.dom7EventData = e.filter((e, t) => t > 0), i.dispatchEvent(s), i.dom7EventData = [], delete i.dom7EventData
                        }
                    }
                }
                return this
            },
            transitionEnd: function(e) {
                const t = this;
                return e && t.on("transitionend", function s(a) {
                    a.target === this && (e.call(this, a), t.off("transitionend", s))
                }), this
            },
            outerWidth: function(e) {
                if (this.length > 0) {
                    if (e) {
                        const e = this.styles();
                        return this[0].offsetWidth + parseFloat(e.getPropertyValue("margin-right")) + parseFloat(e.getPropertyValue("margin-left"))
                    }
                    return this[0].offsetWidth
                }
                return null
            },
            outerHeight: function(e) {
                if (this.length > 0) {
                    if (e) {
                        const e = this.styles();
                        return this[0].offsetHeight + parseFloat(e.getPropertyValue("margin-top")) + parseFloat(e.getPropertyValue("margin-bottom"))
                    }
                    return this[0].offsetHeight
                }
                return null
            },
            styles: function() {
                const e = r();
                return this[0] ? e.getComputedStyle(this[0], null) : {}
            },
            offset: function() {
                if (this.length > 0) {
                    const e = r(),
                        t = a(),
                        s = this[0],
                        i = s.getBoundingClientRect(),
                        n = t.body,
                        l = s.clientTop || n.clientTop || 0,
                        o = s.clientLeft || n.clientLeft || 0,
                        d = s === e ? e.scrollY : s.scrollTop,
                        c = s === e ? e.scrollX : s.scrollLeft;
                    return {
                        top: i.top + d - l,
                        left: i.left + c - o
                    }
                }
                return null
            },
            css: function(e, t) {
                const s = r();
                let a;
                if (1 === arguments.length) {
                    if ("string" != typeof e) {
                        for (a = 0; a < this.length; a += 1)
                            for (const t in e) this[a].style[t] = e[t];
                        return this
                    }
                    if (this[0]) return s.getComputedStyle(this[0], null).getPropertyValue(e)
                }
                if (2 === arguments.length && "string" == typeof e) {
                    for (a = 0; a < this.length; a += 1) this[a].style[e] = t;
                    return this
                }
                return this
            },
            each: function(e) {
                return e ? (this.forEach((t, s) => {
                    e.apply(t, [t, s])
                }), this) : this
            },
            html: function(e) {
                if (void 0 === e) return this[0] ? this[0].innerHTML : null;
                for (let t = 0; t < this.length; t += 1) this[t].innerHTML = e;
                return this
            },
            text: function(e) {
                if (void 0 === e) return this[0] ? this[0].textContent.trim() : null;
                for (let t = 0; t < this.length; t += 1) this[t].textContent = e;
                return this
            },
            is: function(e) {
                const t = r(),
                    s = a(),
                    i = this[0];
                let l, o;
                if (!i || void 0 === e) return !1;
                if ("string" == typeof e) {
                    if (i.matches) return i.matches(e);
                    if (i.webkitMatchesSelector) return i.webkitMatchesSelector(e);
                    if (i.msMatchesSelector) return i.msMatchesSelector(e);
                    for (l = d(e), o = 0; o < l.length; o += 1)
                        if (l[o] === i) return !0;
                    return !1
                }
                if (e === s) return i === s;
                if (e === t) return i === t;
                if (e.nodeType || e instanceof n) {
                    for (l = e.nodeType ? [e] : e, o = 0; o < l.length; o += 1)
                        if (l[o] === i) return !0;
                    return !1
                }
                return !1
            },
            index: function() {
                let e, t = this[0];
                if (t) {
                    for (e = 0; null !== (t = t.previousSibling);) 1 === t.nodeType && (e += 1);
                    return e
                }
            },
            eq: function(e) {
                if (void 0 === e) return this;
                const t = this.length;
                if (e > t - 1) return d([]);
                if (e < 0) {
                    const s = t + e;
                    return d(s < 0 ? [] : [this[s]])
                }
                return d([this[e]])
            },
            append: function(...e) {
                let t;
                const s = a();
                for (let a = 0; a < e.length; a += 1) {
                    t = e[a];
                    for (let e = 0; e < this.length; e += 1)
                        if ("string" == typeof t) {
                            const a = s.createElement("div");
                            for (a.innerHTML = t; a.firstChild;) this[e].appendChild(a.firstChild)
                        } else if (t instanceof n)
                        for (let s = 0; s < t.length; s += 1) this[e].appendChild(t[s]);
                    else this[e].appendChild(t)
                }
                return this
            },
            prepend: function(e) {
                const t = a();
                let s, i;
                for (s = 0; s < this.length; s += 1)
                    if ("string" == typeof e) {
                        const a = t.createElement("div");
                        for (a.innerHTML = e, i = a.childNodes.length - 1; i >= 0; i -= 1) this[s].insertBefore(a.childNodes[i], this[s].childNodes[0])
                    } else if (e instanceof n)
                    for (i = 0; i < e.length; i += 1) this[s].insertBefore(e[i], this[s].childNodes[0]);
                else this[s].insertBefore(e, this[s].childNodes[0]);
                return this
            },
            next: function(e) {
                return this.length > 0 ? e ? this[0].nextElementSibling && d(this[0].nextElementSibling).is(e) ? d([this[0].nextElementSibling]) : d([]) : this[0].nextElementSibling ? d([this[0].nextElementSibling]) : d([]) : d([])
            },
            nextAll: function(e) {
                const t = [];
                let s = this[0];
                if (!s) return d([]);
                for (; s.nextElementSibling;) {
                    const a = s.nextElementSibling;
                    e ? d(a).is(e) && t.push(a) : t.push(a), s = a
                }
                return d(t)
            },
            prev: function(e) {
                if (this.length > 0) {
                    const t = this[0];
                    return e ? t.previousElementSibling && d(t.previousElementSibling).is(e) ? d([t.previousElementSibling]) : d([]) : t.previousElementSibling ? d([t.previousElementSibling]) : d([])
                }
                return d([])
            },
            prevAll: function(e) {
                const t = [];
                let s = this[0];
                if (!s) return d([]);
                for (; s.previousElementSibling;) {
                    const a = s.previousElementSibling;
                    e ? d(a).is(e) && t.push(a) : t.push(a), s = a
                }
                return d(t)
            },
            parent: function(e) {
                const t = [];
                for (let s = 0; s < this.length; s += 1) null !== this[s].parentNode && (e ? d(this[s].parentNode).is(e) && t.push(this[s].parentNode) : t.push(this[s].parentNode));
                return d(t)
            },
            parents: function(e) {
                const t = [];
                for (let s = 0; s < this.length; s += 1) {
                    let a = this[s].parentNode;
                    for (; a;) e ? d(a).is(e) && t.push(a) : t.push(a), a = a.parentNode
                }
                return d(t)
            },
            closest: function(e) {
                let t = this;
                return void 0 === e ? d([]) : (t.is(e) || (t = t.parents(e).eq(0)), t)
            },
            find: function(e) {
                const t = [];
                for (let s = 0; s < this.length; s += 1) {
                    const a = this[s].querySelectorAll(e);
                    for (let e = 0; e < a.length; e += 1) t.push(a[e])
                }
                return d(t)
            },
            children: function(e) {
                const t = [];
                for (let s = 0; s < this.length; s += 1) {
                    const a = this[s].children;
                    for (let s = 0; s < a.length; s += 1) e && !d(a[s]).is(e) || t.push(a[s])
                }
                return d(t)
            },
            filter: function(e) {
                return d(o(this, e))
            },
            remove: function() {
                for (let e = 0; e < this.length; e += 1) this[e].parentNode && this[e].parentNode.removeChild(this[e]);
                return this
            }
        };

        function p(e, t = 0) {
            return setTimeout(e, t)
        }

        function u() {
            return Date.now()
        }

        function h(e, t = "x") {
            const s = r();
            let a, i, n;
            const l = function(e) {
                const t = r();
                let s;
                return t.getComputedStyle && (s = t.getComputedStyle(e, null)), !s && e.currentStyle && (s = e.currentStyle), s || (s = e.style), s
            }(e);
            return s.WebKitCSSMatrix ? ((i = l.transform || l.webkitTransform).split(",").length > 6 && (i = i.split(", ").map(e => e.replace(",", ".")).join(", ")), n = new s.WebKitCSSMatrix("none" === i ? "" : i)) : a = (n = l.MozTransform || l.OTransform || l.MsTransform || l.msTransform || l.transform || l.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,")).toString().split(","), "x" === t && (i = s.WebKitCSSMatrix ? n.m41 : 16 === a.length ? parseFloat(a[12]) : parseFloat(a[4])), "y" === t && (i = s.WebKitCSSMatrix ? n.m42 : 16 === a.length ? parseFloat(a[13]) : parseFloat(a[5])), i || 0
        }

        function m(e) {
            return "object" == typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1)
        }

        function f(...e) {
            const t = Object(e[0]),
                s = ["__proto__", "constructor", "prototype"];
            for (let i = 1; i < e.length; i += 1) {
                const r = e[i];
                if (null != r && (a = r, !("undefined" != typeof window && void 0 !== window.HTMLElement ? a instanceof HTMLElement : a && (1 === a.nodeType || 11 === a.nodeType)))) {
                    const e = Object.keys(Object(r)).filter(e => s.indexOf(e) < 0);
                    for (let s = 0, a = e.length; s < a; s += 1) {
                        const a = e[s],
                            i = Object.getOwnPropertyDescriptor(r, a);
                        void 0 !== i && i.enumerable && (m(t[a]) && m(r[a]) ? r[a].__swiper__ ? t[a] = r[a] : f(t[a], r[a]) : !m(t[a]) && m(r[a]) ? (t[a] = {}, r[a].__swiper__ ? t[a] = r[a] : f(t[a], r[a])) : t[a] = r[a])
                    }
                }
            }
            var a;
            return t
        }

        function g(e, t, s) {
            e.style.setProperty(t, s)
        }

        function v({
            swiper: e,
            targetPosition: t,
            side: s
        }) {
            const a = r(),
                i = -e.translate;
            let n, l = null;
            const o = e.params.speed;
            e.wrapperEl.style.scrollSnapType = "none", a.cancelAnimationFrame(e.cssModeFrameID);
            const d = t > i ? "next" : "prev",
                c = (e, t) => "next" === d && e >= t || "prev" === d && e <= t,
                p = () => {
                    n = (new Date).getTime(), null === l && (l = n);
                    const r = Math.max(Math.min((n - l) / o, 1), 0),
                        d = .5 - Math.cos(r * Math.PI) / 2;
                    let u = i + d * (t - i);
                    if (c(u, t) && (u = t), e.wrapperEl.scrollTo({
                            [s]: u
                        }), c(u, t)) return e.wrapperEl.style.overflow = "hidden", e.wrapperEl.style.scrollSnapType = "", setTimeout(() => {
                        e.wrapperEl.style.overflow = "", e.wrapperEl.scrollTo({
                            [s]: u
                        })
                    }), void a.cancelAnimationFrame(e.cssModeFrameID);
                    e.cssModeFrameID = a.requestAnimationFrame(p)
                };
            p()
        }
        let w, b, x;

        function y() {
            return w || (w = function() {
                const e = r(),
                    t = a();
                return {
                    smoothScroll: t.documentElement && "scrollBehavior" in t.documentElement.style,
                    touch: !!("ontouchstart" in e || e.DocumentTouch && t instanceof e.DocumentTouch),
                    passiveListener: function() {
                        let t = !1;
                        try {
                            const s = Object.defineProperty({}, "passive", {
                                get() {
                                    t = !0
                                }
                            });
                            e.addEventListener("testPassiveListener", null, s)
                        } catch (e) {}
                        return t
                    }(),
                    gestures: "ongesturestart" in e
                }
            }()), w
        }

        function E(e = {}) {
            return b || (b = function({
                userAgent: e
            } = {}) {
                const t = y(),
                    s = r(),
                    a = s.navigator.platform,
                    i = e || s.navigator.userAgent,
                    n = {
                        ios: !1,
                        android: !1
                    },
                    l = s.screen.width,
                    o = s.screen.height,
                    d = i.match(/(Android);?[\s\/]+([\d.]+)?/);
                let c = i.match(/(iPad).*OS\s([\d_]+)/);
                const p = i.match(/(iPod)(.*OS\s([\d_]+))?/),
                    u = !c && i.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
                    h = "Win32" === a;
                let m = "MacIntel" === a;
                return !c && m && t.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${l}x${o}`) >= 0 && ((c = i.match(/(Version)\/([\d.]+)/)) || (c = [0, 1, "13_0_0"]), m = !1), d && !h && (n.os = "android", n.android = !0), (c || u || p) && (n.os = "ios", n.ios = !0), n
            }(e)), b
        }

        function T() {
            return x || (x = function() {
                const e = r();
                return {
                    isSafari: function() {
                        const t = e.navigator.userAgent.toLowerCase();
                        return t.indexOf("safari") >= 0 && t.indexOf("chrome") < 0 && t.indexOf("android") < 0
                    }(),
                    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent)
                }
            }()), x
        }

        function $({
            swiper: e,
            runCallbacks: t,
            direction: s,
            step: a
        }) {
            const {
                activeIndex: i,
                previousIndex: r
            } = e;
            let n = s;
            if (n || (n = i > r ? "next" : i < r ? "prev" : "reset"), e.emit(`transition${a}`), t && i !== r) {
                if ("reset" === n) return void e.emit(`slideResetTransition${a}`);
                e.emit(`slideChangeTransition${a}`), "next" === n ? e.emit(`slideNextTransition${a}`) : e.emit(`slidePrevTransition${a}`)
            }
        }

        function k() {
            const e = this,
                {
                    params: t,
                    el: s
                } = e;
            if (s && 0 === s.offsetWidth) return;
            t.breakpoints && e.setBreakpoint();
            const {
                allowSlideNext: a,
                allowSlidePrev: i,
                snapGrid: r
            } = e;
            e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses(), ("auto" === t.slidesPerView || t.slidesPerView > 1) && e.isEnd && !e.isBeginning && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.run(), e.allowSlidePrev = i, e.allowSlideNext = a, e.params.watchOverflow && r !== e.snapGrid && e.checkOverflow()
        }
        Object.keys(c).forEach(e => {
            Object.defineProperty(d.fn, e, {
                value: c[e],
                writable: !0
            })
        });
        let I = !1;

        function L() {}
        const A = (e, t) => {
                const s = a(),
                    {
                        params: i,
                        touchEvents: r,
                        el: n,
                        wrapperEl: l,
                        device: o,
                        support: d
                    } = e,
                    c = !!i.nested,
                    p = "on" === t ? "addEventListener" : "removeEventListener",
                    u = t;
                if (d.touch) {
                    const t = !("touchstart" !== r.start || !d.passiveListener || !i.passiveListeners) && {
                        passive: !0,
                        capture: !1
                    };
                    n[p](r.start, e.onTouchStart, t), n[p](r.move, e.onTouchMove, d.passiveListener ? {
                        passive: !1,
                        capture: c
                    } : c), n[p](r.end, e.onTouchEnd, t), r.cancel && n[p](r.cancel, e.onTouchEnd, t)
                } else n[p](r.start, e.onTouchStart, !1), s[p](r.move, e.onTouchMove, c), s[p](r.end, e.onTouchEnd, !1);
                (i.preventClicks || i.preventClicksPropagation) && n[p]("click", e.onClick, !0), i.cssMode && l[p]("scroll", e.onScroll), i.updateOnWindowResize ? e[u](o.ios || o.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", k, !0) : e[u]("observerUpdate", k, !0)
            },
            D = (e, t) => e.grid && t.grid && t.grid.rows > 1;
        var G = {
            init: !0,
            direction: "horizontal",
            touchEventsTarget: "wrapper",
            initialSlide: 0,
            speed: 300,
            cssMode: !1,
            updateOnWindowResize: !0,
            resizeObserver: !0,
            nested: !1,
            createElements: !1,
            enabled: !0,
            focusableElements: "input, select, option, textarea, button, video, label",
            width: null,
            height: null,
            preventInteractionOnTransition: !1,
            userAgent: null,
            url: null,
            edgeSwipeDetection: !1,
            edgeSwipeThreshold: 20,
            autoHeight: !1,
            setWrapperSize: !1,
            virtualTranslate: !1,
            effect: "slide",
            breakpoints: void 0,
            breakpointsBase: "window",
            spaceBetween: 0,
            slidesPerView: 1,
            slidesPerGroup: 1,
            slidesPerGroupSkip: 0,
            slidesPerGroupAuto: !1,
            centeredSlides: !1,
            centeredSlidesBounds: !1,
            slidesOffsetBefore: 0,
            slidesOffsetAfter: 0,
            normalizeSlideIndex: !0,
            centerInsufficientSlides: !1,
            watchOverflow: !0,
            roundLengths: !1,
            touchRatio: 1,
            touchAngle: 45,
            simulateTouch: !0,
            shortSwipes: !0,
            longSwipes: !0,
            longSwipesRatio: .5,
            longSwipesMs: 300,
            followFinger: !0,
            allowTouchMove: !0,
            threshold: 0,
            touchMoveStopPropagation: !1,
            touchStartPreventDefault: !0,
            touchStartForcePreventDefault: !1,
            touchReleaseOnEdges: !1,
            uniqueNavElements: !0,
            resistance: !0,
            resistanceRatio: .85,
            watchSlidesProgress: !1,
            grabCursor: !1,
            preventClicks: !0,
            preventClicksPropagation: !0,
            slideToClickedSlide: !1,
            preloadImages: !0,
            updateOnImagesReady: !0,
            loop: !1,
            loopAdditionalSlides: 0,
            loopedSlides: null,
            loopFillGroupWithBlank: !1,
            loopPreventsSlide: !0,
            allowSlidePrev: !0,
            allowSlideNext: !0,
            swipeHandler: null,
            noSwiping: !0,
            noSwipingClass: "swiper-no-swiping",
            noSwipingSelector: null,
            passiveListeners: !0,
            containerModifierClass: "swiper-",
            slideClass: "swiper-slide",
            slideBlankClass: "swiper-slide-invisible-blank",
            slideActiveClass: "swiper-slide-active",
            slideDuplicateActiveClass: "swiper-slide-duplicate-active",
            slideVisibleClass: "swiper-slide-visible",
            slideDuplicateClass: "swiper-slide-duplicate",
            slideNextClass: "swiper-slide-next",
            slideDuplicateNextClass: "swiper-slide-duplicate-next",
            slidePrevClass: "swiper-slide-prev",
            slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
            wrapperClass: "swiper-wrapper",
            runCallbacksOnInit: !0,
            _emitClasses: !1
        };
        const B = {
                eventsEmitter: {
                    on(e, t, s) {
                        const a = this;
                        if ("function" != typeof t) return a;
                        const i = s ? "unshift" : "push";
                        return e.split(" ").forEach(e => {
                            a.eventsListeners[e] || (a.eventsListeners[e] = []), a.eventsListeners[e][i](t)
                        }), a
                    },
                    once(e, t, s) {
                        const a = this;
                        if ("function" != typeof t) return a;

                        function i(...s) {
                            a.off(e, i), i.__emitterProxy && delete i.__emitterProxy, t.apply(a, s)
                        }
                        return i.__emitterProxy = t, a.on(e, i, s)
                    },
                    onAny(e, t) {
                        const s = this;
                        if ("function" != typeof e) return s;
                        const a = t ? "unshift" : "push";
                        return s.eventsAnyListeners.indexOf(e) < 0 && s.eventsAnyListeners[a](e), s
                    },
                    offAny(e) {
                        const t = this;
                        if (!t.eventsAnyListeners) return t;
                        const s = t.eventsAnyListeners.indexOf(e);
                        return s >= 0 && t.eventsAnyListeners.splice(s, 1), t
                    },
                    off(e, t) {
                        const s = this;
                        return s.eventsListeners ? (e.split(" ").forEach(e => {
                            void 0 === t ? s.eventsListeners[e] = [] : s.eventsListeners[e] && s.eventsListeners[e].forEach((a, i) => {
                                (a === t || a.__emitterProxy && a.__emitterProxy === t) && s.eventsListeners[e].splice(i, 1)
                            })
                        }), s) : s
                    },
                    emit(...e) {
                        const t = this;
                        if (!t.eventsListeners) return t;
                        let s, a, i;
                        return "string" == typeof e[0] || Array.isArray(e[0]) ? (s = e[0], a = e.slice(1, e.length), i = t) : (s = e[0].events, a = e[0].data, i = e[0].context || t), a.unshift(i), (Array.isArray(s) ? s : s.split(" ")).forEach(e => {
                            t.eventsAnyListeners && t.eventsAnyListeners.length && t.eventsAnyListeners.forEach(t => {
                                t.apply(i, [e, ...a])
                            }), t.eventsListeners && t.eventsListeners[e] && t.eventsListeners[e].forEach(e => {
                                e.apply(i, a)
                            })
                        }), t
                    }
                },
                update: {
                    updateSize: function() {
                        const e = this;
                        let t, s;
                        const a = e.$el;
                        t = void 0 !== e.params.width && null !== e.params.width ? e.params.width : a[0].clientWidth, s = void 0 !== e.params.height && null !== e.params.height ? e.params.height : a[0].clientHeight, 0 === t && e.isHorizontal() || 0 === s && e.isVertical() || (t = t - parseInt(a.css("padding-left") || 0, 10) - parseInt(a.css("padding-right") || 0, 10), s = s - parseInt(a.css("padding-top") || 0, 10) - parseInt(a.css("padding-bottom") || 0, 10), Number.isNaN(t) && (t = 0), Number.isNaN(s) && (s = 0), Object.assign(e, {
                            width: t,
                            height: s,
                            size: e.isHorizontal() ? t : s
                        }))
                    },
                    updateSlides: function() {
                        const e = this;

                        function t(t) {
                            return e.isHorizontal() ? t : {
                                width: "height",
                                "margin-top": "margin-left",
                                "margin-bottom ": "margin-right",
                                "margin-left": "margin-top",
                                "margin-right": "margin-bottom",
                                "padding-left": "padding-top",
                                "padding-right": "padding-bottom",
                                marginRight: "marginBottom"
                            } [t]
                        }

                        function s(e, s) {
                            return parseFloat(e.getPropertyValue(t(s)) || 0)
                        }
                        const a = e.params,
                            {
                                $wrapperEl: i,
                                size: r,
                                rtlTranslate: n,
                                wrongRTL: l
                            } = e,
                            o = e.virtual && a.virtual.enabled,
                            d = o ? e.virtual.slides.length : e.slides.length,
                            c = i.children(`.${e.params.slideClass}`),
                            p = o ? e.virtual.slides.length : c.length;
                        let u = [];
                        const h = [],
                            m = [];
                        let f = a.slidesOffsetBefore;
                        "function" == typeof f && (f = a.slidesOffsetBefore.call(e));
                        let v = a.slidesOffsetAfter;
                        "function" == typeof v && (v = a.slidesOffsetAfter.call(e));
                        const w = e.snapGrid.length,
                            b = e.slidesGrid.length;
                        let x = a.spaceBetween,
                            y = -f,
                            E = 0,
                            T = 0;
                        if (void 0 === r) return;
                        "string" == typeof x && x.indexOf("%") >= 0 && (x = parseFloat(x.replace("%", "")) / 100 * r), e.virtualSize = -x, n ? c.css({
                            marginLeft: "",
                            marginBottom: "",
                            marginTop: ""
                        }) : c.css({
                            marginRight: "",
                            marginBottom: "",
                            marginTop: ""
                        }), a.centeredSlides && a.cssMode && (g(e.wrapperEl, "--swiper-centered-offset-before", ""), g(e.wrapperEl, "--swiper-centered-offset-after", ""));
                        const C = a.grid && a.grid.rows > 1 && e.grid;
                        let $;
                        C && e.grid.initSlides(p);
                        const S = "auto" === a.slidesPerView && a.breakpoints && Object.keys(a.breakpoints).filter(e => void 0 !== a.breakpoints[e].slidesPerView).length > 0;
                        for (let i = 0; i < p; i += 1) {
                            $ = 0;
                            const n = c.eq(i);
                            if (C && e.grid.updateSlide(i, n, p, t), "none" !== n.css("display")) {
                                if ("auto" === a.slidesPerView) {
                                    S && (c[i].style[t("width")] = "");
                                    const r = getComputedStyle(n[0]),
                                        l = n[0].style.transform,
                                        o = n[0].style.webkitTransform;
                                    if (l && (n[0].style.transform = "none"), o && (n[0].style.webkitTransform = "none"), a.roundLengths) $ = e.isHorizontal() ? n.outerWidth(!0) : n.outerHeight(!0);
                                    else {
                                        const e = s(r, "width"),
                                            t = s(r, "padding-left"),
                                            a = s(r, "padding-right"),
                                            i = s(r, "margin-left"),
                                            l = s(r, "margin-right"),
                                            o = r.getPropertyValue("box-sizing");
                                        if (o && "border-box" === o) $ = e + i + l;
                                        else {
                                            const {
                                                clientWidth: s,
                                                offsetWidth: r
                                            } = n[0];
                                            $ = e + t + a + i + l + (r - s)
                                        }
                                    }
                                    l && (n[0].style.transform = l), o && (n[0].style.webkitTransform = o), a.roundLengths && ($ = Math.floor($))
                                } else $ = (r - (a.slidesPerView - 1) * x) / a.slidesPerView, a.roundLengths && ($ = Math.floor($)), c[i] && (c[i].style[t("width")] = `${$}px`);
                                c[i] && (c[i].swiperSlideSize = $), m.push($), a.centeredSlides ? (y = y + $ / 2 + E / 2 + x, 0 === E && 0 !== i && (y = y - r / 2 - x), 0 === i && (y = y - r / 2 - x), Math.abs(y) < .001 && (y = 0), a.roundLengths && (y = Math.floor(y)), T % a.slidesPerGroup == 0 && u.push(y), h.push(y)) : (a.roundLengths && (y = Math.floor(y)), (T - Math.min(e.params.slidesPerGroupSkip, T)) % e.params.slidesPerGroup == 0 && u.push(y), h.push(y), y = y + $ + x), e.virtualSize += $ + x, E = $, T += 1
                            }
                        }
                        if (e.virtualSize = Math.max(e.virtualSize, r) + v, n && l && ("slide" === a.effect || "coverflow" === a.effect) && i.css({
                                width: `${e.virtualSize+a.spaceBetween}px`
                            }), a.setWrapperSize && i.css({
                                [t("width")]: `${e.virtualSize+a.spaceBetween}px`
                            }), C && e.grid.updateWrapperSize($, u, t), !a.centeredSlides) {
                            const t = [];
                            for (let s = 0; s < u.length; s += 1) {
                                let i = u[s];
                                a.roundLengths && (i = Math.floor(i)), u[s] <= e.virtualSize - r && t.push(i)
                            }
                            u = t, Math.floor(e.virtualSize - r) - Math.floor(u[u.length - 1]) > 1 && u.push(e.virtualSize - r)
                        }
                        if (0 === u.length && (u = [0]), 0 !== a.spaceBetween) {
                            const s = e.isHorizontal() && n ? "marginLeft" : t("marginRight");
                            c.filter((e, t) => !a.cssMode || t !== c.length - 1).css({
                                [s]: `${x}px`
                            })
                        }
                        if (a.centeredSlides && a.centeredSlidesBounds) {
                            let e = 0;
                            m.forEach(t => {
                                e += t + (a.spaceBetween ? a.spaceBetween : 0)
                            });
                            const t = (e -= a.spaceBetween) - r;
                            u = u.map(e => e < 0 ? -f : e > t ? t + v : e)
                        }
                        if (a.centerInsufficientSlides) {
                            let e = 0;
                            if (m.forEach(t => {
                                    e += t + (a.spaceBetween ? a.spaceBetween : 0)
                                }), (e -= a.spaceBetween) < r) {
                                const t = (r - e) / 2;
                                u.forEach((e, s) => {
                                    u[s] = e - t
                                }), h.forEach((e, s) => {
                                    h[s] = e + t
                                })
                            }
                        }
                        if (Object.assign(e, {
                                slides: c,
                                snapGrid: u,
                                slidesGrid: h,
                                slidesSizesGrid: m
                            }), a.centeredSlides && a.cssMode && !a.centeredSlidesBounds) {
                            g(e.wrapperEl, "--swiper-centered-offset-before", -u[0] + "px"), g(e.wrapperEl, "--swiper-centered-offset-after", e.size / 2 - m[m.length - 1] / 2 + "px");
                            const t = -e.snapGrid[0],
                                s = -e.slidesGrid[0];
                            e.snapGrid = e.snapGrid.map(e => e + t), e.slidesGrid = e.slidesGrid.map(e => e + s)
                        }
                        p !== d && e.emit("slidesLengthChange"), u.length !== w && (e.params.watchOverflow && e.checkOverflow(), e.emit("snapGridLengthChange")), h.length !== b && e.emit("slidesGridLengthChange"), a.watchSlidesProgress && e.updateSlidesOffset()
                    },
                    updateAutoHeight: function(e) {
                        const t = this,
                            s = [],
                            a = t.virtual && t.params.virtual.enabled;
                        let i, r = 0;
                        "number" == typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed);
                        const n = e => a ? t.slides.filter(t => parseInt(t.getAttribute("data-swiper-slide-index"), 10) === e)[0] : t.slides.eq(e)[0];
                        if ("auto" !== t.params.slidesPerView && t.params.slidesPerView > 1)
                            if (t.params.centeredSlides) t.visibleSlides.each(e => {
                                s.push(e)
                            });
                            else
                                for (i = 0; i < Math.ceil(t.params.slidesPerView); i += 1) {
                                    const e = t.activeIndex + i;
                                    if (e > t.slides.length && !a) break;
                                    s.push(n(e))
                                } else s.push(n(t.activeIndex));
                        for (i = 0; i < s.length; i += 1)
                            if (void 0 !== s[i]) {
                                const e = s[i].offsetHeight;
                                r = e > r ? e : r
                            } r && t.$wrapperEl.css("height", `${r}px`)
                    },
                    updateSlidesOffset: function() {
                        const e = this,
                            t = e.slides;
                        for (let s = 0; s < t.length; s += 1) t[s].swiperSlideOffset = e.isHorizontal() ? t[s].offsetLeft : t[s].offsetTop
                    },
                    updateSlidesProgress: function(e = this && this.translate || 0) {
                        const t = this,
                            s = t.params,
                            {
                                slides: a,
                                rtlTranslate: i
                            } = t;
                        if (0 === a.length) return;
                        void 0 === a[0].swiperSlideOffset && t.updateSlidesOffset();
                        let r = -e;
                        i && (r = e), a.removeClass(s.slideVisibleClass), t.visibleSlidesIndexes = [], t.visibleSlides = [];
                        for (let e = 0; e < a.length; e += 1) {
                            const n = a[e];
                            let l = n.swiperSlideOffset;
                            s.cssMode && s.centeredSlides && (l -= a[0].swiperSlideOffset);
                            const o = (r + (s.centeredSlides ? t.minTranslate() : 0) - l) / (n.swiperSlideSize + s.spaceBetween),
                                d = -(r - l),
                                c = d + t.slidesSizesGrid[e];
                            (d >= 0 && d < t.size - 1 || c > 1 && c <= t.size || d <= 0 && c >= t.size) && (t.visibleSlides.push(n), t.visibleSlidesIndexes.push(e), a.eq(e).addClass(s.slideVisibleClass)), n.progress = i ? -o : o
                        }
                        t.visibleSlides = d(t.visibleSlides)
                    },
                    updateProgress: function(e) {
                        const t = this;
                        if (void 0 === e) {
                            const s = t.rtlTranslate ? -1 : 1;
                            e = t && t.translate && t.translate * s || 0
                        }
                        const s = t.params,
                            a = t.maxTranslate() - t.minTranslate();
                        let {
                            progress: i,
                            isBeginning: r,
                            isEnd: n
                        } = t;
                        const l = r,
                            o = n;
                        0 === a ? (i = 0, r = !0, n = !0) : (r = (i = (e - t.minTranslate()) / a) <= 0, n = i >= 1), Object.assign(t, {
                            progress: i,
                            isBeginning: r,
                            isEnd: n
                        }), (s.watchSlidesProgress || s.centeredSlides && s.autoHeight) && t.updateSlidesProgress(e), r && !l && t.emit("reachBeginning toEdge"), n && !o && t.emit("reachEnd toEdge"), (l && !r || o && !n) && t.emit("fromEdge"), t.emit("progress", i)
                    },
                    updateSlidesClasses: function() {
                        const e = this,
                            {
                                slides: t,
                                params: s,
                                $wrapperEl: a,
                                activeIndex: i,
                                realIndex: r
                            } = e,
                            n = e.virtual && s.virtual.enabled;
                        let l;
                        t.removeClass(`${s.slideActiveClass} ${s.slideNextClass} ${s.slidePrevClass} ${s.slideDuplicateActiveClass} ${s.slideDuplicateNextClass} ${s.slideDuplicatePrevClass}`), (l = n ? e.$wrapperEl.find(`.${s.slideClass}[data-swiper-slide-index="${i}"]`) : t.eq(i)).addClass(s.slideActiveClass), s.loop && (l.hasClass(s.slideDuplicateClass) ? a.children(`.${s.slideClass}:not(.${s.slideDuplicateClass})[data-swiper-slide-index="${r}"]`).addClass(s.slideDuplicateActiveClass) : a.children(`.${s.slideClass}.${s.slideDuplicateClass}[data-swiper-slide-index="${r}"]`).addClass(s.slideDuplicateActiveClass));
                        let o = l.nextAll(`.${s.slideClass}`).eq(0).addClass(s.slideNextClass);
                        s.loop && 0 === o.length && (o = t.eq(0)).addClass(s.slideNextClass);
                        let d = l.prevAll(`.${s.slideClass}`).eq(0).addClass(s.slidePrevClass);
                        s.loop && 0 === d.length && (d = t.eq(-1)).addClass(s.slidePrevClass), s.loop && (o.hasClass(s.slideDuplicateClass) ? a.children(`.${s.slideClass}:not(.${s.slideDuplicateClass})[data-swiper-slide-index="${o.attr("data-swiper-slide-index")}"]`).addClass(s.slideDuplicateNextClass) : a.children(`.${s.slideClass}.${s.slideDuplicateClass}[data-swiper-slide-index="${o.attr("data-swiper-slide-index")}"]`).addClass(s.slideDuplicateNextClass), d.hasClass(s.slideDuplicateClass) ? a.children(`.${s.slideClass}:not(.${s.slideDuplicateClass})[data-swiper-slide-index="${d.attr("data-swiper-slide-index")}"]`).addClass(s.slideDuplicatePrevClass) : a.children(`.${s.slideClass}.${s.slideDuplicateClass}[data-swiper-slide-index="${d.attr("data-swiper-slide-index")}"]`).addClass(s.slideDuplicatePrevClass)), e.emitSlidesClasses()
                    },
                    updateActiveIndex: function(e) {
                        const t = this,
                            s = t.rtlTranslate ? t.translate : -t.translate,
                            {
                                slidesGrid: a,
                                snapGrid: i,
                                params: r,
                                activeIndex: n,
                                realIndex: l,
                                snapIndex: o
                            } = t;
                        let d, c = e;
                        if (void 0 === c) {
                            for (let e = 0; e < a.length; e += 1) void 0 !== a[e + 1] ? s >= a[e] && s < a[e + 1] - (a[e + 1] - a[e]) / 2 ? c = e : s >= a[e] && s < a[e + 1] && (c = e + 1) : s >= a[e] && (c = e);
                            r.normalizeSlideIndex && (c < 0 || void 0 === c) && (c = 0)
                        }
                        if (i.indexOf(s) >= 0) d = i.indexOf(s);
                        else {
                            const e = Math.min(r.slidesPerGroupSkip, c);
                            d = e + Math.floor((c - e) / r.slidesPerGroup)
                        }
                        if (d >= i.length && (d = i.length - 1), c === n) return void(d !== o && (t.snapIndex = d, t.emit("snapIndexChange")));
                        const p = parseInt(t.slides.eq(c).attr("data-swiper-slide-index") || c, 10);
                        Object.assign(t, {
                            snapIndex: d,
                            realIndex: p,
                            previousIndex: n,
                            activeIndex: c
                        }), t.emit("activeIndexChange"), t.emit("snapIndexChange"), l !== p && t.emit("realIndexChange"), (t.initialized || t.params.runCallbacksOnInit) && t.emit("slideChange")
                    },
                    updateClickedSlide: function(e) {
                        const t = this,
                            s = t.params,
                            a = d(e.target).closest(`.${s.slideClass}`)[0];
                        let i, r = !1;
                        if (a)
                            for (let e = 0; e < t.slides.length; e += 1)
                                if (t.slides[e] === a) {
                                    r = !0, i = e;
                                    break
                                } if (!a || !r) return t.clickedSlide = void 0, void(t.clickedIndex = void 0);
                        t.clickedSlide = a, t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(d(a).attr("data-swiper-slide-index"), 10) : t.clickedIndex = i, s.slideToClickedSlide && void 0 !== t.clickedIndex && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide()
                    }
                },
                translate: {
                    getTranslate: function(e = (this.isHorizontal() ? "x" : "y")) {
                        const {
                            params: t,
                            rtlTranslate: s,
                            translate: a,
                            $wrapperEl: i
                        } = this;
                        if (t.virtualTranslate) return s ? -a : a;
                        if (t.cssMode) return a;
                        let r = h(i[0], e);
                        return s && (r = -r), r || 0
                    },
                    setTranslate: function(e, t) {
                        const s = this,
                            {
                                rtlTranslate: a,
                                params: i,
                                $wrapperEl: r,
                                wrapperEl: n,
                                progress: l
                            } = s;
                        let o, d = 0,
                            c = 0;
                        s.isHorizontal() ? d = a ? -e : e : c = e, i.roundLengths && (d = Math.floor(d), c = Math.floor(c)), i.cssMode ? n[s.isHorizontal() ? "scrollLeft" : "scrollTop"] = s.isHorizontal() ? -d : -c : i.virtualTranslate || r.transform(`translate3d(${d}px, ${c}px, 0px)`), s.previousTranslate = s.translate, s.translate = s.isHorizontal() ? d : c;
                        const p = s.maxTranslate() - s.minTranslate();
                        (o = 0 === p ? 0 : (e - s.minTranslate()) / p) !== l && s.updateProgress(e), s.emit("setTranslate", s.translate, t)
                    },
                    minTranslate: function() {
                        return -this.snapGrid[0]
                    },
                    maxTranslate: function() {
                        return -this.snapGrid[this.snapGrid.length - 1]
                    },
                    translateTo: function(e = 0, t = this.params.speed, s = !0, a = !0, i) {
                        const r = this,
                            {
                                params: n,
                                wrapperEl: l
                            } = r;
                        if (r.animating && n.preventInteractionOnTransition) return !1;
                        const o = r.minTranslate(),
                            d = r.maxTranslate();
                        let c;
                        if (c = a && e > o ? o : a && e < d ? d : e, r.updateProgress(c), n.cssMode) {
                            const e = r.isHorizontal();
                            if (0 === t) l[e ? "scrollLeft" : "scrollTop"] = -c;
                            else {
                                if (!r.support.smoothScroll) return v({
                                    swiper: r,
                                    targetPosition: -c,
                                    side: e ? "left" : "top"
                                }), !0;
                                l.scrollTo({
                                    [e ? "left" : "top"]: -c,
                                    behavior: "smooth"
                                })
                            }
                            return !0
                        }
                        return 0 === t ? (r.setTransition(0), r.setTranslate(c), s && (r.emit("beforeTransitionStart", t, i), r.emit("transitionEnd"))) : (r.setTransition(t), r.setTranslate(c), s && (r.emit("beforeTransitionStart", t, i), r.emit("transitionStart")), r.animating || (r.animating = !0, r.onTranslateToWrapperTransitionEnd || (r.onTranslateToWrapperTransitionEnd = function(e) {
                            r && !r.destroyed && e.target === this && (r.$wrapperEl[0].removeEventListener("transitionend", r.onTranslateToWrapperTransitionEnd), r.$wrapperEl[0].removeEventListener("webkitTransitionEnd", r.onTranslateToWrapperTransitionEnd), r.onTranslateToWrapperTransitionEnd = null, delete r.onTranslateToWrapperTransitionEnd, s && r.emit("transitionEnd"))
                        }), r.$wrapperEl[0].addEventListener("transitionend", r.onTranslateToWrapperTransitionEnd), r.$wrapperEl[0].addEventListener("webkitTransitionEnd", r.onTranslateToWrapperTransitionEnd))), !0
                    }
                },
                transition: {
                    setTransition: function(e, t) {
                        const s = this;
                        s.params.cssMode || s.$wrapperEl.transition(e), s.emit("setTransition", e, t)
                    },
                    transitionStart: function(e = !0, t) {
                        const s = this,
                            {
                                params: a
                            } = s;
                        a.cssMode || (a.autoHeight && s.updateAutoHeight(), $({
                            swiper: s,
                            runCallbacks: e,
                            direction: t,
                            step: "Start"
                        }))
                    },
                    transitionEnd: function(e = !0, t) {
                        const s = this,
                            {
                                params: a
                            } = s;
                        s.animating = !1, a.cssMode || (s.setTransition(0), $({
                            swiper: s,
                            runCallbacks: e,
                            direction: t,
                            step: "End"
                        }))
                    }
                },
                slide: {
                    slideTo: function(e = 0, t = this.params.speed, s = !0, a, i) {
                        if ("number" != typeof e && "string" != typeof e) throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof e}] given.`);
                        if ("string" == typeof e) {
                            const t = parseInt(e, 10);
                            if (!isFinite(t)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${e}] given.`);
                            e = t
                        }
                        const r = this;
                        let n = e;
                        n < 0 && (n = 0);
                        const {
                            params: l,
                            snapGrid: o,
                            slidesGrid: d,
                            previousIndex: c,
                            activeIndex: p,
                            rtlTranslate: u,
                            wrapperEl: h,
                            enabled: m
                        } = r;
                        if (r.animating && l.preventInteractionOnTransition || !m && !a && !i) return !1;
                        const f = Math.min(r.params.slidesPerGroupSkip, n);
                        let g = f + Math.floor((n - f) / r.params.slidesPerGroup);
                        g >= o.length && (g = o.length - 1), (p || l.initialSlide || 0) === (c || 0) && s && r.emit("beforeSlideChangeStart");
                        const w = -o[g];
                        if (r.updateProgress(w), l.normalizeSlideIndex)
                            for (let e = 0; e < d.length; e += 1) {
                                const t = -Math.floor(100 * w),
                                    s = Math.floor(100 * d[e]),
                                    a = Math.floor(100 * d[e + 1]);
                                void 0 !== d[e + 1] ? t >= s && t < a - (a - s) / 2 ? n = e : t >= s && t < a && (n = e + 1) : t >= s && (n = e)
                            }
                        if (r.initialized && n !== p) {
                            if (!r.allowSlideNext && w < r.translate && w < r.minTranslate()) return !1;
                            if (!r.allowSlidePrev && w > r.translate && w > r.maxTranslate() && (p || 0) !== n) return !1
                        }
                        let b;
                        if (b = n > p ? "next" : n < p ? "prev" : "reset", u && -w === r.translate || !u && w === r.translate) return r.updateActiveIndex(n), l.autoHeight && r.updateAutoHeight(), r.updateSlidesClasses(), "slide" !== l.effect && r.setTranslate(w), "reset" !== b && (r.transitionStart(s, b), r.transitionEnd(s, b)), !1;
                        if (l.cssMode) {
                            const e = r.isHorizontal(),
                                s = u ? w : -w;
                            if (0 === t) {
                                const t = r.virtual && r.params.virtual.enabled;
                                t && (r.wrapperEl.style.scrollSnapType = "none"), h[e ? "scrollLeft" : "scrollTop"] = s, t && requestAnimationFrame(() => {
                                    r.wrapperEl.style.scrollSnapType = ""
                                })
                            } else {
                                if (!r.support.smoothScroll) return v({
                                    swiper: r,
                                    targetPosition: s,
                                    side: e ? "left" : "top"
                                }), !0;
                                h.scrollTo({
                                    [e ? "left" : "top"]: s,
                                    behavior: "smooth"
                                })
                            }
                            return !0
                        }
                        return 0 === t ? (r.setTransition(0), r.setTranslate(w), r.updateActiveIndex(n), r.updateSlidesClasses(), r.emit("beforeTransitionStart", t, a), r.transitionStart(s, b), r.transitionEnd(s, b)) : (r.setTransition(t), r.setTranslate(w), r.updateActiveIndex(n), r.updateSlidesClasses(), r.emit("beforeTransitionStart", t, a), r.transitionStart(s, b), r.animating || (r.animating = !0, r.onSlideToWrapperTransitionEnd || (r.onSlideToWrapperTransitionEnd = function(e) {
                            r && !r.destroyed && e.target === this && (r.$wrapperEl[0].removeEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.$wrapperEl[0].removeEventListener("webkitTransitionEnd", r.onSlideToWrapperTransitionEnd), r.onSlideToWrapperTransitionEnd = null, delete r.onSlideToWrapperTransitionEnd, r.transitionEnd(s, b))
                        }), r.$wrapperEl[0].addEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.$wrapperEl[0].addEventListener("webkitTransitionEnd", r.onSlideToWrapperTransitionEnd))), !0
                    },
                    slideToLoop: function(e = 0, t = this.params.speed, s = !0, a) {
                        const i = this;
                        let r = e;
                        return i.params.loop && (r += i.loopedSlides), i.slideTo(r, t, s, a)
                    },
                    slideNext: function(e = this.params.speed, t = !0, s) {
                        const a = this,
                            {
                                animating: i,
                                enabled: r,
                                params: n
                            } = a;
                        if (!r) return a;
                        let l = n.slidesPerGroup;
                        "auto" === n.slidesPerView && 1 === n.slidesPerGroup && n.slidesPerGroupAuto && (l = Math.max(a.slidesPerViewDynamic("current", !0), 1));
                        const o = a.activeIndex < n.slidesPerGroupSkip ? 1 : l;
                        if (n.loop) {
                            if (i && n.loopPreventsSlide) return !1;
                            a.loopFix(), a._clientLeft = a.$wrapperEl[0].clientLeft
                        }
                        return a.slideTo(a.activeIndex + o, e, t, s)
                    },
                    slidePrev: function(e = this.params.speed, t = !0, s) {
                        const a = this,
                            {
                                params: i,
                                animating: r,
                                snapGrid: n,
                                slidesGrid: l,
                                rtlTranslate: o,
                                enabled: d
                            } = a;
                        if (!d) return a;
                        if (i.loop) {
                            if (r && i.loopPreventsSlide) return !1;
                            a.loopFix(), a._clientLeft = a.$wrapperEl[0].clientLeft
                        }

                        function c(e) {
                            return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e)
                        }
                        const p = c(o ? a.translate : -a.translate);
                        let h = n[n.map(e => c(e)).indexOf(p) - 1];
                        if (void 0 === h && i.cssMode) {
                            let e;
                            n.forEach((t, s) => {
                                p >= t && (e = s)
                            }), void 0 !== e && (h = n[e > 0 ? e - 1 : e])
                        }
                        let m = 0;
                        return void 0 !== h && ((m = l.indexOf(h)) < 0 && (m = a.activeIndex - 1), "auto" === i.slidesPerView && 1 === i.slidesPerGroup && i.slidesPerGroupAuto && (m = m - a.slidesPerViewDynamic("previous", !0) + 1, m = Math.max(m, 0))), a.slideTo(m, e, t, s)
                    },
                    slideReset: function(e = this.params.speed, t = !0, s) {
                        return this.slideTo(this.activeIndex, e, t, s)
                    },
                    slideToClosest: function(e = this.params.speed, t = !0, s, a = .5) {
                        const i = this;
                        let r = i.activeIndex;
                        const n = Math.min(i.params.slidesPerGroupSkip, r),
                            l = n + Math.floor((r - n) / i.params.slidesPerGroup),
                            o = i.rtlTranslate ? i.translate : -i.translate;
                        if (o >= i.snapGrid[l]) {
                            const e = i.snapGrid[l];
                            o - e > (i.snapGrid[l + 1] - e) * a && (r += i.params.slidesPerGroup)
                        } else {
                            const e = i.snapGrid[l - 1];
                            o - e <= (i.snapGrid[l] - e) * a && (r -= i.params.slidesPerGroup)
                        }
                        return r = Math.max(r, 0), r = Math.min(r, i.slidesGrid.length - 1), i.slideTo(r, e, t, s)
                    },
                    slideToClickedSlide: function() {
                        const e = this,
                            {
                                params: t,
                                $wrapperEl: s
                            } = e,
                            a = "auto" === t.slidesPerView ? e.slidesPerViewDynamic() : t.slidesPerView;
                        let i, r = e.clickedIndex;
                        if (t.loop) {
                            if (e.animating) return;
                            i = parseInt(d(e.clickedSlide).attr("data-swiper-slide-index"), 10), t.centeredSlides ? r < e.loopedSlides - a / 2 || r > e.slides.length - e.loopedSlides + a / 2 ? (e.loopFix(), r = s.children(`.${t.slideClass}[data-swiper-slide-index="${i}"]:not(.${t.slideDuplicateClass})`).eq(0).index(), p(() => {
                                e.slideTo(r)
                            })) : e.slideTo(r) : r > e.slides.length - a ? (e.loopFix(), r = s.children(`.${t.slideClass}[data-swiper-slide-index="${i}"]:not(.${t.slideDuplicateClass})`).eq(0).index(), p(() => {
                                e.slideTo(r)
                            })) : e.slideTo(r)
                        } else e.slideTo(r)
                    }
                },
                loop: {
                    loopCreate: function() {
                        const e = this,
                            t = a(),
                            {
                                params: s,
                                $wrapperEl: i
                            } = e;
                        i.children(`.${s.slideClass}.${s.slideDuplicateClass}`).remove();
                        let r = i.children(`.${s.slideClass}`);
                        if (s.loopFillGroupWithBlank) {
                            const e = s.slidesPerGroup - r.length % s.slidesPerGroup;
                            if (e !== s.slidesPerGroup) {
                                for (let a = 0; a < e; a += 1) {
                                    const e = d(t.createElement("div")).addClass(`${s.slideClass} ${s.slideBlankClass}`);
                                    i.append(e)
                                }
                                r = i.children(`.${s.slideClass}`)
                            }
                        }
                        "auto" !== s.slidesPerView || s.loopedSlides || (s.loopedSlides = r.length), e.loopedSlides = Math.ceil(parseFloat(s.loopedSlides || s.slidesPerView, 10)), e.loopedSlides += s.loopAdditionalSlides, e.loopedSlides > r.length && (e.loopedSlides = r.length);
                        const n = [],
                            l = [];
                        r.each((t, s) => {
                            const a = d(t);
                            s < e.loopedSlides && l.push(t), s < r.length && s >= r.length - e.loopedSlides && n.push(t), a.attr("data-swiper-slide-index", s)
                        });
                        for (let e = 0; e < l.length; e += 1) i.append(d(l[e].cloneNode(!0)).addClass(s.slideDuplicateClass));
                        for (let e = n.length - 1; e >= 0; e -= 1) i.prepend(d(n[e].cloneNode(!0)).addClass(s.slideDuplicateClass))
                    },
                    loopFix: function() {
                        const e = this;
                        e.emit("beforeLoopFix");
                        const {
                            activeIndex: t,
                            slides: s,
                            loopedSlides: a,
                            allowSlidePrev: i,
                            allowSlideNext: r,
                            snapGrid: n,
                            rtlTranslate: l
                        } = e;
                        let o;
                        e.allowSlidePrev = !0, e.allowSlideNext = !0;
                        const d = -n[t] - e.getTranslate();
                        t < a ? (o = s.length - 3 * a + t, o += a, e.slideTo(o, 0, !1, !0) && 0 !== d && e.setTranslate((l ? -e.translate : e.translate) - d)) : t >= s.length - a && (o = -s.length + t + a, o += a, e.slideTo(o, 0, !1, !0) && 0 !== d && e.setTranslate((l ? -e.translate : e.translate) - d)), e.allowSlidePrev = i, e.allowSlideNext = r, e.emit("loopFix")
                    },
                    loopDestroy: function() {
                        const {
                            $wrapperEl: e,
                            params: t,
                            slides: s
                        } = this;
                        e.children(`.${t.slideClass}.${t.slideDuplicateClass},.${t.slideClass}.${t.slideBlankClass}`).remove(), s.removeAttr("data-swiper-slide-index")
                    }
                },
                grabCursor: {
                    setGrabCursor: function(e) {
                        const t = this;
                        if (t.support.touch || !t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode) return;
                        const s = "container" === t.params.touchEventsTarget ? t.el : t.wrapperEl;
                        s.style.cursor = "move", s.style.cursor = e ? "-webkit-grabbing" : "-webkit-grab", s.style.cursor = e ? "-moz-grabbin" : "-moz-grab", s.style.cursor = e ? "grabbing" : "grab"
                    },
                    unsetGrabCursor: function() {
                        const e = this;
                        e.support.touch || e.params.watchOverflow && e.isLocked || e.params.cssMode || (e["container" === e.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "")
                    }
                },
                events: {
                    attachEvents: function() {
                        const e = this,
                            t = a(),
                            {
                                params: s,
                                support: i
                            } = e;
                        e.onTouchStart = function(e) {
                            const t = this,
                                s = a(),
                                i = r(),
                                n = t.touchEventsData,
                                {
                                    params: l,
                                    touches: o,
                                    enabled: c
                                } = t;
                            if (!c) return;
                            if (t.animating && l.preventInteractionOnTransition) return;
                            !t.animating && l.cssMode && l.loop && t.loopFix();
                            let p = e;
                            p.originalEvent && (p = p.originalEvent);
                            let h = d(p.target);
                            if ("wrapper" === l.touchEventsTarget && !h.closest(t.wrapperEl).length) return;
                            if (n.isTouchEvent = "touchstart" === p.type, !n.isTouchEvent && "which" in p && 3 === p.which) return;
                            if (!n.isTouchEvent && "button" in p && p.button > 0) return;
                            if (n.isTouched && n.isMoved) return;
                            l.noSwipingClass && "" !== l.noSwipingClass && p.target && p.target.shadowRoot && e.path && e.path[0] && (h = d(e.path[0]));
                            const m = l.noSwipingSelector ? l.noSwipingSelector : `.${l.noSwipingClass}`,
                                f = !(!p.target || !p.target.shadowRoot);
                            if (l.noSwiping && (f ? function(e, t = this) {
                                    return function t(s) {
                                        return s && s !== a() && s !== r() ? (s.assignedSlot && (s = s.assignedSlot), s.closest(e) || t(s.getRootNode().host)) : null
                                    }(t)
                                }(m, p.target) : h.closest(m)[0])) return void(t.allowClick = !0);
                            if (l.swipeHandler && !h.closest(l.swipeHandler)[0]) return;
                            o.currentX = "touchstart" === p.type ? p.targetTouches[0].pageX : p.pageX, o.currentY = "touchstart" === p.type ? p.targetTouches[0].pageY : p.pageY;
                            const g = o.currentX,
                                v = o.currentY,
                                w = l.edgeSwipeDetection || l.iOSEdgeSwipeDetection,
                                b = l.edgeSwipeThreshold || l.iOSEdgeSwipeThreshold;
                            if (w && (g <= b || g >= i.innerWidth - b)) {
                                if ("prevent" !== w) return;
                                e.preventDefault()
                            }
                            if (Object.assign(n, {
                                    isTouched: !0,
                                    isMoved: !1,
                                    allowTouchCallbacks: !0,
                                    isScrolling: void 0,
                                    startMoving: void 0
                                }), o.startX = g, o.startY = v, n.touchStartTime = u(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, l.threshold > 0 && (n.allowThresholdMove = !1), "touchstart" !== p.type) {
                                let e = !0;
                                h.is(n.focusableElements) && (e = !1), s.activeElement && d(s.activeElement).is(n.focusableElements) && s.activeElement !== h[0] && s.activeElement.blur();
                                const a = e && t.allowTouchMove && l.touchStartPreventDefault;
                                !l.touchStartForcePreventDefault && !a || h[0].isContentEditable || p.preventDefault()
                            }
                            t.emit("touchStart", p)
                        }.bind(e), e.onTouchMove = function(e) {
                            const t = a(),
                                s = this,
                                i = s.touchEventsData,
                                {
                                    params: r,
                                    touches: n,
                                    rtlTranslate: l,
                                    enabled: o
                                } = s;
                            if (!o) return;
                            let c = e;
                            if (c.originalEvent && (c = c.originalEvent), !i.isTouched) return void(i.startMoving && i.isScrolling && s.emit("touchMoveOpposite", c));
                            if (i.isTouchEvent && "touchmove" !== c.type) return;
                            const p = "touchmove" === c.type && c.targetTouches && (c.targetTouches[0] || c.changedTouches[0]),
                                h = "touchmove" === c.type ? p.pageX : c.pageX,
                                m = "touchmove" === c.type ? p.pageY : c.pageY;
                            if (c.preventedByNestedSwiper) return n.startX = h, void(n.startY = m);
                            if (!s.allowTouchMove) return s.allowClick = !1, void(i.isTouched && (Object.assign(n, {
                                startX: h,
                                startY: m,
                                currentX: h,
                                currentY: m
                            }), i.touchStartTime = u()));
                            if (i.isTouchEvent && r.touchReleaseOnEdges && !r.loop)
                                if (s.isVertical()) {
                                    if (m < n.startY && s.translate <= s.maxTranslate() || m > n.startY && s.translate >= s.minTranslate()) return i.isTouched = !1, void(i.isMoved = !1)
                                } else if (h < n.startX && s.translate <= s.maxTranslate() || h > n.startX && s.translate >= s.minTranslate()) return;
                            if (i.isTouchEvent && t.activeElement && c.target === t.activeElement && d(c.target).is(i.focusableElements)) return i.isMoved = !0, void(s.allowClick = !1);
                            if (i.allowTouchCallbacks && s.emit("touchMove", c), c.targetTouches && c.targetTouches.length > 1) return;
                            n.currentX = h, n.currentY = m;
                            const f = n.currentX - n.startX,
                                g = n.currentY - n.startY;
                            if (s.params.threshold && Math.sqrt(f ** 2 + g ** 2) < s.params.threshold) return;
                            if (void 0 === i.isScrolling) {
                                let e;
                                s.isHorizontal() && n.currentY === n.startY || s.isVertical() && n.currentX === n.startX ? i.isScrolling = !1 : f * f + g * g >= 25 && (e = 180 * Math.atan2(Math.abs(g), Math.abs(f)) / Math.PI, i.isScrolling = s.isHorizontal() ? e > r.touchAngle : 90 - e > r.touchAngle)
                            }
                            if (i.isScrolling && s.emit("touchMoveOpposite", c), void 0 === i.startMoving && (n.currentX === n.startX && n.currentY === n.startY || (i.startMoving = !0)), i.isScrolling) return void(i.isTouched = !1);
                            if (!i.startMoving) return;
                            s.allowClick = !1, !r.cssMode && c.cancelable && c.preventDefault(), r.touchMoveStopPropagation && !r.nested && c.stopPropagation(), i.isMoved || (r.loop && !r.cssMode && s.loopFix(), i.startTranslate = s.getTranslate(), s.setTransition(0), s.animating && s.$wrapperEl.trigger("webkitTransitionEnd transitionend"), i.allowMomentumBounce = !1, !r.grabCursor || !0 !== s.allowSlideNext && !0 !== s.allowSlidePrev || s.setGrabCursor(!0), s.emit("sliderFirstMove", c)), s.emit("sliderMove", c), i.isMoved = !0;
                            let v = s.isHorizontal() ? f : g;
                            n.diff = v, v *= r.touchRatio, l && (v = -v), s.swipeDirection = v > 0 ? "prev" : "next", i.currentTranslate = v + i.startTranslate;
                            let w = !0,
                                b = r.resistanceRatio;
                            if (r.touchReleaseOnEdges && (b = 0), v > 0 && i.currentTranslate > s.minTranslate() ? (w = !1, r.resistance && (i.currentTranslate = s.minTranslate() - 1 + (-s.minTranslate() + i.startTranslate + v) ** b)) : v < 0 && i.currentTranslate < s.maxTranslate() && (w = !1, r.resistance && (i.currentTranslate = s.maxTranslate() + 1 - (s.maxTranslate() - i.startTranslate - v) ** b)), w && (c.preventedByNestedSwiper = !0), !s.allowSlideNext && "next" === s.swipeDirection && i.currentTranslate < i.startTranslate && (i.currentTranslate = i.startTranslate), !s.allowSlidePrev && "prev" === s.swipeDirection && i.currentTranslate > i.startTranslate && (i.currentTranslate = i.startTranslate), s.allowSlidePrev || s.allowSlideNext || (i.currentTranslate = i.startTranslate), r.threshold > 0) {
                                if (!(Math.abs(v) > r.threshold || i.allowThresholdMove)) return void(i.currentTranslate = i.startTranslate);
                                if (!i.allowThresholdMove) return i.allowThresholdMove = !0, n.startX = n.currentX, n.startY = n.currentY, i.currentTranslate = i.startTranslate, void(n.diff = s.isHorizontal() ? n.currentX - n.startX : n.currentY - n.startY)
                            }
                            r.followFinger && !r.cssMode && ((r.freeMode && r.freeMode.enabled && s.freeMode || r.watchSlidesProgress) && (s.updateActiveIndex(), s.updateSlidesClasses()), s.params.freeMode && r.freeMode.enabled && s.freeMode && s.freeMode.onTouchMove(), s.updateProgress(i.currentTranslate), s.setTranslate(i.currentTranslate))
                        }.bind(e), e.onTouchEnd = function(e) {
                            const t = this,
                                s = t.touchEventsData,
                                {
                                    params: a,
                                    touches: i,
                                    rtlTranslate: r,
                                    slidesGrid: n,
                                    enabled: l
                                } = t;
                            if (!l) return;
                            let o = e;
                            if (o.originalEvent && (o = o.originalEvent), s.allowTouchCallbacks && t.emit("touchEnd", o), s.allowTouchCallbacks = !1, !s.isTouched) return s.isMoved && a.grabCursor && t.setGrabCursor(!1), s.isMoved = !1, void(s.startMoving = !1);
                            a.grabCursor && s.isMoved && s.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1);
                            const d = u(),
                                c = d - s.touchStartTime;
                            if (t.allowClick && (t.updateClickedSlide(o), t.emit("tap click", o), c < 300 && d - s.lastClickTime < 300 && t.emit("doubleTap doubleClick", o)), s.lastClickTime = u(), p(() => {
                                    t.destroyed || (t.allowClick = !0)
                                }), !s.isTouched || !s.isMoved || !t.swipeDirection || 0 === i.diff || s.currentTranslate === s.startTranslate) return s.isTouched = !1, s.isMoved = !1, void(s.startMoving = !1);
                            let h;
                            if (s.isTouched = !1, s.isMoved = !1, s.startMoving = !1, h = a.followFinger ? r ? t.translate : -t.translate : -s.currentTranslate, a.cssMode) return;
                            if (t.params.freeMode && a.freeMode.enabled) return void t.freeMode.onTouchEnd({
                                currentPos: h
                            });
                            let m = 0,
                                f = t.slidesSizesGrid[0];
                            for (let e = 0; e < n.length; e += e < a.slidesPerGroupSkip ? 1 : a.slidesPerGroup) {
                                const t = e < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup;
                                void 0 !== n[e + t] ? h >= n[e] && h < n[e + t] && (m = e, f = n[e + t] - n[e]) : h >= n[e] && (m = e, f = n[n.length - 1] - n[n.length - 2])
                            }
                            const g = (h - n[m]) / f,
                                v = m < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup;
                            if (c > a.longSwipesMs) {
                                if (!a.longSwipes) return void t.slideTo(t.activeIndex);
                                "next" === t.swipeDirection && (g >= a.longSwipesRatio ? t.slideTo(m + v) : t.slideTo(m)), "prev" === t.swipeDirection && (g > 1 - a.longSwipesRatio ? t.slideTo(m + v) : t.slideTo(m))
                            } else {
                                if (!a.shortSwipes) return void t.slideTo(t.activeIndex);
                                !t.navigation || o.target !== t.navigation.nextEl && o.target !== t.navigation.prevEl ? ("next" === t.swipeDirection && t.slideTo(m + v), "prev" === t.swipeDirection && t.slideTo(m)) : o.target === t.navigation.nextEl ? t.slideTo(m + v) : t.slideTo(m)
                            }
                        }.bind(e), s.cssMode && (e.onScroll = function() {
                            const e = this,
                                {
                                    wrapperEl: t,
                                    rtlTranslate: s,
                                    enabled: a
                                } = e;
                            if (!a) return;
                            let i;
                            e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop, -0 === e.translate && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses();
                            const r = e.maxTranslate() - e.minTranslate();
                            (i = 0 === r ? 0 : (e.translate - e.minTranslate()) / r) !== e.progress && e.updateProgress(s ? -e.translate : e.translate), e.emit("setTranslate", e.translate, !1)
                        }.bind(e)), e.onClick = function(e) {
                            const t = this;
                            t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation())))
                        }.bind(e), i.touch && !I && (t.addEventListener("touchstart", L), I = !0), A(e, "on")
                    },
                    detachEvents: function() {
                        A(this, "off")
                    }
                },
                breakpoints: {
                    setBreakpoint: function() {
                        const e = this,
                            {
                                activeIndex: t,
                                initialized: s,
                                loopedSlides: a = 0,
                                params: i,
                                $el: r
                            } = e,
                            n = i.breakpoints;
                        if (!n || n && 0 === Object.keys(n).length) return;
                        const l = e.getBreakpoint(n, e.params.breakpointsBase, e.el);
                        if (!l || e.currentBreakpoint === l) return;
                        const o = (l in n ? n[l] : void 0) || e.originalParams,
                            d = D(e, i),
                            c = D(e, o),
                            p = i.enabled;
                        d && !c ? (r.removeClass(`${i.containerModifierClass}grid ${i.containerModifierClass}grid-column`), e.emitContainerClasses()) : !d && c && (r.addClass(`${i.containerModifierClass}grid`), (o.grid.fill && "column" === o.grid.fill || !o.grid.fill && "column" === i.grid.fill) && r.addClass(`${i.containerModifierClass}grid-column`), e.emitContainerClasses());
                        const u = o.direction && o.direction !== i.direction,
                            h = i.loop && (o.slidesPerView !== i.slidesPerView || u);
                        u && s && e.changeDirection(), f(e.params, o);
                        const m = e.params.enabled;
                        Object.assign(e, {
                            allowTouchMove: e.params.allowTouchMove,
                            allowSlideNext: e.params.allowSlideNext,
                            allowSlidePrev: e.params.allowSlidePrev
                        }), p && !m ? e.disable() : !p && m && e.enable(), e.currentBreakpoint = l, e.emit("_beforeBreakpoint", o), h && s && (e.loopDestroy(), e.loopCreate(), e.updateSlides(), e.slideTo(t - a + e.loopedSlides, 0, !1)), e.emit("breakpoint", o)
                    },
                    getBreakpoint: function(e, t = "window", s) {
                        if (!e || "container" === t && !s) return;
                        let a = !1;
                        const i = r(),
                            n = "window" === t ? i.innerHeight : s.clientHeight,
                            l = Object.keys(e).map(e => {
                                if ("string" == typeof e && 0 === e.indexOf("@")) {
                                    const t = parseFloat(e.substr(1));
                                    return {
                                        value: n * t,
                                        point: e
                                    }
                                }
                                return {
                                    value: e,
                                    point: e
                                }
                            });
                        l.sort((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10));
                        for (let e = 0; e < l.length; e += 1) {
                            const {
                                point: r,
                                value: n
                            } = l[e];
                            "window" === t ? i.matchMedia(`(min-width: ${n}px)`).matches && (a = r) : n <= s.clientWidth && (a = r)
                        }
                        return a || "max"
                    }
                },
                checkOverflow: {
                    checkOverflow: function() {
                        const e = this,
                            {
                                isLocked: t,
                                params: s
                            } = e,
                            {
                                slidesOffsetBefore: a
                            } = s;
                        if (a) {
                            const t = e.slides.length - 1,
                                s = e.slidesGrid[t] + e.slidesSizesGrid[t] + 2 * a;
                            e.isLocked = e.size > s
                        } else e.isLocked = 1 === e.snapGrid.length;
                        !0 === s.allowSlideNext && (e.allowSlideNext = !e.isLocked), !0 === s.allowSlidePrev && (e.allowSlidePrev = !e.isLocked), t && t !== e.isLocked && (e.isEnd = !1), t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock")
                    }
                },
                classes: {
                    addClasses: function() {
                        const e = this,
                            {
                                classNames: t,
                                params: s,
                                rtl: a,
                                $el: i,
                                device: r,
                                support: n
                            } = e,
                            l = function(e, t) {
                                const s = [];
                                return e.forEach(e => {
                                    "object" == typeof e ? Object.keys(e).forEach(a => {
                                        e[a] && s.push(t + a)
                                    }) : "string" == typeof e && s.push(t + e)
                                }), s
                            }(["initialized", s.direction, {
                                "pointer-events": !n.touch
                            }, {
                                "free-mode": e.params.freeMode && s.freeMode.enabled
                            }, {
                                autoheight: s.autoHeight
                            }, {
                                rtl: a
                            }, {
                                grid: s.grid && s.grid.rows > 1
                            }, {
                                "grid-column": s.grid && s.grid.rows > 1 && "column" === s.grid.fill
                            }, {
                                android: r.android
                            }, {
                                ios: r.ios
                            }, {
                                "css-mode": s.cssMode
                            }, {
                                centered: s.cssMode && s.centeredSlides
                            }], s.containerModifierClass);
                        t.push(...l), i.addClass([...t].join(" ")), e.emitContainerClasses()
                    },
                    removeClasses: function() {
                        const {
                            $el: e,
                            classNames: t
                        } = this;
                        e.removeClass(t.join(" ")), this.emitContainerClasses()
                    }
                },
                images: {
                    loadImage: function(e, t, s, a, i, n) {
                        const l = r();
                        let o;

                        function c() {
                            n && n()
                        }
                        d(e).parent("picture")[0] || e.complete && i ? c() : t ? ((o = new l.Image).onload = c, o.onerror = c, a && (o.sizes = a), s && (o.srcset = s), t && (o.src = t)) : c()
                    },
                    preloadImages: function() {
                        const e = this;

                        function t() {
                            null != e && e && !e.destroyed && (void 0 !== e.imagesLoaded && (e.imagesLoaded += 1), e.imagesLoaded === e.imagesToLoad.length && (e.params.updateOnImagesReady && e.update(), e.emit("imagesReady")))
                        }
                        e.imagesToLoad = e.$el.find("img");
                        for (let s = 0; s < e.imagesToLoad.length; s += 1) {
                            const a = e.imagesToLoad[s];
                            e.loadImage(a, a.currentSrc || a.getAttribute("src"), a.srcset || a.getAttribute("srcset"), a.sizes || a.getAttribute("sizes"), !0, t)
                        }
                    }
                }
            },
            X = {};
        class H {
            constructor(...e) {
                let t, s;
                if (1 === e.length && e[0].constructor && "Object" === Object.prototype.toString.call(e[0]).slice(8, -1) ? s = e[0] : [t, s] = e, s || (s = {}), s = f({}, s), t && !s.el && (s.el = t), s.el && d(s.el).length > 1) {
                    const e = [];
                    return d(s.el).each(t => {
                        const a = f({}, s, {
                            el: t
                        });
                        e.push(new H(a))
                    }), e
                }
                const a = this;
                a.__swiper__ = !0, a.support = y(), a.device = E({
                    userAgent: s.userAgent
                }), a.browser = T(), a.eventsListeners = {}, a.eventsAnyListeners = [], a.modules = [...a.__modules__], s.modules && Array.isArray(s.modules) && a.modules.push(...s.modules);
                const i = {};
                a.modules.forEach(e => {
                    e({
                        swiper: a,
                        extendParams: function(e, t) {
                            return function(s = {}) {
                                const a = Object.keys(s)[0],
                                    i = s[a];
                                "object" == typeof i && null !== i ? (["navigation", "pagination", "scrollbar"].indexOf(a) >= 0 && !0 === e[a] && (e[a] = {
                                    auto: !0
                                }), a in e && "enabled" in i ? (!0 === e[a] && (e[a] = {
                                    enabled: !0
                                }), "object" != typeof e[a] || "enabled" in e[a] || (e[a].enabled = !0), e[a] || (e[a] = {
                                    enabled: !1
                                }), f(t, s)) : f(t, s)) : f(t, s)
                            }
                        }(s, i),
                        on: a.on.bind(a),
                        once: a.once.bind(a),
                        off: a.off.bind(a),
                        emit: a.emit.bind(a)
                    })
                });
                const r = f({}, G, i);
                return a.params = f({}, r, X, s), a.originalParams = f({}, a.params), a.passedParams = f({}, s), a.params && a.params.on && Object.keys(a.params.on).forEach(e => {
                    a.on(e, a.params.on[e])
                }), a.params && a.params.onAny && a.onAny(a.params.onAny), a.$ = d, Object.assign(a, {
                    enabled: a.params.enabled,
                    el: t,
                    classNames: [],
                    slides: d(),
                    slidesGrid: [],
                    snapGrid: [],
                    slidesSizesGrid: [],
                    isHorizontal: () => "horizontal" === a.params.direction,
                    isVertical: () => "vertical" === a.params.direction,
                    activeIndex: 0,
                    realIndex: 0,
                    isBeginning: !0,
                    isEnd: !1,
                    translate: 0,
                    previousTranslate: 0,
                    progress: 0,
                    velocity: 0,
                    animating: !1,
                    allowSlideNext: a.params.allowSlideNext,
                    allowSlidePrev: a.params.allowSlidePrev,
                    touchEvents: function() {
                        const e = ["touchstart", "touchmove", "touchend", "touchcancel"],
                            t = ["pointerdown", "pointermove", "pointerup"];
                        return a.touchEventsTouch = {
                            start: e[0],
                            move: e[1],
                            end: e[2],
                            cancel: e[3]
                        }, a.touchEventsDesktop = {
                            start: t[0],
                            move: t[1],
                            end: t[2]
                        }, a.support.touch || !a.params.simulateTouch ? a.touchEventsTouch : a.touchEventsDesktop
                    }(),
                    touchEventsData: {
                        isTouched: void 0,
                        isMoved: void 0,
                        allowTouchCallbacks: void 0,
                        touchStartTime: void 0,
                        isScrolling: void 0,
                        currentTranslate: void 0,
                        startTranslate: void 0,
                        allowThresholdMove: void 0,
                        focusableElements: a.params.focusableElements,
                        lastClickTime: u(),
                        clickTimeout: void 0,
                        velocities: [],
                        allowMomentumBounce: void 0,
                        isTouchEvent: void 0,
                        startMoving: void 0
                    },
                    allowClick: !0,
                    allowTouchMove: a.params.allowTouchMove,
                    touches: {
                        startX: 0,
                        startY: 0,
                        currentX: 0,
                        currentY: 0,
                        diff: 0
                    },
                    imagesToLoad: [],
                    imagesLoaded: 0
                }), a.emit("_swiper"), a.params.init && a.init(), a
            }
            enable() {
                const e = this;
                e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable"))
            }
            disable() {
                const e = this;
                e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable"))
            }
            setProgress(e, t) {
                const s = this;
                e = Math.min(Math.max(e, 0), 1);
                const a = s.minTranslate(),
                    i = (s.maxTranslate() - a) * e + a;
                s.translateTo(i, void 0 === t ? 0 : t), s.updateActiveIndex(), s.updateSlidesClasses()
            }
            emitContainerClasses() {
                const e = this;
                if (!e.params._emitClasses || !e.el) return;
                const t = e.el.className.split(" ").filter(t => 0 === t.indexOf("swiper") || 0 === t.indexOf(e.params.containerModifierClass));
                e.emit("_containerClasses", t.join(" "))
            }
            getSlideClasses(e) {
                const t = this;
                return e.className.split(" ").filter(e => 0 === e.indexOf("swiper-slide") || 0 === e.indexOf(t.params.slideClass)).join(" ")
            }
            emitSlidesClasses() {
                const e = this;
                if (!e.params._emitClasses || !e.el) return;
                const t = [];
                e.slides.each(s => {
                    const a = e.getSlideClasses(s);
                    t.push({
                        slideEl: s,
                        classNames: a
                    }), e.emit("_slideClass", s, a)
                }), e.emit("_slideClasses", t)
            }
            slidesPerViewDynamic(e = "current", t = !1) {
                const {
                    params: s,
                    slides: a,
                    slidesGrid: i,
                    slidesSizesGrid: r,
                    size: n,
                    activeIndex: l
                } = this;
                let o = 1;
                if (s.centeredSlides) {
                    let e, t = a[l].swiperSlideSize;
                    for (let s = l + 1; s < a.length; s += 1) a[s] && !e && (o += 1, (t += a[s].swiperSlideSize) > n && (e = !0));
                    for (let s = l - 1; s >= 0; s -= 1) a[s] && !e && (o += 1, (t += a[s].swiperSlideSize) > n && (e = !0))
                } else if ("current" === e)
                    for (let e = l + 1; e < a.length; e += 1)(t ? i[e] + r[e] - i[l] < n : i[e] - i[l] < n) && (o += 1);
                else
                    for (let e = l - 1; e >= 0; e -= 1) i[l] - i[e] < n && (o += 1);
                return o
            }
            update() {
                const e = this;
                if (!e || e.destroyed) return;
                const {
                    snapGrid: t,
                    params: s
                } = e;

                function a() {
                    const t = e.rtlTranslate ? -1 * e.translate : e.translate,
                        s = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate());
                    e.setTranslate(s), e.updateActiveIndex(), e.updateSlidesClasses()
                }
                let i;
                s.breakpoints && e.setBreakpoint(), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.params.freeMode && e.params.freeMode.enabled ? (a(), e.params.autoHeight && e.updateAutoHeight()) : (i = ("auto" === e.params.slidesPerView || e.params.slidesPerView > 1) && e.isEnd && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0)) || a(), s.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update")
            }
            changeDirection(e, t = !0) {
                const s = this,
                    a = s.params.direction;
                return e || (e = "horizontal" === a ? "vertical" : "horizontal"), e === a || "horizontal" !== e && "vertical" !== e || (s.$el.removeClass(`${s.params.containerModifierClass}${a}`).addClass(`${s.params.containerModifierClass}${e}`), s.emitContainerClasses(), s.params.direction = e, s.slides.each(t => {
                    "vertical" === e ? t.style.width = "" : t.style.height = ""
                }), s.emit("changeDirection"), t && s.update()), s
            }
            mount(e) {
                const t = this;
                if (t.mounted) return !0;
                const s = d(e || t.params.el);
                if (!(e = s[0])) return !1;
                e.swiper = t;
                const i = () => `.${(t.params.wrapperClass||"").trim().split(" ").join(".")}`;
                let r = (() => {
                    if (e && e.shadowRoot && e.shadowRoot.querySelector) {
                        const t = d(e.shadowRoot.querySelector(i()));
                        return t.children = (e => s.children(e)), t
                    }
                    return s.children(i())
                })();
                if (0 === r.length && t.params.createElements) {
                    const e = a().createElement("div");
                    r = d(e), e.className = t.params.wrapperClass, s.append(e), s.children(`.${t.params.slideClass}`).each(e => {
                        r.append(e)
                    })
                }
                return Object.assign(t, {
                    $el: s,
                    el: e,
                    $wrapperEl: r,
                    wrapperEl: r[0],
                    mounted: !0,
                    rtl: "rtl" === e.dir.toLowerCase() || "rtl" === s.css("direction"),
                    rtlTranslate: "horizontal" === t.params.direction && ("rtl" === e.dir.toLowerCase() || "rtl" === s.css("direction")),
                    wrongRTL: "-webkit-box" === r.css("display")
                }), !0
            }
            init(e) {
                const t = this;
                return t.initialized ? t : (!1 === t.mount(e) || (t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.params.loop && t.loopCreate(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.preloadImages && t.preloadImages(), t.params.loop ? t.slideTo(t.params.initialSlide + t.loopedSlides, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.attachEvents(), t.initialized = !0, t.emit("init"), t.emit("afterInit")), t)
            }
            destroy(e = !0, t = !0) {
                const s = this,
                    {
                        params: a,
                        $el: i,
                        $wrapperEl: r,
                        slides: n
                    } = s;
                return void 0 === s.params || s.destroyed || (s.emit("beforeDestroy"), s.initialized = !1, s.detachEvents(), a.loop && s.loopDestroy(), t && (s.removeClasses(), i.removeAttr("style"), r.removeAttr("style"), n && n.length && n.removeClass([a.slideVisibleClass, a.slideActiveClass, a.slideNextClass, a.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index")), s.emit("destroy"), Object.keys(s.eventsListeners).forEach(e => {
                    s.off(e)
                }), !1 !== e && (s.$el[0].swiper = null, function(e) {
                    const t = s;
                    Object.keys(t).forEach(e => {
                        try {
                            t[e] = null
                        } catch (e) {}
                        try {
                            delete t[e]
                        } catch (e) {}
                    })
                }()), s.destroyed = !0), null
            }
            static extendDefaults(e) {
                f(X, e)
            }
            static get extendedDefaults() {
                return X
            }
            static get defaults() {
                return G
            }
            static installModule(e) {
                H.prototype.__modules__ || (H.prototype.__modules__ = []);
                const t = H.prototype.__modules__;
                "function" == typeof e && t.indexOf(e) < 0 && t.push(e)
            }
            static use(e) {
                return Array.isArray(e) ? (e.forEach(e => H.installModule(e)), H) : (H.installModule(e), H)
            }
        }

        function Y(e, t, s, i) {
            const r = a();
            return e.params.createElements && Object.keys(i).forEach(a => {
                if (!s[a] && !0 === s.auto) {
                    let n = e.$el.children(`.${i[a]}`)[0];
                    n || ((n = r.createElement("div")).className = i[a], e.$el.append(n)), s[a] = n, t[a] = n
                }
            }), s
        }

        function W(e = "") {
            return `.${e.trim().replace(/([\.:!\/])/g,"\\$1").replace(/ /g,".")}`
        }

        function F(e) {
            const {
                effect: t,
                swiper: s,
                on: a,
                setTranslate: i,
                setTransition: r,
                overwriteParams: n,
                perspective: l
            } = e;
            a("beforeInit", () => {
                if (s.params.effect !== t) return;
                s.classNames.push(`${s.params.containerModifierClass}${t}`), l && l() && s.classNames.push(`${s.params.containerModifierClass}3d`);
                const e = n ? n() : {};
                Object.assign(s.params, e), Object.assign(s.originalParams, e)
            }), a("setTranslate", () => {
                s.params.effect === t && i()
            }), a("setTransition", (e, a) => {
                s.params.effect === t && r(a)
            })
        }

        function U(e, t) {
            return e.transformEl ? t.find(e.transformEl).css({
                "backface-visibility": "hidden",
                "-webkit-backface-visibility": "hidden"
            }) : t
        }

        function K({
            swiper: e,
            duration: t,
            transformEl: s,
            allSlides: a
        }) {
            const {
                slides: i,
                activeIndex: r,
                $wrapperEl: n
            } = e;
            if (e.params.virtualTranslate && 0 !== t) {
                let t, l = !1;
                (t = a ? s ? i.find(s) : i : s ? i.eq(r).find(s) : i.eq(r)).transitionEnd(() => {
                    if (l) return;
                    if (!e || e.destroyed) return;
                    l = !0, e.animating = !1;
                    const t = ["webkitTransitionEnd", "transitionend"];
                    for (let e = 0; e < t.length; e += 1) n.trigger(t[e])
                })
            }
        }

        function Z(e, t, s) {
            const a = "swiper-slide-shadow" + (s ? `-${s}` : ""),
                i = e.transformEl ? t.find(e.transformEl) : t;
            let r = i.children(`.${a}`);
            return r.length || (r = d(`<div class="swiper-slide-shadow${s?`-${s}`:""}"></div>`), i.append(r)), r
        }
        Object.keys(B).forEach(e => {
            Object.keys(B[e]).forEach(t => {
                H.prototype[t] = B[e][t]
            })
        }), H.use([function({
            swiper: e,
            on: t,
            emit: s
        }) {
            const a = r();
            let i = null;
            const n = () => {
                    e && !e.destroyed && e.initialized && (s("beforeResize"), s("resize"))
                },
                l = () => {
                    e && !e.destroyed && e.initialized && s("orientationchange")
                };
            t("init", () => {
                e.params.resizeObserver && void 0 !== a.ResizeObserver ? e && !e.destroyed && e.initialized && (i = new ResizeObserver(t => {
                    const {
                        width: s,
                        height: a
                    } = e;
                    let i = s,
                        r = a;
                    t.forEach(({
                        contentBoxSize: t,
                        contentRect: s,
                        target: a
                    }) => {
                        a && a !== e.el || (i = s ? s.width : (t[0] || t).inlineSize, r = s ? s.height : (t[0] || t).blockSize)
                    }), i === s && r === a || n()
                })).observe(e.el) : (a.addEventListener("resize", n), a.addEventListener("orientationchange", l))
            }), t("destroy", () => {
                i && i.unobserve && e.el && (i.unobserve(e.el), i = null), a.removeEventListener("resize", n), a.removeEventListener("orientationchange", l)
            })
        }, function({
            swiper: e,
            extendParams: t,
            on: s,
            emit: a
        }) {
            const i = [],
                n = r(),
                l = (e, t = {}) => {
                    const s = new(n.MutationObserver || n.WebkitMutationObserver)(e => {
                        if (1 === e.length) return void a("observerUpdate", e[0]);
                        const t = function() {
                            a("observerUpdate", e[0])
                        };
                        n.requestAnimationFrame ? n.requestAnimationFrame(t) : n.setTimeout(t, 0)
                    });
                    s.observe(e, {
                        attributes: void 0 === t.attributes || t.attributes,
                        childList: void 0 === t.childList || t.childList,
                        characterData: void 0 === t.characterData || t.characterData
                    }), i.push(s)
                };
            t({
                observer: !1,
                observeParents: !1,
                observeSlideChildren: !1
            }), s("init", () => {
                if (e.params.observer) {
                    if (e.params.observeParents) {
                        const t = e.$el.parents();
                        for (let e = 0; e < t.length; e += 1) l(t[e])
                    }
                    l(e.$el[0], {
                        childList: e.params.observeSlideChildren
                    }), l(e.$wrapperEl[0], {
                        attributes: !1
                    })
                }
            }), s("destroy", () => {
                i.forEach(e => {
                    e.disconnect()
                }), i.splice(0, i.length)
            })
        }]);
        const J = [function({
            swiper: e,
            extendParams: t,
            on: s
        }) {
            function a(t, s) {
                const a = e.params.virtual;
                if (a.cache && e.virtual.cache[s]) return e.virtual.cache[s];
                const i = a.renderSlide ? d(a.renderSlide.call(e, t, s)) : d(`<div class="${e.params.slideClass}" data-swiper-slide-index="${s}">${t}</div>`);
                return i.attr("data-swiper-slide-index") || i.attr("data-swiper-slide-index", s), a.cache && (e.virtual.cache[s] = i), i
            }

            function i(t) {
                const {
                    slidesPerView: s,
                    slidesPerGroup: i,
                    centeredSlides: r
                } = e.params, {
                    addSlidesBefore: n,
                    addSlidesAfter: l
                } = e.params.virtual, {
                    from: o,
                    to: d,
                    slides: c,
                    slidesGrid: p,
                    offset: u
                } = e.virtual;
                e.updateActiveIndex();
                const h = e.activeIndex || 0;
                let m, f, g;
                m = e.rtlTranslate ? "right" : e.isHorizontal() ? "left" : "top", r ? (f = Math.floor(s / 2) + i + l, g = Math.floor(s / 2) + i + n) : (f = s + (i - 1) + l, g = i + n);
                const v = Math.max((h || 0) - g, 0),
                    w = Math.min((h || 0) + f, c.length - 1),
                    b = (e.slidesGrid[v] || 0) - (e.slidesGrid[0] || 0);

                function x() {
                    e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.lazy && e.params.lazy.enabled && e.lazy.load()
                }
                if (Object.assign(e.virtual, {
                        from: v,
                        to: w,
                        offset: b,
                        slidesGrid: e.slidesGrid
                    }), o === v && d === w && !t) return e.slidesGrid !== p && b !== u && e.slides.css(m, `${b}px`), void e.updateProgress();
                if (e.params.virtual.renderExternal) return e.params.virtual.renderExternal.call(e, {
                    offset: b,
                    from: v,
                    to: w,
                    slides: function() {
                        const e = [];
                        for (let t = v; t <= w; t += 1) e.push(c[t]);
                        return e
                    }()
                }), void(e.params.virtual.renderExternalUpdate && x());
                const y = [],
                    E = [];
                if (t) e.$wrapperEl.find(`.${e.params.slideClass}`).remove();
                else
                    for (let t = o; t <= d; t += 1)(t < v || t > w) && e.$wrapperEl.find(`.${e.params.slideClass}[data-swiper-slide-index="${t}"]`).remove();
                for (let e = 0; e < c.length; e += 1) e >= v && e <= w && (void 0 === d || t ? E.push(e) : (e > d && E.push(e), e < o && y.push(e)));
                E.forEach(t => {
                    e.$wrapperEl.append(a(c[t], t))
                }), y.sort((e, t) => t - e).forEach(t => {
                    e.$wrapperEl.prepend(a(c[t], t))
                }), e.$wrapperEl.children(".swiper-slide").css(m, `${b}px`), x()
            }
            t({
                virtual: {
                    enabled: !1,
                    slides: [],
                    cache: !0,
                    renderSlide: null,
                    renderExternal: null,
                    renderExternalUpdate: !0,
                    addSlidesBefore: 0,
                    addSlidesAfter: 0
                }
            }), e.virtual = {
                cache: {},
                from: void 0,
                to: void 0,
                slides: [],
                offset: 0,
                slidesGrid: []
            }, s("beforeInit", () => {
                e.params.virtual.enabled && (e.virtual.slides = e.params.virtual.slides, e.classNames.push(`${e.params.containerModifierClass}virtual`), e.params.watchSlidesProgress = !0, e.originalParams.watchSlidesProgress = !0, e.params.initialSlide || i())
            }), s("setTranslate", () => {
                e.params.virtual.enabled && i()
            }), s("init update resize", () => {
                e.params.virtual.enabled && e.params.cssMode && g(e.wrapperEl, "--swiper-virtual-size", `${e.virtualSize}px`)
            }), Object.assign(e.virtual, {
                appendSlide: function(t) {
                    if ("object" == typeof t && "length" in t)
                        for (let s = 0; s < t.length; s += 1) t[s] && e.virtual.slides.push(t[s]);
                    else e.virtual.slides.push(t);
                    i(!0)
                },
                prependSlide: function(t) {
                    const s = e.activeIndex;
                    let a = s + 1,
                        r = 1;
                    if (Array.isArray(t)) {
                        for (let s = 0; s < t.length; s += 1) t[s] && e.virtual.slides.unshift(t[s]);
                        a = s + t.length, r = t.length
                    } else e.virtual.slides.unshift(t);
                    if (e.params.virtual.cache) {
                        const t = e.virtual.cache,
                            s = {};
                        Object.keys(t).forEach(e => {
                            const a = t[e],
                                i = a.attr("data-swiper-slide-index");
                            i && a.attr("data-swiper-slide-index", parseInt(i, 10) + 1), s[parseInt(e, 10) + r] = a
                        }), e.virtual.cache = s
                    }
                    i(!0), e.slideTo(a, 0)
                },
                removeSlide: function(t) {
                    if (null == t) return;
                    let s = e.activeIndex;
                    if (Array.isArray(t))
                        for (let a = t.length - 1; a >= 0; a -= 1) e.virtual.slides.splice(t[a], 1), e.params.virtual.cache && delete e.virtual.cache[t[a]], t[a] < s && (s -= 1), s = Math.max(s, 0);
                    else e.virtual.slides.splice(t, 1), e.params.virtual.cache && delete e.virtual.cache[t], t < s && (s -= 1), s = Math.max(s, 0);
                    i(!0), e.slideTo(s, 0)
                },
                removeAllSlides: function() {
                    e.virtual.slides = [], e.params.virtual.cache && (e.virtual.cache = {}), i(!0), e.slideTo(0, 0)
                },
                update: i
            })
        }, function({
            swiper: e,
            extendParams: t,
            on: s,
            emit: i
        }) {
            const n = a(),
                l = r();

            function o(t) {
                if (!e.enabled) return;
                const {
                    rtlTranslate: s
                } = e;
                let a = t;
                a.originalEvent && (a = a.originalEvent);
                const r = a.keyCode || a.charCode,
                    o = e.params.keyboard.pageUpDown,
                    d = o && 33 === r,
                    c = o && 34 === r,
                    p = 37 === r,
                    u = 39 === r,
                    h = 38 === r,
                    m = 40 === r;
                if (!e.allowSlideNext && (e.isHorizontal() && u || e.isVertical() && m || c)) return !1;
                if (!e.allowSlidePrev && (e.isHorizontal() && p || e.isVertical() && h || d)) return !1;
                if (!(a.shiftKey || a.altKey || a.ctrlKey || a.metaKey || n.activeElement && n.activeElement.nodeName && ("input" === n.activeElement.nodeName.toLowerCase() || "textarea" === n.activeElement.nodeName.toLowerCase()))) {
                    if (e.params.keyboard.onlyInViewport && (d || c || p || u || h || m)) {
                        let t = !1;
                        if (e.$el.parents(`.${e.params.slideClass}`).length > 0 && 0 === e.$el.parents(`.${e.params.slideActiveClass}`).length) return;
                        const a = e.$el,
                            i = a[0].clientWidth,
                            r = a[0].clientHeight,
                            n = l.innerWidth,
                            o = l.innerHeight,
                            d = e.$el.offset();
                        s && (d.left -= e.$el[0].scrollLeft);
                        const c = [
                            [d.left, d.top],
                            [d.left + i, d.top],
                            [d.left, d.top + r],
                            [d.left + i, d.top + r]
                        ];
                        for (let e = 0; e < c.length; e += 1) {
                            const s = c[e];
                            if (s[0] >= 0 && s[0] <= n && s[1] >= 0 && s[1] <= o) {
                                if (0 === s[0] && 0 === s[1]) continue;
                                t = !0
                            }
                        }
                        if (!t) return
                    }
                    e.isHorizontal() ? ((d || c || p || u) && (a.preventDefault ? a.preventDefault() : a.returnValue = !1), ((c || u) && !s || (d || p) && s) && e.slideNext(), ((d || p) && !s || (c || u) && s) && e.slidePrev()) : ((d || c || h || m) && (a.preventDefault ? a.preventDefault() : a.returnValue = !1), (c || m) && e.slideNext(), (d || h) && e.slidePrev()), i("keyPress", r)
                }
            }

            function c() {
                e.keyboard.enabled || (d(n).on("keydown", o), e.keyboard.enabled = !0)
            }

            function p() {
                e.keyboard.enabled && (d(n).off("keydown", o), e.keyboard.enabled = !1)
            }
            e.keyboard = {
                enabled: !1
            }, t({
                keyboard: {
                    enabled: !1,
                    onlyInViewport: !0,
                    pageUpDown: !0
                }
            }), s("init", () => {
                e.params.keyboard.enabled && c()
            }), s("destroy", () => {
                e.keyboard.enabled && p()
            }), Object.assign(e.keyboard, {
                enable: c,
                disable: p
            })
        }, function({
            swiper: e,
            extendParams: t,
            on: s,
            emit: a
        }) {
            const i = r();
            let n;
            t({
                mousewheel: {
                    enabled: !1,
                    releaseOnEdges: !1,
                    invert: !1,
                    forceToAxis: !1,
                    sensitivity: 1,
                    eventsTarget: "container",
                    thresholdDelta: null,
                    thresholdTime: null
                }
            }), e.mousewheel = {
                enabled: !1
            };
            let l, o = u();
            const c = [];

            function h() {
                e.enabled && (e.mouseEntered = !0)
            }

            function m() {
                e.enabled && (e.mouseEntered = !1)
            }

            function f(t) {
                return !(e.params.mousewheel.thresholdDelta && t.delta < e.params.mousewheel.thresholdDelta || e.params.mousewheel.thresholdTime && u() - o < e.params.mousewheel.thresholdTime || !(t.delta >= 6 && u() - o < 60) && (t.direction < 0 ? e.isEnd && !e.params.loop || e.animating || (e.slideNext(), a("scroll", t.raw)) : e.isBeginning && !e.params.loop || e.animating || (e.slidePrev(), a("scroll", t.raw)), o = (new i.Date).getTime(), 1))
            }

            function g(t) {
                let s = t,
                    i = !0;
                if (!e.enabled) return;
                const r = e.params.mousewheel;
                e.params.cssMode && s.preventDefault();
                let o = e.$el;
                if ("container" !== e.params.mousewheel.eventsTarget && (o = d(e.params.mousewheel.eventsTarget)), !e.mouseEntered && !o[0].contains(s.target) && !r.releaseOnEdges) return !0;
                s.originalEvent && (s = s.originalEvent);
                let h = 0;
                const m = e.rtlTranslate ? -1 : 1,
                    g = function(e) {
                        let t = 0,
                            s = 0,
                            a = 0,
                            i = 0;
                        return "detail" in e && (s = e.detail), "wheelDelta" in e && (s = -e.wheelDelta / 120), "wheelDeltaY" in e && (s = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (t = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (t = s, s = 0), a = 10 * t, i = 10 * s, "deltaY" in e && (i = e.deltaY), "deltaX" in e && (a = e.deltaX), e.shiftKey && !a && (a = i, i = 0), (a || i) && e.deltaMode && (1 === e.deltaMode ? (a *= 40, i *= 40) : (a *= 800, i *= 800)), a && !t && (t = a < 1 ? -1 : 1), i && !s && (s = i < 1 ? -1 : 1), {
                            spinX: t,
                            spinY: s,
                            pixelX: a,
                            pixelY: i
                        }
                    }(s);
                if (r.forceToAxis)
                    if (e.isHorizontal()) {
                        if (!(Math.abs(g.pixelX) > Math.abs(g.pixelY))) return !0;
                        h = -g.pixelX * m
                    } else {
                        if (!(Math.abs(g.pixelY) > Math.abs(g.pixelX))) return !0;
                        h = -g.pixelY
                    }
                else h = Math.abs(g.pixelX) > Math.abs(g.pixelY) ? -g.pixelX * m : -g.pixelY;
                if (0 === h) return !0;
                r.invert && (h = -h);
                let v = e.getTranslate() + h * r.sensitivity;
                if (v >= e.minTranslate() && (v = e.minTranslate()), v <= e.maxTranslate() && (v = e.maxTranslate()), (i = !!e.params.loop || !(v === e.minTranslate() || v === e.maxTranslate())) && e.params.nested && s.stopPropagation(), e.params.freeMode && e.params.freeMode.enabled) {
                    const t = {
                            time: u(),
                            delta: Math.abs(h),
                            direction: Math.sign(h)
                        },
                        i = l && t.time < l.time + 500 && t.delta <= l.delta && t.direction === l.direction;
                    if (!i) {
                        l = void 0, e.params.loop && e.loopFix();
                        let o = e.getTranslate() + h * r.sensitivity;
                        const d = e.isBeginning,
                            u = e.isEnd;
                        if (o >= e.minTranslate() && (o = e.minTranslate()), o <= e.maxTranslate() && (o = e.maxTranslate()), e.setTransition(0), e.setTranslate(o), e.updateProgress(), e.updateActiveIndex(), e.updateSlidesClasses(), (!d && e.isBeginning || !u && e.isEnd) && e.updateSlidesClasses(), e.params.freeMode.sticky) {
                            clearTimeout(n), n = void 0, c.length >= 15 && c.shift();
                            const s = c.length ? c[c.length - 1] : void 0,
                                a = c[0];
                            if (c.push(t), s && (t.delta > s.delta || t.direction !== s.direction)) c.splice(0);
                            else if (c.length >= 15 && t.time - a.time < 500 && a.delta - t.delta >= 1 && t.delta <= 6) {
                                const s = h > 0 ? .8 : .2;
                                l = t, c.splice(0), n = p(() => {
                                    e.slideToClosest(e.params.speed, !0, void 0, s)
                                }, 0)
                            }
                            n || (n = p(() => {
                                l = t, c.splice(0), e.slideToClosest(e.params.speed, !0, void 0, .5)
                            }, 500))
                        }
                        if (i || a("scroll", s), e.params.autoplay && e.params.autoplayDisableOnInteraction && e.autoplay.stop(), o === e.minTranslate() || o === e.maxTranslate()) return !0
                    }
                } else {
                    const s = {
                        time: u(),
                        delta: Math.abs(h),
                        direction: Math.sign(h),
                        raw: t
                    };
                    c.length >= 2 && c.shift();
                    const a = c.length ? c[c.length - 1] : void 0;
                    if (c.push(s), a ? (s.direction !== a.direction || s.delta > a.delta || s.time > a.time + 150) && f(s) : f(s), function(t) {
                            const s = e.params.mousewheel;
                            if (t.direction < 0) {
                                if (e.isEnd && !e.params.loop && s.releaseOnEdges) return !0
                            } else if (e.isBeginning && !e.params.loop && s.releaseOnEdges) return !0;
                            return !1
                        }(s)) return !0
                }
                return s.preventDefault ? s.preventDefault() : s.returnValue = !1, !1
            }

            function v(t) {
                let s = e.$el;
                "container" !== e.params.mousewheel.eventsTarget && (s = d(e.params.mousewheel.eventsTarget)), s[t]("mouseenter", h), s[t]("mouseleave", m), s[t]("wheel", g)
            }

            function w() {
                return e.params.cssMode ? (e.wrapperEl.removeEventListener("wheel", g), !0) : !e.mousewheel.enabled && (v("on"), e.mousewheel.enabled = !0, !0)
            }

            function b() {
                return e.params.cssMode ? (e.wrapperEl.addEventListener(event, g), !0) : !!e.mousewheel.enabled && (v("off"), e.mousewheel.enabled = !1, !0)
            }
            s("init", () => {
                !e.params.mousewheel.enabled && e.params.cssMode && b(), e.params.mousewheel.enabled && w()
            }), s("destroy", () => {
                e.params.cssMode && w(), e.mousewheel.enabled && b()
            }), Object.assign(e.mousewheel, {
                enable: w,
                disable: b
            })
        }, function({
            swiper: e,
            extendParams: t,
            on: s,
            emit: a
        }) {
            function i(t) {
                let s;
                return t && (s = d(t), e.params.uniqueNavElements && "string" == typeof t && s.length > 1 && 1 === e.$el.find(t).length && (s = e.$el.find(t))), s
            }

            function r(t, s) {
                const a = e.params.navigation;
                t && t.length > 0 && (t[s ? "addClass" : "removeClass"](a.disabledClass), t[0] && "BUTTON" === t[0].tagName && (t[0].disabled = s), e.params.watchOverflow && e.enabled && t[e.isLocked ? "addClass" : "removeClass"](a.lockClass))
            }

            function n() {
                if (e.params.loop) return;
                const {
                    $nextEl: t,
                    $prevEl: s
                } = e.navigation;
                r(s, e.isBeginning), r(t, e.isEnd)
            }

            function l(t) {
                t.preventDefault(), e.isBeginning && !e.params.loop || e.slidePrev()
            }

            function o(t) {
                t.preventDefault(), e.isEnd && !e.params.loop || e.slideNext()
            }

            function c() {
                const t = e.params.navigation;
                if (e.params.navigation = Y(e, e.originalParams.navigation, e.params.navigation, {
                        nextEl: "swiper-button-next",
                        prevEl: "swiper-button-prev"
                    }), !t.nextEl && !t.prevEl) return;
                const s = i(t.nextEl),
                    a = i(t.prevEl);
                s && s.length > 0 && s.on("click", o), a && a.length > 0 && a.on("click", l), Object.assign(e.navigation, {
                    $nextEl: s,
                    nextEl: s && s[0],
                    $prevEl: a,
                    prevEl: a && a[0]
                }), e.enabled || (s && s.addClass(t.lockClass), a && a.addClass(t.lockClass))
            }

            function p() {
                const {
                    $nextEl: t,
                    $prevEl: s
                } = e.navigation;
                t && t.length && (t.off("click", o), t.removeClass(e.params.navigation.disabledClass)), s && s.length && (s.off("click", l), s.removeClass(e.params.navigation.disabledClass))
            }
            t({
                navigation: {
                    nextEl: null,
                    prevEl: null,
                    hideOnClick: !1,
                    disabledClass: "swiper-button-disabled",
                    hiddenClass: "swiper-button-hidden",
                    lockClass: "swiper-button-lock"
                }
            }), e.navigation = {
                nextEl: null,
                $nextEl: null,
                prevEl: null,
                $prevEl: null
            }, s("init", () => {
                c(), n()
            }), s("toEdge fromEdge lock unlock", () => {
                n()
            }), s("destroy", () => {
                p()
            }), s("enable disable", () => {
                const {
                    $nextEl: t,
                    $prevEl: s
                } = e.navigation;
                t && t[e.enabled ? "removeClass" : "addClass"](e.params.navigation.lockClass), s && s[e.enabled ? "removeClass" : "addClass"](e.params.navigation.lockClass)
            }), s("click", (t, s) => {
                const {
                    $nextEl: i,
                    $prevEl: r
                } = e.navigation, n = s.target;
                if (e.params.navigation.hideOnClick && !d(n).is(r) && !d(n).is(i)) {
                    if (e.pagination && e.params.pagination && e.params.pagination.clickable && (e.pagination.el === n || e.pagination.el.contains(n))) return;
                    let t;
                    i ? t = i.hasClass(e.params.navigation.hiddenClass) : r && (t = r.hasClass(e.params.navigation.hiddenClass)), a(!0 === t ? "navigationShow" : "navigationHide"), i && i.toggleClass(e.params.navigation.hiddenClass), r && r.toggleClass(e.params.navigation.hiddenClass)
                }
            }), Object.assign(e.navigation, {
                update: n,
                init: c,
                destroy: p
            })
        }, function({
            swiper: e,
            extendParams: t,
            on: s,
            emit: a
        }) {
            const i = "swiper-pagination";
            let r;
            t({
                pagination: {
                    el: null,
                    bulletElement: "span",
                    clickable: !1,
                    hideOnClick: !1,
                    renderBullet: null,
                    renderProgressbar: null,
                    renderFraction: null,
                    renderCustom: null,
                    progressbarOpposite: !1,
                    type: "bullets",
                    dynamicBullets: !1,
                    dynamicMainBullets: 1,
                    formatFractionCurrent: e => e,
                    formatFractionTotal: e => e,
                    bulletClass: `${i}-bullet`,
                    bulletActiveClass: `${i}-bullet-active`,
                    modifierClass: `${i}-`,
                    currentClass: `${i}-current`,
                    totalClass: `${i}-total`,
                    hiddenClass: `${i}-hidden`,
                    progressbarFillClass: `${i}-progressbar-fill`,
                    progressbarOppositeClass: `${i}-progressbar-opposite`,
                    clickableClass: `${i}-clickable`,
                    lockClass: `${i}-lock`,
                    horizontalClass: `${i}-horizontal`,
                    verticalClass: `${i}-vertical`
                }
            }), e.pagination = {
                el: null,
                $el: null,
                bullets: []
            };
            let n = 0;

            function l() {
                return !e.params.pagination.el || !e.pagination.el || !e.pagination.$el || 0 === e.pagination.$el.length
            }

            function o(t, s) {
                const {
                    bulletActiveClass: a
                } = e.params.pagination;
                t[s]().addClass(`${a}-${s}`)[s]().addClass(`${a}-${s}-${s}`)
            }

            function c() {
                const t = e.rtl,
                    s = e.params.pagination;
                if (l()) return;
                const i = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length,
                    c = e.pagination.$el;
                let p;
                const u = e.params.loop ? Math.ceil((i - 2 * e.loopedSlides) / e.params.slidesPerGroup) : e.snapGrid.length;
                if (e.params.loop ? ((p = Math.ceil((e.activeIndex - e.loopedSlides) / e.params.slidesPerGroup)) > i - 1 - 2 * e.loopedSlides && (p -= i - 2 * e.loopedSlides), p > u - 1 && (p -= u), p < 0 && "bullets" !== e.params.paginationType && (p = u + p)) : p = void 0 !== e.snapIndex ? e.snapIndex : e.activeIndex || 0, "bullets" === s.type && e.pagination.bullets && e.pagination.bullets.length > 0) {
                    const a = e.pagination.bullets;
                    let i, l, u;
                    if (s.dynamicBullets && (r = a.eq(0)[e.isHorizontal() ? "outerWidth" : "outerHeight"](!0), c.css(e.isHorizontal() ? "width" : "height", r * (s.dynamicMainBullets + 4) + "px"), s.dynamicMainBullets > 1 && void 0 !== e.previousIndex && ((n += p - e.previousIndex) > s.dynamicMainBullets - 1 ? n = s.dynamicMainBullets - 1 : n < 0 && (n = 0)), u = ((l = (i = p - n) + (Math.min(a.length, s.dynamicMainBullets) - 1)) + i) / 2), a.removeClass(["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map(e => `${s.bulletActiveClass}${e}`).join(" ")), c.length > 1) a.each(e => {
                        const t = d(e),
                            a = t.index();
                        a === p && t.addClass(s.bulletActiveClass), s.dynamicBullets && (a >= i && a <= l && t.addClass(`${s.bulletActiveClass}-main`), a === i && o(t, "prev"), a === l && o(t, "next"))
                    });
                    else {
                        const t = a.eq(p),
                            r = t.index();
                        if (t.addClass(s.bulletActiveClass), s.dynamicBullets) {
                            const t = a.eq(i),
                                n = a.eq(l);
                            for (let e = i; e <= l; e += 1) a.eq(e).addClass(`${s.bulletActiveClass}-main`);
                            if (e.params.loop)
                                if (r >= a.length - s.dynamicMainBullets) {
                                    for (let e = s.dynamicMainBullets; e >= 0; e -= 1) a.eq(a.length - e).addClass(`${s.bulletActiveClass}-main`);
                                    a.eq(a.length - s.dynamicMainBullets - 1).addClass(`${s.bulletActiveClass}-prev`)
                                } else o(t, "prev"), o(n, "next");
                            else o(t, "prev"), o(n, "next")
                        }
                    }
                    if (s.dynamicBullets) {
                        const i = Math.min(a.length, s.dynamicMainBullets + 4),
                            n = (r * i - r) / 2 - u * r,
                            l = t ? "right" : "left";
                        a.css(e.isHorizontal() ? l : "top", `${n}px`)
                    }
                }
                if ("fraction" === s.type && (c.find(W(s.currentClass)).text(s.formatFractionCurrent(p + 1)), c.find(W(s.totalClass)).text(s.formatFractionTotal(u))), "progressbar" === s.type) {
                    let t;
                    t = s.progressbarOpposite ? e.isHorizontal() ? "vertical" : "horizontal" : e.isHorizontal() ? "horizontal" : "vertical";
                    const a = (p + 1) / u;
                    let i = 1,
                        r = 1;
                    "horizontal" === t ? i = a : r = a, c.find(W(s.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${i}) scaleY(${r})`).transition(e.params.speed)
                }
                "custom" === s.type && s.renderCustom ? (c.html(s.renderCustom(e, p + 1, u)), a("paginationRender", c[0])) : a("paginationUpdate", c[0]), e.params.watchOverflow && e.enabled && c[e.isLocked ? "addClass" : "removeClass"](s.lockClass)
            }

            function p() {
                const t = e.params.pagination;
                if (l()) return;
                const s = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length,
                    i = e.pagination.$el;
                let r = "";
                if ("bullets" === t.type) {
                    let a = e.params.loop ? Math.ceil((s - 2 * e.loopedSlides) / e.params.slidesPerGroup) : e.snapGrid.length;
                    e.params.freeMode && e.params.freeMode.enabled && !e.params.loop && a > s && (a = s);
                    for (let s = 0; s < a; s += 1) t.renderBullet ? r += t.renderBullet.call(e, s, t.bulletClass) : r += `<${t.bulletElement} class="${t.bulletClass}"></${t.bulletElement}>`;
                    i.html(r), e.pagination.bullets = i.find(W(t.bulletClass))
                }
                "fraction" === t.type && (r = t.renderFraction ? t.renderFraction.call(e, t.currentClass, t.totalClass) : `<span class="${t.currentClass}"></span> / <span class="${t.totalClass}"></span>`, i.html(r)), "progressbar" === t.type && (r = t.renderProgressbar ? t.renderProgressbar.call(e, t.progressbarFillClass) : `<span class="${t.progressbarFillClass}"></span>`, i.html(r)), "custom" !== t.type && a("paginationRender", e.pagination.$el[0])
            }

            function u() {
                e.params.pagination = Y(e, e.originalParams.pagination, e.params.pagination, {
                    el: "swiper-pagination"
                });
                const t = e.params.pagination;
                if (!t.el) return;
                let s = d(t.el);
                0 !== s.length && (e.params.uniqueNavElements && "string" == typeof t.el && s.length > 1 && ((s = e.$el.find(t.el)).length > 1 && (s = s.filter(t => d(t).parents(".swiper")[0] === e.el))), "bullets" === t.type && t.clickable && s.addClass(t.clickableClass), s.addClass(t.modifierClass + t.type), s.addClass(t.modifierClass + e.params.direction), "bullets" === t.type && t.dynamicBullets && (s.addClass(`${t.modifierClass}${t.type}-dynamic`), n = 0, t.dynamicMainBullets < 1 && (t.dynamicMainBullets = 1)), "progressbar" === t.type && t.progressbarOpposite && s.addClass(t.progressbarOppositeClass), t.clickable && s.on("click", W(t.bulletClass), function(t) {
                    t.preventDefault();
                    let s = d(this).index() * e.params.slidesPerGroup;
                    e.params.loop && (s += e.loopedSlides), e.slideTo(s)
                }), Object.assign(e.pagination, {
                    $el: s,
                    el: s[0]
                }), e.enabled || s.addClass(t.lockClass))
            }

            function h() {
                const t = e.params.pagination;
                if (l()) return;
                const s = e.pagination.$el;
                s.removeClass(t.hiddenClass), s.removeClass(t.modifierClass + t.type), s.removeClass(t.modifierClass + e.params.direction), e.pagination.bullets && e.pagination.bullets.removeClass && e.pagination.bullets.removeClass(t.bulletActiveClass), t.clickable && s.off("click", W(t.bulletClass))
            }
            s("init", () => {
                u(), p(), c()
            }), s("activeIndexChange", () => {
                (e.params.loop || void 0 === e.snapIndex) && c()
            }), s("snapIndexChange", () => {
                e.params.loop || c()
            }), s("slidesLengthChange", () => {
                e.params.loop && (p(), c())
            }), s("snapGridLengthChange", () => {
                e.params.loop || (p(), c())
            }), s("destroy", () => {
                h()
            }), s("enable disable", () => {
                const {
                    $el: t
                } = e.pagination;
                t && t[e.enabled ? "removeClass" : "addClass"](e.params.pagination.lockClass)
            }), s("lock unlock", () => {
                c()
            }), s("click", (t, s) => {
                const i = s.target,
                    {
                        $el: r
                    } = e.pagination;
                if (e.params.pagination.el && e.params.pagination.hideOnClick && r.length > 0 && !d(i).hasClass(e.params.pagination.bulletClass)) {
                    if (e.navigation && (e.navigation.nextEl && i === e.navigation.nextEl || e.navigation.prevEl && i === e.navigation.prevEl)) return;
                    const t = r.hasClass(e.params.pagination.hiddenClass);
                    a(!0 === t ? "paginationShow" : "paginationHide"), r.toggleClass(e.params.pagination.hiddenClass)
                }
            }), Object.assign(e.pagination, {
                render: p,
                update: c,
                init: u,
                destroy: h
            })
        }, function({
            swiper: e,
            extendParams: t,
            on: s,
            emit: i
        }) {
            const r = a();
            let n, l, o, c, u = !1,
                h = null,
                m = null;

            function f() {
                if (!e.params.scrollbar.el || !e.scrollbar.el) return;
                const {
                    scrollbar: t,
                    rtlTranslate: s,
                    progress: a
                } = e, {
                    $dragEl: i,
                    $el: r
                } = t, n = e.params.scrollbar;
                let d = l,
                    c = (o - l) * a;
                s ? (c = -c) > 0 ? (d = l - c, c = 0) : -c + l > o && (d = o + c) : c < 0 ? (d = l + c, c = 0) : c + l > o && (d = o - c), e.isHorizontal() ? (i.transform(`translate3d(${c}px, 0, 0)`), i[0].style.width = `${d}px`) : (i.transform(`translate3d(0px, ${c}px, 0)`), i[0].style.height = `${d}px`), n.hide && (clearTimeout(h), r[0].style.opacity = 1, h = setTimeout(() => {
                    r[0].style.opacity = 0, r.transition(400)
                }, 1e3))
            }

            function g() {
                if (!e.params.scrollbar.el || !e.scrollbar.el) return;
                const {
                    scrollbar: t
                } = e, {
                    $dragEl: s,
                    $el: a
                } = t;
                s[0].style.width = "", s[0].style.height = "", o = e.isHorizontal() ? a[0].offsetWidth : a[0].offsetHeight, c = e.size / (e.virtualSize + e.params.slidesOffsetBefore - (e.params.centeredSlides ? e.snapGrid[0] : 0)), l = "auto" === e.params.scrollbar.dragSize ? o * c : parseInt(e.params.scrollbar.dragSize, 10), e.isHorizontal() ? s[0].style.width = `${l}px` : s[0].style.height = `${l}px`, a[0].style.display = c >= 1 ? "none" : "", e.params.scrollbar.hide && (a[0].style.opacity = 0), e.params.watchOverflow && e.enabled && t.$el[e.isLocked ? "addClass" : "removeClass"](e.params.scrollbar.lockClass)
            }

            function v(t) {
                return e.isHorizontal() ? "touchstart" === t.type || "touchmove" === t.type ? t.targetTouches[0].clientX : t.clientX : "touchstart" === t.type || "touchmove" === t.type ? t.targetTouches[0].clientY : t.clientY
            }

            function w(t) {
                const {
                    scrollbar: s,
                    rtlTranslate: a
                } = e, {
                    $el: i
                } = s;
                let r;
                r = (v(t) - i.offset()[e.isHorizontal() ? "left" : "top"] - (null !== n ? n : l / 2)) / (o - l), r = Math.max(Math.min(r, 1), 0), a && (r = 1 - r);
                const d = e.minTranslate() + (e.maxTranslate() - e.minTranslate()) * r;
                e.updateProgress(d), e.setTranslate(d), e.updateActiveIndex(), e.updateSlidesClasses()
            }

            function b(t) {
                const s = e.params.scrollbar,
                    {
                        scrollbar: a,
                        $wrapperEl: r
                    } = e,
                    {
                        $el: l,
                        $dragEl: o
                    } = a;
                u = !0, n = t.target === o[0] || t.target === o ? v(t) - t.target.getBoundingClientRect()[e.isHorizontal() ? "left" : "top"] : null, t.preventDefault(), t.stopPropagation(), r.transition(100), o.transition(100), w(t), clearTimeout(m), l.transition(0), s.hide && l.css("opacity", 1), e.params.cssMode && e.$wrapperEl.css("scroll-snap-type", "none"), i("scrollbarDragStart", t)
            }

            function x(t) {
                const {
                    scrollbar: s,
                    $wrapperEl: a
                } = e, {
                    $el: r,
                    $dragEl: n
                } = s;
                u && (t.preventDefault ? t.preventDefault() : t.returnValue = !1, w(t), a.transition(0), r.transition(0), n.transition(0), i("scrollbarDragMove", t))
            }

            function y(t) {
                const s = e.params.scrollbar,
                    {
                        scrollbar: a,
                        $wrapperEl: r
                    } = e,
                    {
                        $el: n
                    } = a;
                u && (u = !1, e.params.cssMode && (e.$wrapperEl.css("scroll-snap-type", ""), r.transition("")), s.hide && (clearTimeout(m), m = p(() => {
                    n.css("opacity", 0), n.transition(400)
                }, 1e3)), i("scrollbarDragEnd", t), s.snapOnRelease && e.slideToClosest())
            }

            function E(t) {
                const {
                    scrollbar: s,
                    touchEventsTouch: a,
                    touchEventsDesktop: i,
                    params: n,
                    support: l
                } = e, o = s.$el[0], d = !(!l.passiveListener || !n.passiveListeners) && {
                    passive: !1,
                    capture: !1
                }, c = !(!l.passiveListener || !n.passiveListeners) && {
                    passive: !0,
                    capture: !1
                };
                if (!o) return;
                const p = "on" === t ? "addEventListener" : "removeEventListener";
                l.touch ? (o[p](a.start, b, d), o[p](a.move, x, d), o[p](a.end, y, c)) : (o[p](i.start, b, d), r[p](i.move, x, d), r[p](i.end, y, c))
            }

            function T() {
                const {
                    scrollbar: t,
                    $el: s
                } = e;
                e.params.scrollbar = Y(e, e.originalParams.scrollbar, e.params.scrollbar, {
                    el: "swiper-scrollbar"
                });
                const a = e.params.scrollbar;
                if (!a.el) return;
                let i = d(a.el);
                e.params.uniqueNavElements && "string" == typeof a.el && i.length > 1 && 1 === s.find(a.el).length && (i = s.find(a.el));
                let r = i.find(`.${e.params.scrollbar.dragClass}`);
                0 === r.length && (r = d(`<div class="${e.params.scrollbar.dragClass}"></div>`), i.append(r)), Object.assign(t, {
                    $el: i,
                    el: i[0],
                    $dragEl: r,
                    dragEl: r[0]
                }), a.draggable && e.params.scrollbar.el && E("on"), i && i[e.enabled ? "removeClass" : "addClass"](e.params.scrollbar.lockClass)
            }

            function C() {
                e.params.scrollbar.el && E("off")
            }
            t({
                scrollbar: {
                    el: null,
                    dragSize: "auto",
                    hide: !1,
                    draggable: !1,
                    snapOnRelease: !0,
                    lockClass: "swiper-scrollbar-lock",
                    dragClass: "swiper-scrollbar-drag"
                }
            }), e.scrollbar = {
                el: null,
                dragEl: null,
                $el: null,
                $dragEl: null
            }, s("init", () => {
                T(), g(), f()
            }), s("update resize observerUpdate lock unlock", () => {
                g()
            }), s("setTranslate", () => {
                f()
            }), s("setTransition", (t, s) => {
                ! function(t) {
                    e.params.scrollbar.el && e.scrollbar.el && e.scrollbar.$dragEl.transition(t)
                }(s)
            }), s("enable disable", () => {
                const {
                    $el: t
                } = e.scrollbar;
                t && t[e.enabled ? "removeClass" : "addClass"](e.params.scrollbar.lockClass)
            }), s("destroy", () => {
                C()
            }), Object.assign(e.scrollbar, {
                updateSize: g,
                setTranslate: f,
                init: T,
                destroy: C
            })
        }, function({
            swiper: e,
            extendParams: t,
            on: s
        }) {
            t({
                parallax: {
                    enabled: !1
                }
            });
            const a = (t, s) => {
                    const {
                        rtl: a
                    } = e, i = d(t), r = a ? -1 : 1, n = i.attr("data-swiper-parallax") || "0";
                    let l = i.attr("data-swiper-parallax-x"),
                        o = i.attr("data-swiper-parallax-y");
                    const c = i.attr("data-swiper-parallax-scale"),
                        p = i.attr("data-swiper-parallax-opacity");
                    if (l || o ? (l = l || "0", o = o || "0") : e.isHorizontal() ? (l = n, o = "0") : (o = n, l = "0"), l = l.indexOf("%") >= 0 ? parseInt(l, 10) * s * r + "%" : l * s * r + "px", o = o.indexOf("%") >= 0 ? parseInt(o, 10) * s + "%" : o * s + "px", null != p) {
                        const e = p - (p - 1) * (1 - Math.abs(s));
                        i[0].style.opacity = e
                    }
                    if (null == c) i.transform(`translate3d(${l}, ${o}, 0px)`);
                    else {
                        const e = c - (c - 1) * (1 - Math.abs(s));
                        i.transform(`translate3d(${l}, ${o}, 0px) scale(${e})`)
                    }
                },
                i = () => {
                    const {
                        $el: t,
                        slides: s,
                        progress: i,
                        snapGrid: r
                    } = e;
                    t.children("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each(e => {
                        a(e, i)
                    }), s.each((t, s) => {
                        let n = t.progress;
                        e.params.slidesPerGroup > 1 && "auto" !== e.params.slidesPerView && (n += Math.ceil(s / 2) - i * (r.length - 1)), n = Math.min(Math.max(n, -1), 1), d(t).find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each(e => {
                            a(e, n)
                        })
                    })
                };
            s("beforeInit", () => {
                e.params.parallax.enabled && (e.params.watchSlidesProgress = !0, e.originalParams.watchSlidesProgress = !0)
            }), s("init", () => {
                e.params.parallax.enabled && i()
            }), s("setTranslate", () => {
                e.params.parallax.enabled && i()
            }), s("setTransition", (t, s) => {
                e.params.parallax.enabled && ((t = e.params.speed) => {
                    const {
                        $el: s
                    } = e;
                    s.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each(e => {
                        const s = d(e);
                        let a = parseInt(s.attr("data-swiper-parallax-duration"), 10) || t;
                        0 === t && (a = 0), s.transition(a)
                    })
                })(s)
            })
        }, function({
            swiper: e,
            extendParams: t,
            on: s,
            emit: a
        }) {
            const i = r();
            t({
                zoom: {
                    enabled: !1,
                    maxRatio: 3,
                    minRatio: 1,
                    toggle: !0,
                    containerClass: "swiper-zoom-container",
                    zoomedSlideClass: "swiper-slide-zoomed"
                }
            }), e.zoom = {
                enabled: !1
            };
            let n, l, o, c = 1,
                p = !1;
            const u = {
                    $slideEl: void 0,
                    slideWidth: void 0,
                    slideHeight: void 0,
                    $imageEl: void 0,
                    $imageWrapEl: void 0,
                    maxRatio: 3
                },
                m = {
                    isTouched: void 0,
                    isMoved: void 0,
                    currentX: void 0,
                    currentY: void 0,
                    minX: void 0,
                    minY: void 0,
                    maxX: void 0,
                    maxY: void 0,
                    width: void 0,
                    height: void 0,
                    startX: void 0,
                    startY: void 0,
                    touchesStart: {},
                    touchesCurrent: {}
                },
                f = {
                    x: void 0,
                    y: void 0,
                    prevPositionX: void 0,
                    prevPositionY: void 0,
                    prevTime: void 0
                };
            let g = 1;

            function v(e) {
                if (e.targetTouches.length < 2) return 1;
                const t = e.targetTouches[0].pageX,
                    s = e.targetTouches[0].pageY,
                    a = e.targetTouches[1].pageX,
                    i = e.targetTouches[1].pageY;
                return Math.sqrt((a - t) ** 2 + (i - s) ** 2)
            }

            function w(t) {
                const s = e.support,
                    a = e.params.zoom;
                if (l = !1, o = !1, !s.gestures) {
                    if ("touchstart" !== t.type || "touchstart" === t.type && t.targetTouches.length < 2) return;
                    l = !0, u.scaleStart = v(t)
                }
                u.$slideEl && u.$slideEl.length || (u.$slideEl = d(t.target).closest(`.${e.params.slideClass}`), 0 === u.$slideEl.length && (u.$slideEl = e.slides.eq(e.activeIndex)), u.$imageEl = u.$slideEl.find(`.${a.containerClass}`).eq(0).find("img, svg, canvas, picture, .swiper-zoom-target"), u.$imageWrapEl = u.$imageEl.parent(`.${a.containerClass}`), u.maxRatio = u.$imageWrapEl.attr("data-swiper-zoom") || a.maxRatio, 0 !== u.$imageWrapEl.length) ? (u.$imageEl && u.$imageEl.transition(0), p = !0) : u.$imageEl = void 0
            }

            function b(t) {
                const s = e.support,
                    a = e.params.zoom,
                    i = e.zoom;
                if (!s.gestures) {
                    if ("touchmove" !== t.type || "touchmove" === t.type && t.targetTouches.length < 2) return;
                    o = !0, u.scaleMove = v(t)
                }
                u.$imageEl && 0 !== u.$imageEl.length ? (s.gestures ? i.scale = t.scale * c : i.scale = u.scaleMove / u.scaleStart * c, i.scale > u.maxRatio && (i.scale = u.maxRatio - 1 + (i.scale - u.maxRatio + 1) ** .5), i.scale < a.minRatio && (i.scale = a.minRatio + 1 - (a.minRatio - i.scale + 1) ** .5), u.$imageEl.transform(`translate3d(0,0,0) scale(${i.scale})`)) : "gesturechange" === t.type && w(t)
            }

            function x(t) {
                const s = e.device,
                    a = e.support,
                    i = e.params.zoom,
                    r = e.zoom;
                if (!a.gestures) {
                    if (!l || !o) return;
                    if ("touchend" !== t.type || "touchend" === t.type && t.changedTouches.length < 2 && !s.android) return;
                    l = !1, o = !1
                }
                u.$imageEl && 0 !== u.$imageEl.length && (r.scale = Math.max(Math.min(r.scale, u.maxRatio), i.minRatio), u.$imageEl.transition(e.params.speed).transform(`translate3d(0,0,0) scale(${r.scale})`), c = r.scale, p = !1, 1 === r.scale && (u.$slideEl = void 0))
            }

            function y(t) {
                const s = e.zoom;
                if (!u.$imageEl || 0 === u.$imageEl.length) return;
                if (e.allowClick = !1, !m.isTouched || !u.$slideEl) return;
                m.isMoved || (m.width = u.$imageEl[0].offsetWidth, m.height = u.$imageEl[0].offsetHeight, m.startX = h(u.$imageWrapEl[0], "x") || 0, m.startY = h(u.$imageWrapEl[0], "y") || 0, u.slideWidth = u.$slideEl[0].offsetWidth, u.slideHeight = u.$slideEl[0].offsetHeight, u.$imageWrapEl.transition(0));
                const a = m.width * s.scale,
                    i = m.height * s.scale;
                if (!(a < u.slideWidth && i < u.slideHeight)) {
                    if (m.minX = Math.min(u.slideWidth / 2 - a / 2, 0), m.maxX = -m.minX, m.minY = Math.min(u.slideHeight / 2 - i / 2, 0), m.maxY = -m.minY, m.touchesCurrent.x = "touchmove" === t.type ? t.targetTouches[0].pageX : t.pageX, m.touchesCurrent.y = "touchmove" === t.type ? t.targetTouches[0].pageY : t.pageY, !m.isMoved && !p) {
                        if (e.isHorizontal() && (Math.floor(m.minX) === Math.floor(m.startX) && m.touchesCurrent.x < m.touchesStart.x || Math.floor(m.maxX) === Math.floor(m.startX) && m.touchesCurrent.x > m.touchesStart.x)) return void(m.isTouched = !1);
                        if (!e.isHorizontal() && (Math.floor(m.minY) === Math.floor(m.startY) && m.touchesCurrent.y < m.touchesStart.y || Math.floor(m.maxY) === Math.floor(m.startY) && m.touchesCurrent.y > m.touchesStart.y)) return void(m.isTouched = !1)
                    }
                    t.cancelable && t.preventDefault(), t.stopPropagation(), m.isMoved = !0, m.currentX = m.touchesCurrent.x - m.touchesStart.x + m.startX, m.currentY = m.touchesCurrent.y - m.touchesStart.y + m.startY, m.currentX < m.minX && (m.currentX = m.minX + 1 - (m.minX - m.currentX + 1) ** .8), m.currentX > m.maxX && (m.currentX = m.maxX - 1 + (m.currentX - m.maxX + 1) ** .8), m.currentY < m.minY && (m.currentY = m.minY + 1 - (m.minY - m.currentY + 1) ** .8), m.currentY > m.maxY && (m.currentY = m.maxY - 1 + (m.currentY - m.maxY + 1) ** .8), f.prevPositionX || (f.prevPositionX = m.touchesCurrent.x), f.prevPositionY || (f.prevPositionY = m.touchesCurrent.y), f.prevTime || (f.prevTime = Date.now()), f.x = (m.touchesCurrent.x - f.prevPositionX) / (Date.now() - f.prevTime) / 2, f.y = (m.touchesCurrent.y - f.prevPositionY) / (Date.now() - f.prevTime) / 2, Math.abs(m.touchesCurrent.x - f.prevPositionX) < 2 && (f.x = 0), Math.abs(m.touchesCurrent.y - f.prevPositionY) < 2 && (f.y = 0), f.prevPositionX = m.touchesCurrent.x, f.prevPositionY = m.touchesCurrent.y, f.prevTime = Date.now(), u.$imageWrapEl.transform(`translate3d(${m.currentX}px, ${m.currentY}px,0)`)
                }
            }

            function E() {
                const t = e.zoom;
                u.$slideEl && e.previousIndex !== e.activeIndex && (u.$imageEl && u.$imageEl.transform("translate3d(0,0,0) scale(1)"), u.$imageWrapEl && u.$imageWrapEl.transform("translate3d(0,0,0)"), t.scale = 1, c = 1, u.$slideEl = void 0, u.$imageEl = void 0, u.$imageWrapEl = void 0)
            }

            function T(t) {
                const s = e.zoom,
                    a = e.params.zoom;
                if (u.$slideEl || (t && t.target && (u.$slideEl = d(t.target).closest(`.${e.params.slideClass}`)), u.$slideEl || (e.params.virtual && e.params.virtual.enabled && e.virtual ? u.$slideEl = e.$wrapperEl.children(`.${e.params.slideActiveClass}`) : u.$slideEl = e.slides.eq(e.activeIndex)), u.$imageEl = u.$slideEl.find(`.${a.containerClass}`).eq(0).find("img, svg, canvas, picture, .swiper-zoom-target"), u.$imageWrapEl = u.$imageEl.parent(`.${a.containerClass}`)), !u.$imageEl || 0 === u.$imageEl.length || !u.$imageWrapEl || 0 === u.$imageWrapEl.length) return;
                let r, n, l, o, p, h, f, g, v, w, b, x, y, E, T, C, $, S;
                e.params.cssMode && (e.wrapperEl.style.overflow = "hidden", e.wrapperEl.style.touchAction = "none"), u.$slideEl.addClass(`${a.zoomedSlideClass}`), void 0 === m.touchesStart.x && t ? (r = "touchend" === t.type ? t.changedTouches[0].pageX : t.pageX, n = "touchend" === t.type ? t.changedTouches[0].pageY : t.pageY) : (r = m.touchesStart.x, n = m.touchesStart.y), s.scale = u.$imageWrapEl.attr("data-swiper-zoom") || a.maxRatio, c = u.$imageWrapEl.attr("data-swiper-zoom") || a.maxRatio, t ? ($ = u.$slideEl[0].offsetWidth, S = u.$slideEl[0].offsetHeight, p = (l = u.$slideEl.offset().left + i.scrollX) + $ / 2 - r, h = (o = u.$slideEl.offset().top + i.scrollY) + S / 2 - n, v = u.$imageEl[0].offsetWidth, w = u.$imageEl[0].offsetHeight, b = v * s.scale, x = w * s.scale, T = -(y = Math.min($ / 2 - b / 2, 0)), C = -(E = Math.min(S / 2 - x / 2, 0)), f = p * s.scale, g = h * s.scale, f < y && (f = y), f > T && (f = T), g < E && (g = E), g > C && (g = C)) : (f = 0, g = 0), u.$imageWrapEl.transition(300).transform(`translate3d(${f}px, ${g}px,0)`), u.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${s.scale})`)
            }

            function C() {
                const t = e.zoom,
                    s = e.params.zoom;
                u.$slideEl || (e.params.virtual && e.params.virtual.enabled && e.virtual ? u.$slideEl = e.$wrapperEl.children(`.${e.params.slideActiveClass}`) : u.$slideEl = e.slides.eq(e.activeIndex), u.$imageEl = u.$slideEl.find(`.${s.containerClass}`).eq(0).find("img, svg, canvas, picture, .swiper-zoom-target"), u.$imageWrapEl = u.$imageEl.parent(`.${s.containerClass}`)), u.$imageEl && 0 !== u.$imageEl.length && u.$imageWrapEl && 0 !== u.$imageWrapEl.length && (e.params.cssMode && (e.wrapperEl.style.overflow = "", e.wrapperEl.style.touchAction = ""), t.scale = 1, c = 1, u.$imageWrapEl.transition(300).transform("translate3d(0,0,0)"), u.$imageEl.transition(300).transform("translate3d(0,0,0) scale(1)"), u.$slideEl.removeClass(`${s.zoomedSlideClass}`), u.$slideEl = void 0)
            }

            function $(t) {
                const s = e.zoom;
                s.scale && 1 !== s.scale ? C() : T(t)
            }

            function S() {
                const t = e.support;
                return {
                    passiveListener: !("touchstart" !== e.touchEvents.start || !t.passiveListener || !e.params.passiveListeners) && {
                        passive: !0,
                        capture: !1
                    },
                    activeListenerWithCapture: !t.passiveListener || {
                        passive: !1,
                        capture: !0
                    }
                }
            }

            function M() {
                return `.${e.params.slideClass}`
            }

            function P(t) {
                const {
                    passiveListener: s
                } = S(), a = M();
                e.$wrapperEl[t]("gesturestart", a, w, s), e.$wrapperEl[t]("gesturechange", a, b, s), e.$wrapperEl[t]("gestureend", a, x, s)
            }

            function k() {
                n || (n = !0, P("on"))
            }

            function z() {
                n && (n = !1, P("off"))
            }

            function O() {
                const t = e.zoom;
                if (t.enabled) return;
                t.enabled = !0;
                const s = e.support,
                    {
                        passiveListener: a,
                        activeListenerWithCapture: i
                    } = S(),
                    r = M();
                s.gestures ? (e.$wrapperEl.on(e.touchEvents.start, k, a), e.$wrapperEl.on(e.touchEvents.end, z, a)) : "touchstart" === e.touchEvents.start && (e.$wrapperEl.on(e.touchEvents.start, r, w, a), e.$wrapperEl.on(e.touchEvents.move, r, b, i), e.$wrapperEl.on(e.touchEvents.end, r, x, a), e.touchEvents.cancel && e.$wrapperEl.on(e.touchEvents.cancel, r, x, a)), e.$wrapperEl.on(e.touchEvents.move, `.${e.params.zoom.containerClass}`, y, i)
            }

            function I() {
                const t = e.zoom;
                if (!t.enabled) return;
                const s = e.support;
                t.enabled = !1;
                const {
                    passiveListener: a,
                    activeListenerWithCapture: i
                } = S(), r = M();
                s.gestures ? (e.$wrapperEl.off(e.touchEvents.start, k, a), e.$wrapperEl.off(e.touchEvents.end, z, a)) : "touchstart" === e.touchEvents.start && (e.$wrapperEl.off(e.touchEvents.start, r, w, a), e.$wrapperEl.off(e.touchEvents.move, r, b, i), e.$wrapperEl.off(e.touchEvents.end, r, x, a), e.touchEvents.cancel && e.$wrapperEl.off(e.touchEvents.cancel, r, x, a)), e.$wrapperEl.off(e.touchEvents.move, `.${e.params.zoom.containerClass}`, y, i)
            }
            Object.defineProperty(e.zoom, "scale", {
                get: () => g,
                set(e) {
                    if (g !== e) {
                        const t = u.$imageEl ? u.$imageEl[0] : void 0,
                            s = u.$slideEl ? u.$slideEl[0] : void 0;
                        a("zoomChange", e, t, s)
                    }
                    g = e
                }
            }), s("init", () => {
                e.params.zoom.enabled && O()
            }), s("destroy", () => {
                I()
            }), s("touchStart", (t, s) => {
                e.zoom.enabled && function(t) {
                    const s = e.device;
                    u.$imageEl && 0 !== u.$imageEl.length && (m.isTouched || (s.android && t.cancelable && t.preventDefault(), m.isTouched = !0, m.touchesStart.x = "touchstart" === t.type ? t.targetTouches[0].pageX : t.pageX, m.touchesStart.y = "touchstart" === t.type ? t.targetTouches[0].pageY : t.pageY))
                }(s)
            }), s("touchEnd", (t, s) => {
                e.zoom.enabled && function() {
                    const t = e.zoom;
                    if (!u.$imageEl || 0 === u.$imageEl.length) return;
                    if (!m.isTouched || !m.isMoved) return m.isTouched = !1, void(m.isMoved = !1);
                    m.isTouched = !1, m.isMoved = !1;
                    let s = 300,
                        a = 300;
                    const i = f.x * s,
                        r = m.currentX + i,
                        n = f.y * a,
                        l = m.currentY + n;
                    0 !== f.x && (s = Math.abs((r - m.currentX) / f.x)), 0 !== f.y && (a = Math.abs((l - m.currentY) / f.y));
                    const o = Math.max(s, a);
                    m.currentX = r, m.currentY = l;
                    const d = m.width * t.scale,
                        c = m.height * t.scale;
                    m.minX = Math.min(u.slideWidth / 2 - d / 2, 0), m.maxX = -m.minX, m.minY = Math.min(u.slideHeight / 2 - c / 2, 0), m.maxY = -m.minY, m.currentX = Math.max(Math.min(m.currentX, m.maxX), m.minX), m.currentY = Math.max(Math.min(m.currentY, m.maxY), m.minY), u.$imageWrapEl.transition(o).transform(`translate3d(${m.currentX}px, ${m.currentY}px,0)`)
                }()
            }), s("doubleTap", (t, s) => {
                !e.animating && e.params.zoom.enabled && e.zoom.enabled && e.params.zoom.toggle && $(s)
            }), s("transitionEnd", () => {
                e.zoom.enabled && e.params.zoom.enabled && E()
            }), s("slideChange", () => {
                e.zoom.enabled && e.params.zoom.enabled && e.params.cssMode && E()
            }), Object.assign(e.zoom, {
                enable: O,
                disable: I,
                in: T,
                out: C,
                toggle: $
            })
        }, function({
            swiper: e,
            extendParams: t,
            on: s,
            emit: a
        }) {
            t({
                lazy: {
                    checkInView: !1,
                    enabled: !1,
                    loadPrevNext: !1,
                    loadPrevNextAmount: 1,
                    loadOnTransitionStart: !1,
                    scrollingElement: "",
                    elementClass: "swiper-lazy",
                    loadingClass: "swiper-lazy-loading",
                    loadedClass: "swiper-lazy-loaded",
                    preloaderClass: "swiper-lazy-preloader"
                }
            }), e.lazy = {};
            let i = !1,
                n = !1;

            function l(t, s = !0) {
                const i = e.params.lazy;
                if (void 0 === t) return;
                if (0 === e.slides.length) return;
                const r = e.virtual && e.params.virtual.enabled ? e.$wrapperEl.children(`.${e.params.slideClass}[data-swiper-slide-index="${t}"]`) : e.slides.eq(t),
                    n = r.find(`.${i.elementClass}:not(.${i.loadedClass}):not(.${i.loadingClass})`);
                !r.hasClass(i.elementClass) || r.hasClass(i.loadedClass) || r.hasClass(i.loadingClass) || n.push(r[0]), 0 !== n.length && n.each(t => {
                    const n = d(t);
                    n.addClass(i.loadingClass);
                    const o = n.attr("data-background"),
                        c = n.attr("data-src"),
                        p = n.attr("data-srcset"),
                        u = n.attr("data-sizes"),
                        h = n.parent("picture");
                    e.loadImage(n[0], c || o, p, u, !1, () => {
                        if (null != e && e && (!e || e.params) && !e.destroyed) {
                            if (o ? (n.css("background-image", `url("${o}")`), n.removeAttr("data-background")) : (p && (n.attr("srcset", p), n.removeAttr("data-srcset")), u && (n.attr("sizes", u), n.removeAttr("data-sizes")), h.length && h.children("source").each(e => {
                                    const t = d(e);
                                    t.attr("data-srcset") && (t.attr("srcset", t.attr("data-srcset")), t.removeAttr("data-srcset"))
                                }), c && (n.attr("src", c), n.removeAttr("data-src"))), n.addClass(i.loadedClass).removeClass(i.loadingClass), r.find(`.${i.preloaderClass}`).remove(), e.params.loop && s) {
                                const t = r.attr("data-swiper-slide-index");
                                r.hasClass(e.params.slideDuplicateClass) ? l(e.$wrapperEl.children(`[data-swiper-slide-index="${t}"]:not(.${e.params.slideDuplicateClass})`).index(), !1) : l(e.$wrapperEl.children(`.${e.params.slideDuplicateClass}[data-swiper-slide-index="${t}"]`).index(), !1)
                            }
                            a("lazyImageReady", r[0], n[0]), e.params.autoHeight && e.updateAutoHeight()
                        }
                    }), a("lazyImageLoad", r[0], n[0])
                })
            }

            function o() {
                const {
                    $wrapperEl: t,
                    params: s,
                    slides: a,
                    activeIndex: i
                } = e, r = e.virtual && s.virtual.enabled, o = s.lazy;
                let c = s.slidesPerView;

                function p(e) {
                    if (r) {
                        if (t.children(`.${s.slideClass}[data-swiper-slide-index="${e}"]`).length) return !0
                    } else if (a[e]) return !0;
                    return !1
                }

                function u(e) {
                    return r ? d(e).attr("data-swiper-slide-index") : d(e).index()
                }
                if ("auto" === c && (c = 0), n || (n = !0), e.params.watchSlidesProgress) t.children(`.${s.slideVisibleClass}`).each(e => {
                    l(r ? d(e).attr("data-swiper-slide-index") : d(e).index())
                });
                else if (c > 1)
                    for (let e = i; e < i + c; e += 1) p(e) && l(e);
                else l(i);
                if (o.loadPrevNext)
                    if (c > 1 || o.loadPrevNextAmount && o.loadPrevNextAmount > 1) {
                        const e = o.loadPrevNextAmount,
                            t = c,
                            s = Math.min(i + t + Math.max(e, t), a.length),
                            r = Math.max(i - Math.max(t, e), 0);
                        for (let e = i + c; e < s; e += 1) p(e) && l(e);
                        for (let e = r; e < i; e += 1) p(e) && l(e)
                    } else {
                        const e = t.children(`.${s.slideNextClass}`);
                        e.length > 0 && l(u(e));
                        const a = t.children(`.${s.slidePrevClass}`);
                        a.length > 0 && l(u(a))
                    }
            }

            function c() {
                const t = r();
                if (!e || e.destroyed) return;
                const s = e.params.lazy.scrollingElement ? d(e.params.lazy.scrollingElement) : d(t),
                    a = s[0] === t,
                    n = a ? t.innerWidth : s[0].offsetWidth,
                    l = a ? t.innerHeight : s[0].offsetHeight,
                    p = e.$el.offset(),
                    {
                        rtlTranslate: u
                    } = e;
                let h = !1;
                u && (p.left -= e.$el[0].scrollLeft);
                const m = [
                    [p.left, p.top],
                    [p.left + e.width, p.top],
                    [p.left, p.top + e.height],
                    [p.left + e.width, p.top + e.height]
                ];
                for (let e = 0; e < m.length; e += 1) {
                    const t = m[e];
                    if (t[0] >= 0 && t[0] <= n && t[1] >= 0 && t[1] <= l) {
                        if (0 === t[0] && 0 === t[1]) continue;
                        h = !0
                    }
                }
                const f = !("touchstart" !== e.touchEvents.start || !e.support.passiveListener || !e.params.passiveListeners) && {
                    passive: !0,
                    capture: !1
                };
                h ? (o(), s.off("scroll", c, f)) : i || (i = !0, s.on("scroll", c, f))
            }
            s("beforeInit", () => {
                e.params.lazy.enabled && e.params.preloadImages && (e.params.preloadImages = !1)
            }), s("init", () => {
                e.params.lazy.enabled && (e.params.lazy.checkInView ? c() : o())
            }), s("scroll", () => {
                e.params.freeMode && e.params.freeMode.enabled && !e.params.freeMode.sticky && o()
            }), s("scrollbarDragMove resize _freeModeNoMomentumRelease", () => {
                e.params.lazy.enabled && (e.params.lazy.checkInView ? c() : o())
            }), s("transitionStart", () => {
                e.params.lazy.enabled && (e.params.lazy.loadOnTransitionStart || !e.params.lazy.loadOnTransitionStart && !n) && (e.params.lazy.checkInView ? c() : o())
            }), s("transitionEnd", () => {
                e.params.lazy.enabled && !e.params.lazy.loadOnTransitionStart && (e.params.lazy.checkInView ? c() : o())
            }), s("slideChange", () => {
                const {
                    lazy: t,
                    cssMode: s,
                    watchSlidesProgress: a,
                    touchReleaseOnEdges: i,
                    resistanceRatio: r
                } = e.params;
                t.enabled && (s || a && (i || 0 === r)) && o()
            }), Object.assign(e.lazy, {
                load: o,
                loadInSlide: l
            })
        }, function({
            swiper: e,
            extendParams: t,
            on: s
        }) {
            function a(e, t) {
                const s = function() {
                    let e, t, s;
                    return (a, i) => {
                        for (t = -1, e = a.length; e - t > 1;) a[s = e + t >> 1] <= i ? t = s : e = s;
                        return e
                    }
                }();
                let a, i;
                return this.x = e, this.y = t, this.lastIndex = e.length - 1, this.interpolate = function(e) {
                    return e ? (i = s(this.x, e), a = i - 1, (e - this.x[a]) * (this.y[i] - this.y[a]) / (this.x[i] - this.x[a]) + this.y[a]) : 0
                }, this
            }

            function i() {
                e.controller.control && e.controller.spline && (e.controller.spline = void 0, delete e.controller.spline)
            }
            t({
                controller: {
                    control: void 0,
                    inverse: !1,
                    by: "slide"
                }
            }), e.controller = {
                control: void 0
            }, s("beforeInit", () => {
                e.controller.control = e.params.controller.control
            }), s("update", () => {
                i()
            }), s("resize", () => {
                i()
            }), s("observerUpdate", () => {
                i()
            }), s("setTranslate", (t, s, a) => {
                e.controller.control && e.controller.setTranslate(s, a)
            }), s("setTransition", (t, s, a) => {
                e.controller.control && e.controller.setTransition(s, a)
            }), Object.assign(e.controller, {
                setTranslate: function(t, s) {
                    const i = e.controller.control;
                    let r, n;
                    const l = e.constructor;

                    function o(t) {
                        const s = e.rtlTranslate ? -e.translate : e.translate;
                        "slide" === e.params.controller.by && (function(t) {
                            e.controller.spline || (e.controller.spline = e.params.loop ? new a(e.slidesGrid, t.slidesGrid) : new a(e.snapGrid, t.snapGrid))
                        }(t), n = -e.controller.spline.interpolate(-s)), n && "container" !== e.params.controller.by || (r = (t.maxTranslate() - t.minTranslate()) / (e.maxTranslate() - e.minTranslate()), n = (s - e.minTranslate()) * r + t.minTranslate()), e.params.controller.inverse && (n = t.maxTranslate() - n), t.updateProgress(n), t.setTranslate(n, e), t.updateActiveIndex(), t.updateSlidesClasses()
                    }
                    if (Array.isArray(i))
                        for (let e = 0; e < i.length; e += 1) i[e] !== s && i[e] instanceof l && o(i[e]);
                    else i instanceof l && s !== i && o(i)
                },
                setTransition: function(t, s) {
                    const a = e.constructor,
                        i = e.controller.control;
                    let r;

                    function n(s) {
                        s.setTransition(t, e), 0 !== t && (s.transitionStart(), s.params.autoHeight && p(() => {
                            s.updateAutoHeight()
                        }), s.$wrapperEl.transitionEnd(() => {
                            i && (s.params.loop && "slide" === e.params.controller.by && s.loopFix(), s.transitionEnd())
                        }))
                    }
                    if (Array.isArray(i))
                        for (r = 0; r < i.length; r += 1) i[r] !== s && i[r] instanceof a && n(i[r]);
                    else i instanceof a && s !== i && n(i)
                }
            })
        }, function({
            swiper: e,
            extendParams: t,
            on: s
        }) {
            t({
                a11y: {
                    enabled: !0,
                    notificationClass: "swiper-notification",
                    prevSlideMessage: "Previous slide",
                    nextSlideMessage: "Next slide",
                    firstSlideMessage: "This is the first slide",
                    lastSlideMessage: "This is the last slide",
                    paginationBulletMessage: "Go to slide {{index}}",
                    slideLabelMessage: "{{index}} / {{slidesLength}}",
                    containerMessage: null,
                    containerRoleDescriptionMessage: null,
                    itemRoleDescriptionMessage: null,
                    slideRole: "group"
                }
            });
            let a = null;

            function i(e) {
                const t = a;
                0 !== t.length && (t.html(""), t.html(e))
            }

            function r(e) {
                e.attr("tabIndex", "0")
            }

            function n(e) {
                e.attr("tabIndex", "-1")
            }

            function l(e, t) {
                e.attr("role", t)
            }

            function o(e, t) {
                e.attr("aria-roledescription", t)
            }

            function c(e, t) {
                e.attr("aria-label", t)
            }

            function p(e) {
                e.attr("aria-disabled", !0)
            }

            function u(e) {
                e.attr("aria-disabled", !1)
            }

            function h(t) {
                if (13 !== t.keyCode && 32 !== t.keyCode) return;
                const s = e.params.a11y,
                    a = d(t.target);
                e.navigation && e.navigation.$nextEl && a.is(e.navigation.$nextEl) && (e.isEnd && !e.params.loop || e.slideNext(), e.isEnd ? i(s.lastSlideMessage) : i(s.nextSlideMessage)), e.navigation && e.navigation.$prevEl && a.is(e.navigation.$prevEl) && (e.isBeginning && !e.params.loop || e.slidePrev(), e.isBeginning ? i(s.firstSlideMessage) : i(s.prevSlideMessage)), e.pagination && a.is(W(e.params.pagination.bulletClass)) && a[0].click()
            }

            function m() {
                if (e.params.loop || !e.navigation) return;
                const {
                    $nextEl: t,
                    $prevEl: s
                } = e.navigation;
                s && s.length > 0 && (e.isBeginning ? (p(s), n(s)) : (u(s), r(s))), t && t.length > 0 && (e.isEnd ? (p(t), n(t)) : (u(t), r(t)))
            }

            function f() {
                return e.pagination && e.params.pagination.clickable && e.pagination.bullets && e.pagination.bullets.length
            }
            const g = (e, t, s) => {
                r(e), "BUTTON" !== e[0].tagName && (l(e, "button"), e.on("keydown", h)), c(e, s),
                    function(e, t) {
                        e.attr("aria-controls", t)
                    }(e, t)
            };
            s("beforeInit", () => {
                a = d(`<span class="${e.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`)
            }), s("afterInit", () => {
                e.params.a11y.enabled && (function() {
                    const t = e.params.a11y;
                    e.$el.append(a);
                    const s = e.$el;
                    t.containerRoleDescriptionMessage && o(s, t.containerRoleDescriptionMessage), t.containerMessage && c(s, t.containerMessage);
                    const i = e.$wrapperEl,
                        r = i.attr("id") || `swiper-wrapper-${function(e=16){return"x".repeat(e).replace(/x/g,()=>Math.round(16*Math.random()).toString(16))}(16)}`,
                        n = e.params.autoplay && e.params.autoplay.enabled ? "off" : "polite";
                    var p;
                    p = r, i.attr("id", p),
                        function(e, t) {
                            i.attr("aria-live", t)
                        }(0, n), t.itemRoleDescriptionMessage && o(d(e.slides), t.itemRoleDescriptionMessage), l(d(e.slides), t.slideRole);
                    const u = e.params.loop ? e.slides.filter(t => !t.classList.contains(e.params.slideDuplicateClass)).length : e.slides.length;
                    let m, v;
                    e.slides.each((s, a) => {
                        const i = d(s),
                            r = e.params.loop ? parseInt(i.attr("data-swiper-slide-index"), 10) : a;
                        c(i, t.slideLabelMessage.replace(/\{\{index\}\}/, r + 1).replace(/\{\{slidesLength\}\}/, u))
                    }), e.navigation && e.navigation.$nextEl && (m = e.navigation.$nextEl), e.navigation && e.navigation.$prevEl && (v = e.navigation.$prevEl), m && m.length && g(m, r, t.nextSlideMessage), v && v.length && g(v, r, t.prevSlideMessage), f() && e.pagination.$el.on("keydown", W(e.params.pagination.bulletClass), h)
                }(), m())
            }), s("toEdge", () => {
                e.params.a11y.enabled && m()
            }), s("fromEdge", () => {
                e.params.a11y.enabled && m()
            }), s("paginationUpdate", () => {
                e.params.a11y.enabled && function() {
                    const t = e.params.a11y;
                    f() && e.pagination.bullets.each(s => {
                        const a = d(s);
                        r(a), e.params.pagination.renderBullet || (l(a, "button"), c(a, t.paginationBulletMessage.replace(/\{\{index\}\}/, a.index() + 1)))
                    })
                }()
            }), s("destroy", () => {
                e.params.a11y.enabled && function() {
                    let t, s;
                    a && a.length > 0 && a.remove(), e.navigation && e.navigation.$nextEl && (t = e.navigation.$nextEl), e.navigation && e.navigation.$prevEl && (s = e.navigation.$prevEl), t && t.off("keydown", h), s && s.off("keydown", h), f() && e.pagination.$el.off("keydown", W(e.params.pagination.bulletClass), h)
                }()
            })
        }, function({
            swiper: e,
            extendParams: t,
            on: s
        }) {
            t({
                history: {
                    enabled: !1,
                    root: "",
                    replaceState: !1,
                    key: "slides"
                }
            });
            let a = !1,
                i = {};
            const n = e => e.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, ""),
                l = e => {
                    const t = r();
                    let s;
                    const a = (s = e ? new URL(e) : t.location).pathname.slice(1).split("/").filter(e => "" !== e),
                        i = a.length;
                    return {
                        key: a[i - 2],
                        value: a[i - 1]
                    }
                },
                o = (t, s) => {
                    const i = r();
                    if (!a || !e.params.history.enabled) return;
                    let l;
                    l = e.params.url ? new URL(e.params.url) : i.location;
                    const o = e.slides.eq(s);
                    let d = n(o.attr("data-history"));
                    if (e.params.history.root.length > 0) {
                        let s = e.params.history.root;
                        "/" === s[s.length - 1] && (s = s.slice(0, s.length - 1)), d = `${s}/${t}/${d}`
                    } else l.pathname.includes(t) || (d = `${t}/${d}`);
                    const c = i.history.state;
                    c && c.value === d || (e.params.history.replaceState ? i.history.replaceState({
                        value: d
                    }, null, d) : i.history.pushState({
                        value: d
                    }, null, d))
                },
                d = (t, s, a) => {
                    if (s)
                        for (let i = 0, r = e.slides.length; i < r; i += 1) {
                            const r = e.slides.eq(i);
                            if (n(r.attr("data-history")) === s && !r.hasClass(e.params.slideDuplicateClass)) {
                                const s = r.index();
                                e.slideTo(s, t, a)
                            }
                        } else e.slideTo(0, t, a)
                },
                c = () => {
                    i = l(e.params.url), d(e.params.speed, e.paths.value, !1)
                };
            s("init", () => {
                e.params.history.enabled && (() => {
                    const t = r();
                    if (e.params.history) {
                        if (!t.history || !t.history.pushState) return e.params.history.enabled = !1, void(e.params.hashNavigation.enabled = !0);
                        a = !0, ((i = l(e.params.url)).key || i.value) && (d(0, i.value, e.params.runCallbacksOnInit), e.params.history.replaceState || t.addEventListener("popstate", c))
                    }
                })()
            }), s("destroy", () => {
                e.params.history.enabled && (() => {
                    const t = r();
                    e.params.history.replaceState || t.removeEventListener("popstate", c)
                })()
            }), s("transitionEnd _freeModeNoMomentumRelease", () => {
                a && o(e.params.history.key, e.activeIndex)
            }), s("slideChange", () => {
                a && e.params.cssMode && o(e.params.history.key, e.activeIndex)
            })
        }, function({
            swiper: e,
            extendParams: t,
            emit: s,
            on: i
        }) {
            let n = !1;
            const l = a(),
                o = r();
            t({
                hashNavigation: {
                    enabled: !1,
                    replaceState: !1,
                    watchState: !1
                }
            });
            const c = () => {
                    s("hashChange");
                    const t = l.location.hash.replace("#", "");
                    if (t !== e.slides.eq(e.activeIndex).attr("data-hash")) {
                        const s = e.$wrapperEl.children(`.${e.params.slideClass}[data-hash="${t}"]`).index();
                        if (void 0 === s) return;
                        e.slideTo(s)
                    }
                },
                p = () => {
                    if (n && e.params.hashNavigation.enabled)
                        if (e.params.hashNavigation.replaceState && o.history && o.history.replaceState) o.history.replaceState(null, null, `#${e.slides.eq(e.activeIndex).attr("data-hash")}` || ""), s("hashSet");
                        else {
                            const t = e.slides.eq(e.activeIndex),
                                a = t.attr("data-hash") || t.attr("data-history");
                            l.location.hash = a || "", s("hashSet")
                        }
                };
            i("init", () => {
                e.params.hashNavigation.enabled && (() => {
                    if (!e.params.hashNavigation.enabled || e.params.history && e.params.history.enabled) return;
                    n = !0;
                    const t = l.location.hash.replace("#", "");
                    if (t) {
                        const s = 0;
                        for (let a = 0, i = e.slides.length; a < i; a += 1) {
                            const i = e.slides.eq(a);
                            if ((i.attr("data-hash") || i.attr("data-history")) === t && !i.hasClass(e.params.slideDuplicateClass)) {
                                const t = i.index();
                                e.slideTo(t, s, e.params.runCallbacksOnInit, !0)
                            }
                        }
                    }
                    e.params.hashNavigation.watchState && d(o).on("hashchange", c)
                })()
            }), i("destroy", () => {
                e.params.hashNavigation.enabled && e.params.hashNavigation.watchState && d(o).off("hashchange", c)
            }), i("transitionEnd _freeModeNoMomentumRelease", () => {
                n && p()
            }), i("slideChange", () => {
                n && e.params.cssMode && p()
            })
        }, function({
            swiper: e,
            extendParams: t,
            on: s,
            emit: i
        }) {
            let r;

            function n() {
                const t = e.slides.eq(e.activeIndex);
                let s = e.params.autoplay.delay;
                t.attr("data-swiper-autoplay") && (s = t.attr("data-swiper-autoplay") || e.params.autoplay.delay), clearTimeout(r), r = p(() => {
                    let t;
                    e.params.autoplay.reverseDirection ? e.params.loop ? (e.loopFix(), t = e.slidePrev(e.params.speed, !0, !0), i("autoplay")) : e.isBeginning ? e.params.autoplay.stopOnLastSlide ? o() : (t = e.slideTo(e.slides.length - 1, e.params.speed, !0, !0), i("autoplay")) : (t = e.slidePrev(e.params.speed, !0, !0), i("autoplay")) : e.params.loop ? (e.loopFix(), t = e.slideNext(e.params.speed, !0, !0), i("autoplay")) : e.isEnd ? e.params.autoplay.stopOnLastSlide ? o() : (t = e.slideTo(0, e.params.speed, !0, !0), i("autoplay")) : (t = e.slideNext(e.params.speed, !0, !0), i("autoplay")), (e.params.cssMode && e.autoplay.running || !1 === t) && n()
                }, s)
            }

            function l() {
                return void 0 === r && !e.autoplay.running && (e.autoplay.running = !0, i("autoplayStart"), n(), !0)
            }

            function o() {
                return !!e.autoplay.running && void 0 !== r && (r && (clearTimeout(r), r = void 0), e.autoplay.running = !1, i("autoplayStop"), !0)
            }

            function d(t) {
                e.autoplay.running && (e.autoplay.paused || (r && clearTimeout(r), e.autoplay.paused = !0, 0 !== t && e.params.autoplay.waitForTransition ? ["transitionend", "webkitTransitionEnd"].forEach(t => {
                    e.$wrapperEl[0].addEventListener(t, u)
                }) : (e.autoplay.paused = !1, n())))
            }

            function c() {
                const t = a();
                "hidden" === t.visibilityState && e.autoplay.running && d(), "visible" === t.visibilityState && e.autoplay.paused && (n(), e.autoplay.paused = !1)
            }

            function u(t) {
                e && !e.destroyed && e.$wrapperEl && t.target === e.$wrapperEl[0] && (["transitionend", "webkitTransitionEnd"].forEach(t => {
                    e.$wrapperEl[0].removeEventListener(t, u)
                }), e.autoplay.paused = !1, e.autoplay.running ? n() : o())
            }

            function h() {
                e.params.autoplay.disableOnInteraction ? o() : d(), ["transitionend", "webkitTransitionEnd"].forEach(t => {
                    e.$wrapperEl[0].removeEventListener(t, u)
                })
            }

            function m() {
                e.params.autoplay.disableOnInteraction || (e.autoplay.paused = !1, n())
            }
            e.autoplay = {
                running: !1,
                paused: !1
            }, t({
                autoplay: {
                    enabled: !1,
                    delay: 3e3,
                    waitForTransition: !0,
                    disableOnInteraction: !0,
                    stopOnLastSlide: !1,
                    reverseDirection: !1,
                    pauseOnMouseEnter: !1
                }
            }), s("init", () => {
                e.params.autoplay.enabled && (l(), a().addEventListener("visibilitychange", c), e.params.autoplay.pauseOnMouseEnter && (e.$el.on("mouseenter", h), e.$el.on("mouseleave", m)))
            }), s("beforeTransitionStart", (t, s, a) => {
                e.autoplay.running && (a || !e.params.autoplay.disableOnInteraction ? e.autoplay.pause(s) : o())
            }), s("sliderFirstMove", () => {
                e.autoplay.running && (e.params.autoplay.disableOnInteraction ? o() : d())
            }), s("touchEnd", () => {
                e.params.cssMode && e.autoplay.paused && !e.params.autoplay.disableOnInteraction && n()
            }), s("destroy", () => {
                e.$el.off("mouseenter", h), e.$el.off("mouseleave", m), e.autoplay.running && o(), a().removeEventListener("visibilitychange", c)
            }), Object.assign(e.autoplay, {
                pause: d,
                run: n,
                start: l,
                stop: o
            })
        }, function({
            swiper: e,
            extendParams: t,
            on: s
        }) {
            t({
                thumbs: {
                    swiper: null,
                    multipleActiveThumbs: !0,
                    autoScrollOffset: 0,
                    slideThumbActiveClass: "swiper-slide-thumb-active",
                    thumbsContainerClass: "swiper-thumbs"
                }
            });
            let a = !1,
                i = !1;

            function r() {
                const t = e.thumbs.swiper;
                if (!t) return;
                const s = t.clickedIndex,
                    a = t.clickedSlide;
                if (a && d(a).hasClass(e.params.thumbs.slideThumbActiveClass)) return;
                if (null == s) return;
                let i;
                if (i = t.params.loop ? parseInt(d(t.clickedSlide).attr("data-swiper-slide-index"), 10) : s, e.params.loop) {
                    let t = e.activeIndex;
                    e.slides.eq(t).hasClass(e.params.slideDuplicateClass) && (e.loopFix(), e._clientLeft = e.$wrapperEl[0].clientLeft, t = e.activeIndex);
                    const s = e.slides.eq(t).prevAll(`[data-swiper-slide-index="${i}"]`).eq(0).index(),
                        a = e.slides.eq(t).nextAll(`[data-swiper-slide-index="${i}"]`).eq(0).index();
                    i = void 0 === s ? a : void 0 === a ? s : a - t < t - s ? a : s
                }
                e.slideTo(i)
            }

            function n() {
                const {
                    thumbs: t
                } = e.params;
                if (a) return !1;
                a = !0;
                const s = e.constructor;
                if (t.swiper instanceof s) e.thumbs.swiper = t.swiper, Object.assign(e.thumbs.swiper.originalParams, {
                    watchSlidesProgress: !0,
                    slideToClickedSlide: !1
                }), Object.assign(e.thumbs.swiper.params, {
                    watchSlidesProgress: !0,
                    slideToClickedSlide: !1
                });
                else if (m(t.swiper)) {
                    const a = Object.assign({}, t.swiper);
                    Object.assign(a, {
                        watchSlidesProgress: !0,
                        slideToClickedSlide: !1
                    }), e.thumbs.swiper = new s(a), i = !0
                }
                return e.thumbs.swiper.$el.addClass(e.params.thumbs.thumbsContainerClass), e.thumbs.swiper.on("tap", r), !0
            }

            function l(t) {
                const s = e.thumbs.swiper;
                if (!s) return;
                const a = "auto" === s.params.slidesPerView ? s.slidesPerViewDynamic() : s.params.slidesPerView,
                    i = e.params.thumbs.autoScrollOffset,
                    r = i && !s.params.loop;
                if (e.realIndex !== s.realIndex || r) {
                    let n, l, o = s.activeIndex;
                    if (s.params.loop) {
                        s.slides.eq(o).hasClass(s.params.slideDuplicateClass) && (s.loopFix(), s._clientLeft = s.$wrapperEl[0].clientLeft, o = s.activeIndex);
                        const t = s.slides.eq(o).prevAll(`[data-swiper-slide-index="${e.realIndex}"]`).eq(0).index(),
                            a = s.slides.eq(o).nextAll(`[data-swiper-slide-index="${e.realIndex}"]`).eq(0).index();
                        n = void 0 === t ? a : void 0 === a ? t : a - o == o - t ? s.params.slidesPerGroup > 1 ? a : o : a - o < o - t ? a : t, l = e.activeIndex > e.previousIndex ? "next" : "prev"
                    } else l = (n = e.realIndex) > e.previousIndex ? "next" : "prev";
                    r && (n += "next" === l ? i : -1 * i), s.visibleSlidesIndexes && s.visibleSlidesIndexes.indexOf(n) < 0 && (s.params.centeredSlides ? n = n > o ? n - Math.floor(a / 2) + 1 : n + Math.floor(a / 2) - 1 : n > o && s.params.slidesPerGroup, s.slideTo(n, t ? 0 : void 0))
                }
                let n = 1;
                const l = e.params.thumbs.slideThumbActiveClass;
                if (e.params.slidesPerView > 1 && !e.params.centeredSlides && (n = e.params.slidesPerView), e.params.thumbs.multipleActiveThumbs || (n = 1), n = Math.floor(n), s.slides.removeClass(l), s.params.loop || s.params.virtual && s.params.virtual.enabled)
                    for (let t = 0; t < n; t += 1) s.$wrapperEl.children(`[data-swiper-slide-index="${e.realIndex+t}"]`).addClass(l);
                else
                    for (let t = 0; t < n; t += 1) s.slides.eq(e.realIndex + t).addClass(l)
            }
            e.thumbs = {
                swiper: null
            }, s("beforeInit", () => {
                const {
                    thumbs: t
                } = e.params;
                t && t.swiper && (n(), l(!0))
            }), s("slideChange update resize observerUpdate", () => {
                e.thumbs.swiper && l()
            }), s("setTransition", (t, s) => {
                const a = e.thumbs.swiper;
                a && a.setTransition(s)
            }), s("beforeDestroy", () => {
                const t = e.thumbs.swiper;
                t && i && t && t.destroy()
            }), Object.assign(e.thumbs, {
                init: n,
                update: l
            })
        }, function({
            swiper: e,
            extendParams: t,
            emit: s,
            once: a
        }) {
            t({
                freeMode: {
                    enabled: !1,
                    momentum: !0,
                    momentumRatio: 1,
                    momentumBounce: !0,
                    momentumBounceRatio: 1,
                    momentumVelocityRatio: 1,
                    sticky: !1,
                    minimumVelocity: .02
                }
            }), Object.assign(e, {
                freeMode: {
                    onTouchMove: function() {
                        const {
                            touchEventsData: t,
                            touches: s
                        } = e;
                        0 === t.velocities.length && t.velocities.push({
                            position: s[e.isHorizontal() ? "startX" : "startY"],
                            time: t.touchStartTime
                        }), t.velocities.push({
                            position: s[e.isHorizontal() ? "currentX" : "currentY"],
                            time: u()
                        })
                    },
                    onTouchEnd: function({
                        currentPos: t
                    }) {
                        const {
                            params: i,
                            $wrapperEl: r,
                            rtlTranslate: n,
                            snapGrid: l,
                            touchEventsData: o
                        } = e, d = u() - o.touchStartTime;
                        if (t < -e.minTranslate()) e.slideTo(e.activeIndex);
                        else if (t > -e.maxTranslate()) e.slides.length < l.length ? e.slideTo(l.length - 1) : e.slideTo(e.slides.length - 1);
                        else {
                            if (i.freeMode.momentum) {
                                if (o.velocities.length > 1) {
                                    const t = o.velocities.pop(),
                                        s = o.velocities.pop(),
                                        a = t.position - s.position,
                                        r = t.time - s.time;
                                    e.velocity = a / r, e.velocity /= 2, Math.abs(e.velocity) < i.freeMode.minimumVelocity && (e.velocity = 0), (r > 150 || u() - t.time > 300) && (e.velocity = 0)
                                } else e.velocity = 0;
                                e.velocity *= i.freeMode.momentumVelocityRatio, o.velocities.length = 0;
                                let t = 1e3 * i.freeMode.momentumRatio;
                                const d = e.velocity * t;
                                let c = e.translate + d;
                                n && (c = -c);
                                let p, h = !1;
                                const m = 20 * Math.abs(e.velocity) * i.freeMode.momentumBounceRatio;
                                let f;
                                if (c < e.maxTranslate()) i.freeMode.momentumBounce ? (c + e.maxTranslate() < -m && (c = e.maxTranslate() - m), p = e.maxTranslate(), h = !0, o.allowMomentumBounce = !0) : c = e.maxTranslate(), i.loop && i.centeredSlides && (f = !0);
                                else if (c > e.minTranslate()) i.freeMode.momentumBounce ? (c - e.minTranslate() > m && (c = e.minTranslate() + m), p = e.minTranslate(), h = !0, o.allowMomentumBounce = !0) : c = e.minTranslate(), i.loop && i.centeredSlides && (f = !0);
                                else if (i.freeMode.sticky) {
                                    let t;
                                    for (let e = 0; e < l.length; e += 1)
                                        if (l[e] > -c) {
                                            t = e;
                                            break
                                        } c = -(c = Math.abs(l[t] - c) < Math.abs(l[t - 1] - c) || "next" === e.swipeDirection ? l[t] : l[t - 1])
                                }
                                if (f && a("transitionEnd", () => {
                                        e.loopFix()
                                    }), 0 !== e.velocity) {
                                    if (t = n ? Math.abs((-c - e.translate) / e.velocity) : Math.abs((c - e.translate) / e.velocity), i.freeMode.sticky) {
                                        const s = Math.abs((n ? -c : c) - e.translate),
                                            a = e.slidesSizesGrid[e.activeIndex];
                                        t = s < a ? i.speed : s < 2 * a ? 1.5 * i.speed : 2.5 * i.speed
                                    }
                                } else if (i.freeMode.sticky) return void e.slideToClosest();
                                i.freeMode.momentumBounce && h ? (e.updateProgress(p), e.setTransition(t), e.setTranslate(c), e.transitionStart(!0, e.swipeDirection), e.animating = !0, r.transitionEnd(() => {
                                    e && !e.destroyed && o.allowMomentumBounce && (s("momentumBounce"), e.setTransition(i.speed), setTimeout(() => {
                                        e.setTranslate(p), r.transitionEnd(() => {
                                            e && !e.destroyed && e.transitionEnd()
                                        })
                                    }, 0))
                                })) : e.velocity ? (s("_freeModeNoMomentumRelease"), e.updateProgress(c), e.setTransition(t), e.setTranslate(c), e.transitionStart(!0, e.swipeDirection), e.animating || (e.animating = !0, r.transitionEnd(() => {
                                    e && !e.destroyed && e.transitionEnd()
                                }))) : e.updateProgress(c), e.updateActiveIndex(), e.updateSlidesClasses()
                            } else {
                                if (i.freeMode.sticky) return void e.slideToClosest();
                                i.freeMode && s("_freeModeNoMomentumRelease")
                            }(!i.freeMode.momentum || d >= i.longSwipesMs) && (e.updateProgress(), e.updateActiveIndex(), e.updateSlidesClasses())
                        }
                    }
                }
            })
        }, function({
            swiper: e,
            extendParams: t
        }) {
            let s, a, i;
            t({
                grid: {
                    rows: 1,
                    fill: "column"
                }
            }), e.grid = {
                initSlides: t => {
                    const {
                        slidesPerView: r
                    } = e.params, {
                        rows: n,
                        fill: l
                    } = e.params.grid;
                    a = s / n, i = Math.floor(t / n), s = Math.floor(t / n) === t / n ? t : Math.ceil(t / n) * n, "auto" !== r && "row" === l && (s = Math.max(s, r * n))
                },
                updateSlide: (t, r, n, l) => {
                    const {
                        slidesPerGroup: o,
                        spaceBetween: d
                    } = e.params, {
                        rows: c,
                        fill: p
                    } = e.params.grid;
                    let u, h, m;
                    if ("row" === p && o > 1) {
                        const e = Math.floor(t / (o * c)),
                            a = t - c * o * e,
                            i = 0 === e ? o : Math.min(Math.ceil((n - e * c * o) / c), o);
                        u = (h = a - (m = Math.floor(a / i)) * i + e * o) + m * s / c, r.css({
                            "-webkit-order": u,
                            order: u
                        })
                    } else "column" === p ? (m = t - (h = Math.floor(t / c)) * c, (h > i || h === i && m === c - 1) && ((m += 1) >= c && (m = 0, h += 1))) : h = t - (m = Math.floor(t / a)) * a;
                    r.css(l("margin-top"), 0 !== m ? d && `${d}px` : "")
                },
                updateWrapperSize: (t, a, i) => {
                    const {
                        spaceBetween: r,
                        centeredSlides: n,
                        roundLengths: l
                    } = e.params, {
                        rows: o
                    } = e.params.grid;
                    if (e.virtualSize = (t + r) * s, e.virtualSize = Math.ceil(e.virtualSize / o) - r, e.$wrapperEl.css({
                            [i("width")]: `${e.virtualSize+r}px`
                        }), n) {
                        a.splice(0, a.length);
                        const t = [];
                        for (let s = 0; s < a.length; s += 1) {
                            let i = a[s];
                            l && (i = Math.floor(i)), a[s] < e.virtualSize + a[0] && t.push(i)
                        }
                        a.push(...t)
                    }
                }
            }
        }, function({
            swiper: e
        }) {
            Object.assign(e, {
                appendSlide: function(e) {
                    const t = this,
                        {
                            $wrapperEl: s,
                            params: a
                        } = t;
                    if (a.loop && t.loopDestroy(), "object" == typeof e && "length" in e)
                        for (let t = 0; t < e.length; t += 1) e[t] && s.append(e[t]);
                    else s.append(e);
                    a.loop && t.loopCreate(), a.observer || t.update()
                }.bind(e),
                prependSlide: function(e) {
                    const t = this,
                        {
                            params: s,
                            $wrapperEl: a,
                            activeIndex: i
                        } = t;
                    s.loop && t.loopDestroy();
                    let r = i + 1;
                    if ("object" == typeof e && "length" in e) {
                        for (let t = 0; t < e.length; t += 1) e[t] && a.prepend(e[t]);
                        r = i + e.length
                    } else a.prepend(e);
                    s.loop && t.loopCreate(), s.observer || t.update(), t.slideTo(r, 0, !1)
                }.bind(e),
                addSlide: function(e, t) {
                    const s = this,
                        {
                            $wrapperEl: a,
                            params: i,
                            activeIndex: r
                        } = s;
                    let n = r;
                    i.loop && (n -= s.loopedSlides, s.loopDestroy(), s.slides = a.children(`.${i.slideClass}`));
                    const l = s.slides.length;
                    if (e <= 0) return void s.prependSlide(t);
                    if (e >= l) return void s.appendSlide(t);
                    let o = n > e ? n + 1 : n;
                    const d = [];
                    for (let t = l - 1; t >= e; t -= 1) {
                        const e = s.slides.eq(t);
                        e.remove(), d.unshift(e)
                    }
                    if ("object" == typeof t && "length" in t) {
                        for (let e = 0; e < t.length; e += 1) t[e] && a.append(t[e]);
                        o = n > e ? n + t.length : n
                    } else a.append(t);
                    for (let e = 0; e < d.length; e += 1) a.append(d[e]);
                    i.loop && s.loopCreate(), i.observer || s.update(), i.loop ? s.slideTo(o + s.loopedSlides, 0, !1) : s.slideTo(o, 0, !1)
                }.bind(e),
                removeSlide: function(e) {
                    const t = this,
                        {
                            params: s,
                            $wrapperEl: a,
                            activeIndex: i
                        } = t;
                    let r = i;
                    s.loop && (r -= t.loopedSlides, t.loopDestroy(), t.slides = a.children(`.${s.slideClass}`));
                    let n, l = r;
                    if ("object" == typeof e && "length" in e) {
                        for (let s = 0; s < e.length; s += 1) n = e[s], t.slides[n] && t.slides.eq(n).remove(), n < l && (l -= 1);
                        l = Math.max(l, 0)
                    } else n = e, t.slides[n] && t.slides.eq(n).remove(), n < l && (l -= 1), l = Math.max(l, 0);
                    s.loop && t.loopCreate(), s.observer || t.update(), s.loop ? t.slideTo(l + t.loopedSlides, 0, !1) : t.slideTo(l, 0, !1)
                }.bind(e),
                removeAllSlides: function() {
                    const e = this,
                        t = [];
                    for (let s = 0; s < e.slides.length; s += 1) t.push(s);
                    e.removeSlide(t)
                }.bind(e)
            })
        }, function({
            swiper: e,
            extendParams: t,
            on: s
        }) {
            t({
                fadeEffect: {
                    crossFade: !1,
                    transformEl: null
                }
            }), F({
                effect: "fade",
                swiper: e,
                on: s,
                setTranslate: () => {
                    const {
                        slides: t
                    } = e, s = e.params.fadeEffect;
                    for (let a = 0; a < t.length; a += 1) {
                        const t = e.slides.eq(a);
                        let i = -t[0].swiperSlideOffset;
                        e.params.virtualTranslate || (i -= e.translate);
                        let r = 0;
                        e.isHorizontal() || (r = i, i = 0);
                        const n = e.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(t[0].progress), 0) : 1 + Math.min(Math.max(t[0].progress, -1), 0);
                        U(s, t).css({
                            opacity: n
                        }).transform(`translate3d(${i}px, ${r}px, 0px)`)
                    }
                },
                setTransition: t => {
                    const {
                        transformEl: s
                    } = e.params.fadeEffect;
                    (s ? e.slides.find(s) : e.slides).transition(t), K({
                        swiper: e,
                        duration: t,
                        transformEl: s,
                        allSlides: !0
                    })
                },
                overwriteParams: () => ({
                    slidesPerView: 1,
                    slidesPerGroup: 1,
                    watchSlidesProgress: !0,
                    spaceBetween: 0,
                    virtualTranslate: !e.params.cssMode
                })
            })
        }, function({
            swiper: e,
            extendParams: t,
            on: s
        }) {
            t({
                cubeEffect: {
                    slideShadows: !0,
                    shadow: !0,
                    shadowOffset: 20,
                    shadowScale: .94
                }
            }), F({
                effect: "cube",
                swiper: e,
                on: s,
                setTranslate: () => {
                    const {
                        $el: t,
                        $wrapperEl: s,
                        slides: a,
                        width: i,
                        height: r,
                        rtlTranslate: n,
                        size: l,
                        browser: o
                    } = e, c = e.params.cubeEffect, p = e.isHorizontal(), u = e.virtual && e.params.virtual.enabled;
                    let h, m = 0;
                    c.shadow && (p ? (0 === (h = s.find(".swiper-cube-shadow")).length && (h = d('<div class="swiper-cube-shadow"></div>'), s.append(h)), h.css({
                        height: `${i}px`
                    })) : 0 === (h = t.find(".swiper-cube-shadow")).length && (h = d('<div class="swiper-cube-shadow"></div>'), t.append(h)));
                    for (let e = 0; e < a.length; e += 1) {
                        const t = a.eq(e);
                        let s = e;
                        u && (s = parseInt(t.attr("data-swiper-slide-index"), 10));
                        let i = 90 * s,
                            r = Math.floor(i / 360);
                        n && (i = -i, r = Math.floor(-i / 360));
                        const o = Math.max(Math.min(t[0].progress, 1), -1);
                        let h = 0,
                            f = 0,
                            g = 0;
                        s % 4 == 0 ? (h = 4 * -r * l, g = 0) : (s - 1) % 4 == 0 ? (h = 0, g = 4 * -r * l) : (s - 2) % 4 == 0 ? (h = l + 4 * r * l, g = l) : (s - 3) % 4 == 0 && (h = -l, g = 3 * l + 4 * l * r), n && (h = -h), p || (f = h, h = 0);
                        const v = `rotateX(${p?0:-i}deg) rotateY(${p?i:0}deg) translate3d(${h}px, ${f}px, ${g}px)`;
                        if (o <= 1 && o > -1 && (m = 90 * s + 90 * o, n && (m = 90 * -s - 90 * o)), t.transform(v), c.slideShadows) {
                            let e = p ? t.find(".swiper-slide-shadow-left") : t.find(".swiper-slide-shadow-top"),
                                s = p ? t.find(".swiper-slide-shadow-right") : t.find(".swiper-slide-shadow-bottom");
                            0 === e.length && (e = d(`<div class="swiper-slide-shadow-${p?"left":"top"}"></div>`), t.append(e)), 0 === s.length && (s = d(`<div class="swiper-slide-shadow-${p?"right":"bottom"}"></div>`), t.append(s)), e.length && (e[0].style.opacity = Math.max(-o, 0)), s.length && (s[0].style.opacity = Math.max(o, 0))
                        }
                    }
                    if (s.css({
                            "-webkit-transform-origin": `50% 50% -${l/2}px`,
                            "transform-origin": `50% 50% -${l/2}px`
                        }), c.shadow)
                        if (p) h.transform(`translate3d(0px, ${i/2+c.shadowOffset}px, ${-i/2}px) rotateX(90deg) rotateZ(0deg) scale(${c.shadowScale})`);
                        else {
                            const e = Math.abs(m) - 90 * Math.floor(Math.abs(m) / 90),
                                t = 1.5 - (Math.sin(2 * e * Math.PI / 360) / 2 + Math.cos(2 * e * Math.PI / 360) / 2),
                                s = c.shadowScale,
                                a = c.shadowScale / t,
                                i = c.shadowOffset;
                            h.transform(`scale3d(${s}, 1, ${a}) translate3d(0px, ${r/2+i}px, ${-r/2/a}px) rotateX(-90deg)`)
                        } const f = o.isSafari || o.isWebView ? -l / 2 : 0;
                    s.transform(`translate3d(0px,0,${f}px) rotateX(${e.isHorizontal()?0:m}deg) rotateY(${e.isHorizontal()?-m:0}deg)`)
                },
                setTransition: t => {
                    const {
                        $el: s,
                        slides: a
                    } = e;
                    a.transition(t).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(t), e.params.cubeEffect.shadow && !e.isHorizontal() && s.find(".swiper-cube-shadow").transition(t)
                },
                perspective: () => !0,
                overwriteParams: () => ({
                    slidesPerView: 1,
                    slidesPerGroup: 1,
                    watchSlidesProgress: !0,
                    resistanceRatio: 0,
                    spaceBetween: 0,
                    centeredSlides: !1,
                    virtualTranslate: !0
                })
            })
        }, function({
            swiper: e,
            extendParams: t,
            on: s
        }) {
            t({
                flipEffect: {
                    slideShadows: !0,
                    limitRotation: !0,
                    transformEl: null
                }
            }), F({
                effect: "flip",
                swiper: e,
                on: s,
                setTranslate: () => {
                    const {
                        slides: t,
                        rtlTranslate: s
                    } = e, a = e.params.flipEffect;
                    for (let i = 0; i < t.length; i += 1) {
                        const r = t.eq(i);
                        let n = r[0].progress;
                        e.params.flipEffect.limitRotation && (n = Math.max(Math.min(r[0].progress, 1), -1));
                        const l = r[0].swiperSlideOffset;
                        let o = -180 * n,
                            d = 0,
                            c = e.params.cssMode ? -l - e.translate : -l,
                            p = 0;
                        if (e.isHorizontal() ? s && (o = -o) : (p = c, c = 0, d = -o, o = 0), r[0].style.zIndex = -Math.abs(Math.round(n)) + t.length, a.slideShadows) {
                            let t = e.isHorizontal() ? r.find(".swiper-slide-shadow-left") : r.find(".swiper-slide-shadow-top"),
                                s = e.isHorizontal() ? r.find(".swiper-slide-shadow-right") : r.find(".swiper-slide-shadow-bottom");
                            0 === t.length && (t = Z(a, r, e.isHorizontal() ? "left" : "top")), 0 === s.length && (s = Z(a, r, e.isHorizontal() ? "right" : "bottom")), t.length && (t[0].style.opacity = Math.max(-n, 0)), s.length && (s[0].style.opacity = Math.max(n, 0))
                        }
                        const u = `translate3d(${c}px, ${p}px, 0px) rotateX(${d}deg) rotateY(${o}deg)`;
                        U(a, r).transform(u)
                    }
                },
                setTransition: t => {
                    const {
                        transformEl: s
                    } = e.params.flipEffect;
                    (s ? e.slides.find(s) : e.slides).transition(t).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(t), K({
                        swiper: e,
                        duration: t,
                        transformEl: s
                    })
                },
                perspective: () => !0,
                overwriteParams: () => ({
                    slidesPerView: 1,
                    slidesPerGroup: 1,
                    watchSlidesProgress: !0,
                    spaceBetween: 0,
                    virtualTranslate: !e.params.cssMode
                })
            })
        }, function({
            swiper: e,
            extendParams: t,
            on: s
        }) {
            t({
                coverflowEffect: {
                    rotate: 50,
                    stretch: 0,
                    depth: 100,
                    scale: 1,
                    modifier: 1,
                    slideShadows: !0,
                    transformEl: null
                }
            }), F({
                effect: "coverflow",
                swiper: e,
                on: s,
                setTranslate: () => {
                    const {
                        width: t,
                        height: s,
                        slides: a,
                        slidesSizesGrid: i
                    } = e, r = e.params.coverflowEffect, n = e.isHorizontal(), l = e.translate, o = n ? t / 2 - l : s / 2 - l, d = n ? r.rotate : -r.rotate, c = r.depth;
                    for (let e = 0, t = a.length; e < t; e += 1) {
                        const t = a.eq(e),
                            s = i[e],
                            l = (o - t[0].swiperSlideOffset - s / 2) / s * r.modifier;
                        let p = n ? d * l : 0,
                            u = n ? 0 : d * l,
                            h = -c * Math.abs(l),
                            m = r.stretch;
                        "string" == typeof m && -1 !== m.indexOf("%") && (m = parseFloat(r.stretch) / 100 * s);
                        let f = n ? 0 : m * l,
                            g = n ? m * l : 0,
                            v = 1 - (1 - r.scale) * Math.abs(l);
                        Math.abs(g) < .001 && (g = 0), Math.abs(f) < .001 && (f = 0), Math.abs(h) < .001 && (h = 0), Math.abs(p) < .001 && (p = 0), Math.abs(u) < .001 && (u = 0), Math.abs(v) < .001 && (v = 0);
                        const w = `translate3d(${g}px,${f}px,${h}px)  rotateX(${u}deg) rotateY(${p}deg) scale(${v})`;
                        if (U(r, t).transform(w), t[0].style.zIndex = 1 - Math.abs(Math.round(l)), r.slideShadows) {
                            let e = n ? t.find(".swiper-slide-shadow-left") : t.find(".swiper-slide-shadow-top"),
                                s = n ? t.find(".swiper-slide-shadow-right") : t.find(".swiper-slide-shadow-bottom");
                            0 === e.length && (e = Z(r, t, n ? "left" : "top")), 0 === s.length && (s = Z(r, t, n ? "right" : "bottom")), e.length && (e[0].style.opacity = l > 0 ? l : 0), s.length && (s[0].style.opacity = -l > 0 ? -l : 0)
                        }
                    }
                },
                setTransition: t => {
                    const {
                        transformEl: s
                    } = e.params.coverflowEffect;
                    (s ? e.slides.find(s) : e.slides).transition(t).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(t)
                },
                perspective: () => !0,
                overwriteParams: () => ({
                    watchSlidesProgress: !0
                })
            })
        }, function({
            swiper: e,
            extendParams: t,
            on: s
        }) {
            t({
                creativeEffect: {
                    transformEl: null,
                    limitProgress: 1,
                    shadowPerProgress: !1,
                    progressMultiplier: 1,
                    perspective: !0,
                    prev: {
                        translate: [0, 0, 0],
                        rotate: [0, 0, 0],
                        opacity: 1,
                        scale: 1
                    },
                    next: {
                        translate: [0, 0, 0],
                        rotate: [0, 0, 0],
                        opacity: 1,
                        scale: 1
                    }
                }
            });
            const a = e => "string" == typeof e ? e : `${e}px`;
            F({
                effect: "creative",
                swiper: e,
                on: s,
                setTranslate: () => {
                    const {
                        slides: t
                    } = e, s = e.params.creativeEffect, {
                        progressMultiplier: i
                    } = s;
                    for (let r = 0; r < t.length; r += 1) {
                        const n = t.eq(r),
                            l = n[0].progress,
                            o = Math.min(Math.max(n[0].progress, -s.limitProgress), s.limitProgress),
                            d = n[0].swiperSlideOffset,
                            c = [e.params.cssMode ? -d - e.translate : -d, 0, 0],
                            p = [0, 0, 0];
                        let u = !1;
                        e.isHorizontal() || (c[1] = c[0], c[0] = 0);
                        let h = {
                            translate: [0, 0, 0],
                            rotate: [0, 0, 0],
                            scale: 1,
                            opacity: 1
                        };
                        o < 0 ? (h = s.next, u = !0) : o > 0 && (h = s.prev, u = !0), c.forEach((e, t) => {
                            c[t] = `calc(${e}px + (${a(h.translate[t])} * ${Math.abs(o*i)}))`
                        }), p.forEach((e, t) => {
                            p[t] = h.rotate[t] * Math.abs(o * i)
                        }), n[0].style.zIndex = -Math.abs(Math.round(l)) + t.length;
                        const m = c.join(", "),
                            f = `rotateX(${p[0]}deg) rotateY(${p[1]}deg) rotateZ(${p[2]}deg)`,
                            g = o < 0 ? `scale(${1+(1-h.scale)*o*i})` : `scale(${1-(1-h.scale)*o*i})`,
                            v = o < 0 ? 1 + (1 - h.opacity) * o * i : 1 - (1 - h.opacity) * o * i,
                            w = `translate3d(${m}) ${f} ${g}`;
                        if (u && h.shadow || !u) {
                            let e = n.children(".swiper-slide-shadow");
                            if (0 === e.length && h.shadow && (e = Z(s, n)), e.length) {
                                const t = s.shadowPerProgress ? o * (1 / s.limitProgress) : o;
                                e[0].style.opacity = Math.min(Math.max(Math.abs(t), 0), 1)
                            }
                        }
                        const b = U(s, n);
                        b.transform(w).css({
                            opacity: v
                        }), h.origin && b.css("transform-origin", h.origin)
                    }
                },
                setTransition: t => {
                    const {
                        transformEl: s
                    } = e.params.creativeEffect;
                    (s ? e.slides.find(s) : e.slides).transition(t).find(".swiper-slide-shadow").transition(t), K({
                        swiper: e,
                        duration: t,
                        transformEl: s,
                        allSlides: !0
                    })
                },
                perspective: () => e.params.creativeEffect.perspective,
                overwriteParams: () => ({
                    watchSlidesProgress: !0,
                    virtualTranslate: !e.params.cssMode
                })
            })
        }, function({
            swiper: e,
            extendParams: t,
            on: s
        }) {
            t({
                cardsEffect: {
                    slideShadows: !0,
                    transformEl: null
                }
            }), F({
                effect: "cards",
                swiper: e,
                on: s,
                setTranslate: () => {
                    const {
                        slides: t,
                        activeIndex: s
                    } = e, a = e.params.cardsEffect, {
                        startTranslate: i,
                        isTouched: r
                    } = e.touchEventsData, n = e.translate;
                    for (let l = 0; l < t.length; l += 1) {
                        const o = t.eq(l),
                            d = o[0].progress,
                            c = Math.min(Math.max(d, -4), 4);
                        let p = o[0].swiperSlideOffset;
                        e.params.centeredSlides && !e.params.cssMode && e.$wrapperEl.transform(`translateX(${e.minTranslate()}px)`), e.params.centeredSlides && e.params.cssMode && (p -= t[0].swiperSlideOffset);
                        let u = e.params.cssMode ? -p - e.translate : -p,
                            h = 0;
                        const m = -100 * Math.abs(c);
                        let f = 1,
                            g = -2 * c,
                            v = 8 - .75 * Math.abs(c);
                        const w = (l === s || l === s - 1) && c > 0 && c < 1 && (r || e.params.cssMode) && n < i,
                            b = (l === s || l === s + 1) && c < 0 && c > -1 && (r || e.params.cssMode) && n > i;
                        if (w || b) {
                            const e = (1 - Math.abs((Math.abs(c) - .5) / .5)) ** .5;
                            g += -28 * c * e, f += -.5 * e, v += 96 * e, h = -25 * e * Math.abs(c) + "%"
                        }
                        if (u = c < 0 ? `calc(${u}px + (${v*Math.abs(c)}%))` : c > 0 ? `calc(${u}px + (-${v*Math.abs(c)}%))` : `${u}px`, !e.isHorizontal()) {
                            const e = h;
                            h = u, u = e
                        }
                        const x = `\n        translate3d(${u}, ${h}, ${m}px)\n        rotateZ(${g}deg)\n        scale(${c<0?""+(1+(1-f)*c):""+(1-(1-f)*c)})\n      `;
                        if (a.slideShadows) {
                            let e = o.find(".swiper-slide-shadow");
                            0 === e.length && (e = Z(a, o)), e.length && (e[0].style.opacity = Math.min(Math.max((Math.abs(c) - .5) / .5, 0), 1))
                        }
                        o[0].style.zIndex = -Math.abs(Math.round(d)) + t.length, U(a, o).transform(x)
                    }
                },
                setTransition: t => {
                    const {
                        transformEl: s
                    } = e.params.cardsEffect;
                    (s ? e.slides.find(s) : e.slides).transition(t).find(".swiper-slide-shadow").transition(t), K({
                        swiper: e,
                        duration: t,
                        transformEl: s
                    })
                },
                perspective: () => !0,
                overwriteParams: () => ({
                    watchSlidesProgress: !0,
                    virtualTranslate: !e.params.cssMode
                })
            })
        }];
        return H.use(J), H
    }, module.exports = t()
}, function(module, exports, __webpack_require__) {
    Object.defineProperty(exports, "__esModule", {
        value: !0
    });
    var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor)
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor
            }
        }(),
        _jquery2 = _interopRequireDefault(__webpack_require__(69)),
        _plyr2 = _interopRequireDefault(__webpack_require__(348));

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        }
    }
    var Brightcove = function() {
        function Brightcove(utag, ref) {
            ! function(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
            }(this, Brightcove), this.utag = utag, this.ref = ref
        }
        return _createClass(Brightcove, [{
            key: "getBrightcoveVideoData",
            value: function(videoID, callback) {
                var path = "https://edge.api.brightcove.com/playback/v1/accounts/75934411001/videos/" + videoID;
                _jquery2.default.ajax({
                    type: "GET",
                    url: path,
                    cache: !1,
                    contentType: "application/json",
                    crossDomain: !0,
                    processData: !0,
                    headers: {
                        Accept: "application/json;pk=BCpkADawqM0NvUfP8kau23tpJMWdg09UoT0lqv-Aoqc98Q-ug4rTtp17hA99TA9yLT4-SJm-oIpkYExCvnGqb1fpbxMZM1Y8Yy1Hol4HdRpWGuJHGskT_7155ak"
                    },
                    success: function(brightcoveVideoData) {
                        callback(brightcoveVideoData)
                    },
                    error: function(xhr, status, errorThrown) {
                        console.log(errorThrown + "\n" + status + "\n" + xhr.statusText)
                    }
                })
            }
        }, {
            key: "loadVideo",
            value: function(element) {
                var _this = this;

                this.videoDataLoadedHack((0, _jquery2.default)(element).data("video-id"), element)
                /*this.getBrightcoveVideoData((0, _jquery2.default)(element).data("video-id"), function(data) {
                    _this.videoDataLoaded(data, element)
                })*/
            }
        }, {
            key: "videoDataLoaded",
            value: function(data, element) {
                var videoSource = this.getVideoSource(data),
                    videoEl = (0, _jquery2.default)(element),
                    videoId = videoEl.data("video-id"),
                    controls = [],
                    autoplayinline = "",
                    playsinline = "",
                    loopinline = "",
                    mutedinline = "",
                    constrolsinline = "";
                !0 === videoEl.data("controls") && (constrolsinline = "controls", controls = ["play-large", "play", "progress", "current-time", "mute", "volume"]), !0 === videoEl.data("autoplay") && (autoplayinline = "autoplay", mutedinline = "muted", playsinline = "playsinline"), !0 === videoEl.data("loop") && (loopinline = "loop"), videoEl.append("<video crossorigin " + constrolsinline + " " + autoplayinline + " " + playsinline + " " + loopinline + " " + mutedinline + ' id="vid-' + videoId + '" class="media-player" poster="' + data.poster + '" data-name="' + videoEl.data("name") + '" data-video="' + data.id + '">\n        <source src="' + videoSource + '" type="video/mp4">\n        \n      </video>');
                var player = void 0;
                videoEl.data("autoplay") ? this.addDefaultListeners("vid-" + videoId) : (player = new _plyr2.default(document.getElementById("vid-" + videoId), {
                    controls: controls,
                    fullscreen: {
                        enabled: !1
                    }
                }), this.addPlayerListeners(player))
            }
        }, {
            key: "videoDataLoadedHack",
            value: function(videoId, element) {

                var videoSource = './video/'+ videoId + '.mp4',
                    videoEl = (0, _jquery2.default)(element),
                    videoId = videoEl.data("video-id"),
                    controls = [],
                    autoplayinline = "",
                    playsinline = "",
                    loopinline = "",
                    mutedinline = "",
                    constrolsinline = "";

                    var posterHTML = '';
                    var poster = videoEl.data("poster");
                    if(poster !== undefined) {
                    	posterHTML = ' poster="' + poster + '"';
                    }

                !0 === videoEl.data("controls") && (constrolsinline = "controls", controls = ["play-large", "play", "progress", "current-time", "mute", "volume"]), !0 === videoEl.data("autoplay") && (autoplayinline = "autoplay", mutedinline = "muted", playsinline = "playsinline"), !0 === videoEl.data("loop") && (loopinline = "loop"), videoEl.append("<video crossorigin " + constrolsinline + " " + autoplayinline + " " + playsinline + " " + loopinline + " " + mutedinline + ' id="vid-' + videoId + '" ' + posterHTML + ' class="media-player" >\n        <source src="' + videoSource + '" type="video/mp4">\n        \n      </video>');
                var player = void 0;
                videoEl.data("autoplay") ? this.addDefaultListeners("vid-" + videoId) : (player = new _plyr2.default(document.getElementById("vid-" + videoId), {
                    controls: controls,
                    fullscreen: {
                        enabled: !1
                    }
                }), this.addPlayerListeners(player))
            }
        }, {
            key: "getVideoSource",
            value: function(data) {
                for (var videoSourceArray = [], i = 0; i < data.sources.length; i += 1)
                    if ("src" in data.sources[i]) {
                        var srcToCheck = data.sources[i].src;
                        srcToCheck.startsWith("https") && srcToCheck.indexOf("mp4") && videoSourceArray.push(data.sources[i])
                    } for (var maxWidth = 0, maxWidthIndex = void 0, _i = 0; _i < videoSourceArray.length; _i += 1) videoSourceArray[_i].width > maxWidth && (maxWidth = videoSourceArray[_i].width, maxWidthIndex = _i);
                return videoSourceArray[maxWidthIndex].src
            }
        }, {
            key: "addDefaultListeners",
            value: function(id) {
                var _this2 = this,
                    vid = document.getElementById(id);
                try {
                    vid.onloadeddata = function() {
                        _this2.ref.setTextBoxes()
                    }
                } catch (err) {
                    console.log(err)
                }
            }
        }, {
            key: "addPlayerListeners",
            value: function(element) {
                var _this3 = this;
                element.once("loadeddata", function(e) {
                    _this3.ref.setTextBoxes(), (0, _jquery2.default)(e.target).addClass("isLoaded"), (0, _jquery2.default)(e.target).find(".plyr__controls").addClass("swiper-no-swiping")
                }), element.on("play", function(e) {
                    (0, _jquery2.default)(e.target).parent().find(".video-poster-sticker").addClass("video-started"), _this3.ref.fireLinkTag("hfth-video-play")
                }), element.on("pause", function() {
                    _this3.ref.fireLinkTag("hfth-video-pause")
                })
            }
        }]), Brightcove
    }();
    exports.default = Brightcove
}, function(module, exports, __webpack_require__) {
    (function(global) {
        var t;
        "object" == typeof navigator && (t = function() {
            "use strict";

            function e(t) {
                return (e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                })(t)
            }

            function t(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }

            function n(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var i = t[n];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                }
            }

            function i(e, t, i) {
                return t && n(e.prototype, t), i && n(e, i), e
            }

            function a(e, t, n) {
                return t in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e
            }

            function r(e, t) {
                var n = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var i = Object.getOwnPropertySymbols(e);
                    t && (i = i.filter(function(t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    })), n.push.apply(n, i)
                }
                return n
            }

            function o(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? r(Object(n), !0).forEach(function(t) {
                        a(e, t, n[t])
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : r(Object(n)).forEach(function(t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
                    })
                }
                return e
            }

            function l(e, t) {
                return function(e) {
                    if (Array.isArray(e)) return e
                }(e) || function(e, t) {
                    if ("undefined" != typeof Symbol && Symbol.iterator in Object(e)) {
                        var n = [],
                            i = !0,
                            a = !1,
                            r = void 0;
                        try {
                            for (var o, s = e[Symbol.iterator](); !(i = (o = s.next()).done) && (n.push(o.value), !t || n.length !== t); i = !0);
                        } catch (e) {
                            a = !0, r = e
                        } finally {
                            try {
                                i || null == s.return || s.return()
                            } finally {
                                if (a) throw r
                            }
                        }
                        return n
                    }
                }(e, t) || u(e, t) || function() {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }()
            }

            function c(e) {
                return function(e) {
                    if (Array.isArray(e)) return d(e)
                }(e) || function(e) {
                    if ("undefined" != typeof Symbol && Symbol.iterator in Object(e)) return Array.from(e)
                }(e) || u(e) || function() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }()
            }

            function u(e, t) {
                if (e) {
                    if ("string" == typeof e) return d(e, t);
                    var n = Object.prototype.toString.call(e).slice(8, -1);
                    return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? d(e, t) : void 0
                }
            }

            function d(e, t) {
                (null == t || t > e.length) && (t = e.length);
                for (var n = 0, i = new Array(t); n < t; n++) i[n] = e[n];
                return i
            }

            function h(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var i = t[n];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                }
            }

            function m(e, t, n) {
                return t in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e
            }

            function p(e, t) {
                var n = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var i = Object.getOwnPropertySymbols(e);
                    t && (i = i.filter(function(t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    })), n.push.apply(n, i)
                }
                return n
            }

            function f(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? p(Object(n), !0).forEach(function(t) {
                        m(e, t, n[t])
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : p(Object(n)).forEach(function(t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
                    })
                }
                return e
            }
            var g = {
                addCSS: !0,
                thumbWidth: 15,
                watch: !0
            };
            var b = function(e) {
                    return null != e ? e.constructor : null
                },
                v = function(e, t) {
                    return !!(e && t && e instanceof t)
                },
                T = function(e) {
                    return b(e) === String
                },
                C = function(e) {
                    return Array.isArray(e)
                },
                A = function(e) {
                    return v(e, NodeList)
                },
                S = T,
                P = C,
                E = A,
                N = function(e) {
                    return v(e, Element)
                },
                M = function(e) {
                    return v(e, Event)
                },
                x = function(e) {
                    return function(e) {
                        return null == e
                    }(e) || (T(e) || C(e) || A(e)) && !e.length || function(e) {
                        return b(e) === Object
                    }(e) && !Object.keys(e).length
                };
            var L, O, _, j = function() {
                    function e(t, n) {
                        (function(e, t) {
                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                        })(this, e), N(t) ? this.element = t : S(t) && (this.element = document.querySelector(t)), N(this.element) && x(this.element.rangeTouch) && (this.config = f({}, g, {}, n), this.init())
                    }
                    return function(e, t, n) {
                        t && h(e.prototype, t), n && h(e, n)
                    }(e, [{
                        key: "init",
                        value: function() {
                            e.enabled && (this.config.addCSS && (this.element.style.userSelect = "none", this.element.style.webKitUserSelect = "none", this.element.style.touchAction = "manipulation"), this.listeners(!0), this.element.rangeTouch = this)
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            e.enabled && (this.config.addCSS && (this.element.style.userSelect = "", this.element.style.webKitUserSelect = "", this.element.style.touchAction = ""), this.listeners(!1), this.element.rangeTouch = null)
                        }
                    }, {
                        key: "listeners",
                        value: function(e) {
                            var t = this,
                                n = e ? "addEventListener" : "removeEventListener";
                            ["touchstart", "touchmove", "touchend"].forEach(function(e) {
                                t.element[n](e, function(e) {
                                    return t.set(e)
                                }, !1)
                            })
                        }
                    }, {
                        key: "get",
                        value: function(t) {
                            if (!e.enabled || !M(t)) return null;
                            var n, i = t.target,
                                a = t.changedTouches[0],
                                r = parseFloat(i.getAttribute("min")) || 0,
                                o = parseFloat(i.getAttribute("max")) || 100,
                                s = parseFloat(i.getAttribute("step")) || 1,
                                l = i.getBoundingClientRect(),
                                c = 100 / l.width * (this.config.thumbWidth / 2) / 100;
                            return 0 > (n = 100 / l.width * (a.clientX - l.left)) ? n = 0 : 100 < n && (n = 100), 50 > n ? n -= (100 - 2 * n) * c : 50 < n && (n += 2 * (n - 50) * c), r + function(e, t) {
                                if (1 > t) {
                                    var n = function(e) {
                                        var t = "".concat(e).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
                                        return t ? Math.max(0, (t[1] ? t[1].length : 0) - (t[2] ? +t[2] : 0)) : 0
                                    }(t);
                                    return parseFloat(e.toFixed(n))
                                }
                                return Math.round(e / t) * t
                            }(n / 100 * (o - r), s)
                        }
                    }, {
                        key: "set",
                        value: function(t) {
                            e.enabled && M(t) && !t.target.disabled && (t.preventDefault(), t.target.value = this.get(t), function(e, t) {
                                if (e && t) {
                                    var n = new Event(t, {
                                        bubbles: !0
                                    });
                                    e.dispatchEvent(n)
                                }
                            }(t.target, "touchend" === t.type ? "change" : "input"))
                        }
                    }], [{
                        key: "setup",
                        value: function(t) {
                            var n = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {},
                                i = null;
                            if (x(t) || S(t) ? i = Array.from(document.querySelectorAll(S(t) ? t : 'input[type="range"]')) : N(t) ? i = [t] : E(t) ? i = Array.from(t) : P(t) && (i = t.filter(N)), x(i)) return null;
                            var a = f({}, g, {}, n);
                            S(t) && a.watch && new MutationObserver(function(n) {
                                Array.from(n).forEach(function(n) {
                                    Array.from(n.addedNodes).forEach(function(n) {
                                        N(n) && function(e, t) {
                                            return function() {
                                                return Array.from(document.querySelectorAll(t)).includes(this)
                                            }.call(e, t)
                                        }(n, t) && new e(n, a)
                                    })
                                })
                            }).observe(document.body, {
                                childList: !0,
                                subtree: !0
                            });
                            return i.map(function(t) {
                                return new e(t, n)
                            })
                        }
                    }, {
                        key: "enabled",
                        get: function() {
                            return "ontouchstart" in document.documentElement
                        }
                    }]), e
                }(),
                D = function(e) {
                    return null != e ? e.constructor : null
                },
                q = function(e, t) {
                    return Boolean(e && t && e instanceof t)
                },
                H = function(e) {
                    return null == e
                },
                F = function(e) {
                    return D(e) === Object
                },
                R = function(e) {
                    return D(e) === String
                },
                V = function(e) {
                    return D(e) === Function
                },
                B = function(e) {
                    return Array.isArray(e)
                },
                U = function(e) {
                    return q(e, NodeList)
                },
                W = function(e) {
                    return H(e) || (R(e) || B(e) || U(e)) && !e.length || F(e) && !Object.keys(e).length
                },
                z = H,
                K = F,
                Y = function(e) {
                    return D(e) === Number && !Number.isNaN(e)
                },
                Q = R,
                X = function(e) {
                    return D(e) === Boolean
                },
                $ = V,
                J = B,
                G = U,
                Z = function(t) {
                    return null !== t && "object" === e(t) && 1 === t.nodeType && "object" === e(t.style) && "object" === e(t.ownerDocument)
                },
                ee = function(e) {
                    return q(e, Event)
                },
                te = function(e) {
                    return q(e, KeyboardEvent)
                },
                ne = function(e) {
                    return q(e, TextTrack) || !H(e) && R(e.kind)
                },
                ie = function(e) {
                    return q(e, Promise) && V(e.then)
                },
                ae = function(e) {
                    if (q(e, window.URL)) return !0;
                    if (!R(e)) return !1;
                    var t = e;
                    e.startsWith("http://") && e.startsWith("https://") || (t = "http://".concat(e));
                    try {
                        return !W(new URL(t).hostname)
                    } catch (e) {
                        return !1
                    }
                },
                re = W,
                oe = (L = document.createElement("span"), O = {
                    WebkitTransition: "webkitTransitionEnd",
                    MozTransition: "transitionend",
                    OTransition: "oTransitionEnd otransitionend",
                    transition: "transitionend"
                }, _ = Object.keys(O).find(function(e) {
                    return void 0 !== L.style[e]
                }), !!Q(_) && O[_]);

            function se(e, t) {
                setTimeout(function() {
                    try {
                        e.hidden = !0, e.offsetHeight, e.hidden = !1
                    } catch (e) {}
                }, t)
            }
            var le = {
                isIE: !!document.documentMode,
                isEdge: window.navigator.userAgent.includes("Edge"),
                isWebkit: "WebkitAppearance" in document.documentElement.style && !/Edge/.test(navigator.userAgent),
                isIPhone: /(iPhone|iPod)/gi.test(navigator.platform),
                isIos: /(iPad|iPhone|iPod)/gi.test(navigator.platform)
            };

            function ce(e, t) {
                return t.split(".").reduce(function(e, t) {
                    return e && e[t]
                }, e)
            }

            function ue() {
                for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
                if (!n.length) return e;
                var r = n.shift();
                return K(r) ? (Object.keys(r).forEach(function(t) {
                    K(r[t]) ? (Object.keys(e).includes(t) || Object.assign(e, a({}, t, {})), ue(e[t], r[t])) : Object.assign(e, a({}, t, r[t]))
                }), ue.apply(void 0, [e].concat(n))) : e
            }

            function de(e, t) {
                var n = e.length ? e : [e];
                Array.from(n).reverse().forEach(function(e, n) {
                    var i = n > 0 ? t.cloneNode(!0) : t,
                        a = e.parentNode,
                        r = e.nextSibling;
                    i.appendChild(e), r ? a.insertBefore(i, r) : a.appendChild(i)
                })
            }

            function he(e, t) {
                Z(e) && !re(t) && Object.entries(t).filter(function(e) {
                    var t = l(e, 2)[1];
                    return !z(t)
                }).forEach(function(t) {
                    var n = l(t, 2),
                        i = n[0],
                        a = n[1];
                    return e.setAttribute(i, a)
                })
            }

            function me(e, t, n) {
                var i = document.createElement(e);
                return K(t) && he(i, t), Q(n) && (i.innerText = n), i
            }

            function pe(e, t, n, i) {
                Z(t) && t.appendChild(me(e, n, i))
            }

            function fe(e) {
                G(e) || J(e) ? Array.from(e).forEach(fe) : Z(e) && Z(e.parentNode) && e.parentNode.removeChild(e)
            }

            function ge(e) {
                if (Z(e))
                    for (var t = e.childNodes.length; t > 0;) e.removeChild(e.lastChild), t -= 1
            }

            function ye(e, t) {
                return Z(t) && Z(t.parentNode) && Z(e) ? (t.parentNode.replaceChild(e, t), e) : null
            }

            function be(e, t) {
                if (!Q(e) || re(e)) return {};
                var n = {},
                    i = ue({}, t);
                return e.split(",").forEach(function(e) {
                    var t = e.trim(),
                        a = t.replace(".", ""),
                        r = t.replace(/[[\]]/g, "").split("="),
                        o = l(r, 1)[0],
                        s = r.length > 1 ? r[1].replace(/["']/g, "") : "";
                    switch (t.charAt(0)) {
                        case ".":
                            Q(i.class) ? n.class = "".concat(i.class, " ").concat(a) : n.class = a;
                            break;
                        case "#":
                            n.id = t.replace("#", "");
                            break;
                        case "[":
                            n[o] = s
                    }
                }), ue(i, n)
            }

            function ve(e, t) {
                if (Z(e)) {
                    var n = t;
                    X(n) || (n = !e.hidden), e.hidden = n
                }
            }

            function we(e, t, n) {
                if (G(e)) return Array.from(e).map(function(e) {
                    return we(e, t, n)
                });
                if (Z(e)) {
                    var i = "toggle";
                    return void 0 !== n && (i = n ? "add" : "remove"), e.classList[i](t), e.classList.contains(t)
                }
                return !1
            }

            function ke(e, t) {
                return Z(e) && e.classList.contains(t)
            }

            function Te(e, t) {
                var n = Element.prototype;
                return (n.matches || n.webkitMatchesSelector || n.mozMatchesSelector || n.msMatchesSelector || function() {
                    return Array.from(document.querySelectorAll(t)).includes(this)
                }).call(e, t)
            }

            function Ce(e) {
                return this.elements.container.querySelectorAll(e)
            }

            function Ae(e) {
                return this.elements.container.querySelector(e)
            }

            function Se() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                    t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                Z(e) && (e.focus({
                    preventScroll: !0
                }), t && we(e, this.config.classNames.tabFocus))
            }
            var Pe, Ee = {
                    "audio/ogg": "vorbis",
                    "audio/wav": "1",
                    "video/webm": "vp8, vorbis",
                    "video/mp4": "avc1.42E01E, mp4a.40.2",
                    "video/ogg": "theora"
                },
                Ne = {
                    audio: "canPlayType" in document.createElement("audio"),
                    video: "canPlayType" in document.createElement("video"),
                    check: function(e, t, n) {
                        var i = le.isIPhone && n && Ne.playsinline,
                            a = Ne[e] || "html5" !== t;
                        return {
                            api: a,
                            ui: a && Ne.rangeInput && ("video" !== e || !le.isIPhone || i)
                        }
                    },
                    pip: !(le.isIPhone || !$(me("video").webkitSetPresentationMode) && (!document.pictureInPictureEnabled || me("video").disablePictureInPicture)),
                    airplay: $(window.WebKitPlaybackTargetAvailabilityEvent),
                    playsinline: "playsInline" in document.createElement("video"),
                    mime: function(e) {
                        if (re(e)) return !1;
                        var t = l(e.split("/"), 1)[0],
                            n = e;
                        if (!this.isHTML5 || t !== this.type) return !1;
                        Object.keys(Ee).includes(n) && (n += '; codecs="'.concat(Ee[e], '"'));
                        try {
                            return Boolean(n && this.media.canPlayType(n).replace(/no/, ""))
                        } catch (e) {
                            return !1
                        }
                    },
                    textTracks: "textTracks" in document.createElement("video"),
                    rangeInput: (Pe = document.createElement("input"), Pe.type = "range", "range" === Pe.type),
                    touch: "ontouchstart" in document.documentElement,
                    transitions: !1 !== oe,
                    reducedMotion: "matchMedia" in window && window.matchMedia("(prefers-reduced-motion)").matches
                },
                Me = function() {
                    var e = !1;
                    try {
                        var t = Object.defineProperty({}, "passive", {
                            get: function() {
                                return e = !0, null
                            }
                        });
                        window.addEventListener("test", null, t), window.removeEventListener("test", null, t)
                    } catch (e) {}
                    return e
                }();

            function xe(e, t, n) {
                var i = this,
                    a = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
                    r = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4],
                    o = arguments.length > 5 && void 0 !== arguments[5] && arguments[5];
                if (e && "addEventListener" in e && !re(t) && $(n)) {
                    var s = t.split(" "),
                        l = o;
                    Me && (l = {
                        passive: r,
                        capture: o
                    }), s.forEach(function(t) {
                        i && i.eventListeners && a && i.eventListeners.push({
                            element: e,
                            type: t,
                            callback: n,
                            options: l
                        }), e[a ? "addEventListener" : "removeEventListener"](t, n, l)
                    })
                }
            }

            function Ie(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
                    n = arguments.length > 2 ? arguments[2] : void 0,
                    i = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
                    a = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
                xe.call(this, e, t, n, !0, i, a)
            }

            function Le(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
                    n = arguments.length > 2 ? arguments[2] : void 0,
                    i = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
                    a = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
                xe.call(this, e, t, n, !1, i, a)
            }

            function Oe(e) {
                var t = this,
                    n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
                    i = arguments.length > 2 ? arguments[2] : void 0,
                    a = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
                    r = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
                xe.call(this, e, n, function o() {
                    Le(e, n, o, a, r);
                    for (var s = arguments.length, l = new Array(s), c = 0; c < s; c++) l[c] = arguments[c];
                    i.apply(t, l)
                }, !0, a, r)
            }

            function _e(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
                    n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                    i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                if (Z(e) && !re(t)) {
                    var a = new CustomEvent(t, {
                        bubbles: n,
                        detail: o(o({}, i), {}, {
                            plyr: this
                        })
                    });
                    e.dispatchEvent(a)
                }
            }

            function qe(e) {
                ie(e) && e.then(null, function() {})
            }

            function He(e) {
                return !!(J(e) || Q(e) && e.includes(":")) && (J(e) ? e : e.split(":")).map(Number).every(Y)
            }

            function Fe(e) {
                if (!J(e) || !e.every(Y)) return null;
                var t = l(e, 2),
                    n = t[0],
                    i = t[1],
                    a = function e(t, n) {
                        return 0 === n ? t : e(n, t % n)
                    }(n, i);
                return [n / a, i / a]
            }

            function Re(e) {
                var t = function(e) {
                        return He(e) ? e.split(":").map(Number) : null
                    },
                    n = t(e);
                if (null === n && (n = t(this.config.ratio)), null === n && !re(this.embed) && J(this.embed.ratio) && (n = this.embed.ratio), null === n && this.isHTML5) {
                    var i = this.media;
                    n = Fe([i.videoWidth, i.videoHeight])
                }
                return n
            }

            function Ve(e) {
                if (!this.isVideo) return {};
                var t = this.elements.wrapper,
                    n = Re.call(this, e),
                    i = l(J(n) ? n : [0, 0], 2),
                    a = 100 / i[0] * i[1];
                if (t.style.paddingBottom = "".concat(a, "%"), this.isVimeo && !this.config.vimeo.premium && this.supported.ui) {
                    var r = 100 / this.media.offsetWidth * parseInt(window.getComputedStyle(this.media).paddingBottom, 10),
                        o = (r - a) / (r / 50);
                    this.fullscreen.active ? t.style.paddingBottom = null : this.media.style.transform = "translateY(-".concat(o, "%)")
                } else this.isHTML5 && t.classList.toggle(this.config.classNames.videoFixedRatio, null !== n);
                return {
                    padding: a,
                    ratio: n
                }
            }
            var Be = {
                getSources: function() {
                    var e = this;
                    return this.isHTML5 ? Array.from(this.media.querySelectorAll("source")).filter(function(t) {
                        var n = t.getAttribute("type");
                        return !!re(n) || Ne.mime.call(e, n)
                    }) : []
                },
                getQualityOptions: function() {
                    return this.config.quality.forced ? this.config.quality.options : Be.getSources.call(this).map(function(e) {
                        return Number(e.getAttribute("size"))
                    }).filter(Boolean)
                },
                setup: function() {
                    if (this.isHTML5) {
                        var e = this;
                        e.options.speed = e.config.speed.options, re(this.config.ratio) || Ve.call(e), Object.defineProperty(e.media, "quality", {
                            get: function() {
                                var t = Be.getSources.call(e).find(function(t) {
                                    return t.getAttribute("src") === e.source
                                });
                                return t && Number(t.getAttribute("size"))
                            },
                            set: function(t) {
                                if (e.quality !== t) {
                                    if (e.config.quality.forced && $(e.config.quality.onChange)) e.config.quality.onChange(t);
                                    else {
                                        var n = Be.getSources.call(e).find(function(e) {
                                            return Number(e.getAttribute("size")) === t
                                        });
                                        if (!n) return;
                                        var i = e.media,
                                            a = i.currentTime,
                                            r = i.paused,
                                            o = i.preload,
                                            s = i.readyState,
                                            l = i.playbackRate;
                                        e.media.src = n.getAttribute("src"), ("none" !== o || s) && (e.once("loadedmetadata", function() {
                                            e.speed = l, e.currentTime = a, r || qe(e.play())
                                        }), e.media.load())
                                    }
                                    _e.call(e, e.media, "qualitychange", !1, {
                                        quality: t
                                    })
                                }
                            }
                        })
                    }
                },
                cancelRequests: function() {
                    this.isHTML5 && (fe(Be.getSources.call(this)), this.media.setAttribute("src", this.config.blankVideo), this.media.load(), this.debug.log("Cancelled network requests"))
                }
            };

            function Ue(e) {
                return J(e) ? e.filter(function(t, n) {
                    return e.indexOf(t) === n
                }) : e
            }

            function We(e) {
                for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
                return re(e) ? e : e.toString().replace(/{(\d+)}/g, function(e, t) {
                    return n[t].toString()
                })
            }
            var ze = function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
                        t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
                        n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "";
                    return e.replace(new RegExp(t.toString().replace(/([.*+?^=!:${}()|[\]/\\])/g, "\\$1"), "g"), n.toString())
                },
                Ke = function() {
                    return (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "").toString().replace(/\w\S*/g, function(e) {
                        return e.charAt(0).toUpperCase() + e.substr(1).toLowerCase()
                    })
                };

            function Qe(e) {
                var t = document.createElement("div");
                return t.appendChild(e), t.innerHTML
            }
            var Xe = {
                    pip: "PIP",
                    airplay: "AirPlay",
                    html5: "HTML5",
                    vimeo: "Vimeo",
                    youtube: "YouTube"
                },
                $e = function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
                        t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    if (re(e) || re(t)) return "";
                    var n = ce(t.i18n, e);
                    if (re(n)) return Object.keys(Xe).includes(e) ? Xe[e] : "";
                    var i = {
                        "{seektime}": t.seekTime,
                        "{title}": t.title
                    };
                    return Object.entries(i).forEach(function(e) {
                        var t = l(e, 2),
                            i = t[0],
                            a = t[1];
                        n = ze(n, i, a)
                    }), n
                },
                Je = function() {
                    function e(n) {
                        var i = this;
                        t(this, e), a(this, "get", function(t) {
                            if (!e.supported || !i.enabled) return null;
                            var n = window.localStorage.getItem(i.key);
                            if (re(n)) return null;
                            var a = JSON.parse(n);
                            return Q(t) && t.length ? a[t] : a
                        }), a(this, "set", function(t) {
                            if (e.supported && i.enabled && K(t)) {
                                var n = i.get();
                                re(n) && (n = {}), ue(n, t), window.localStorage.setItem(i.key, JSON.stringify(n))
                            }
                        }), this.enabled = n.config.storage.enabled, this.key = n.config.storage.key
                    }
                    return i(e, null, [{
                        key: "supported",
                        get: function() {
                            try {
                                if (!("localStorage" in window)) return !1;
                                var e = "___test";
                                return window.localStorage.setItem(e, e), window.localStorage.removeItem(e), !0
                            } catch (e) {
                                return !1
                            }
                        }
                    }]), e
                }();

            function Ge(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "text";
                return new Promise(function(n, i) {
                    try {
                        var a = new XMLHttpRequest;
                        if (!("withCredentials" in a)) return;
                        a.addEventListener("load", function() {
                            if ("text" === t) try {
                                n(JSON.parse(a.responseText))
                            } catch (e) {
                                n(a.responseText)
                            } else n(a.response)
                        }), a.addEventListener("error", function() {
                            throw new Error(a.status)
                        }), a.open("GET", e, !0), a.responseType = t, a.send()
                    } catch (e) {
                        i(e)
                    }
                })
            }

            function Ze(e, t) {
                if (Q(e)) {
                    var n = "cache",
                        i = Q(t),
                        a = function() {
                            return null !== document.getElementById(t)
                        },
                        r = function(e, t) {
                            e.innerHTML = t, i && a() || document.body.insertAdjacentElement("afterbegin", e)
                        };
                    if (!i || !a()) {
                        var o = Je.supported,
                            s = document.createElement("div");
                        if (s.setAttribute("hidden", ""), i && s.setAttribute("id", t), o) {
                            var l = window.localStorage.getItem("".concat(n, "-").concat(t));
                            if (null !== l) {
                                var c = JSON.parse(l);
                                r(s, c.content)
                            }
                        }
                        Ge(e).then(function(e) {
                            re(e) || (o && window.localStorage.setItem("".concat(n, "-").concat(t), JSON.stringify({
                                content: e
                            })), r(s, e))
                        }).catch(function() {})
                    }
                }
            }
            var et = function(e) {
                    return Math.trunc(e / 60 / 60 % 60, 10)
                },
                tt = function(e) {
                    return Math.trunc(e / 60 % 60, 10)
                },
                nt = function(e) {
                    return Math.trunc(e % 60, 10)
                };

            function it() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                    t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                    n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                if (!Y(e)) return it(void 0, t, n);
                var i = function(e) {
                        return "0".concat(e).slice(-2)
                    },
                    a = et(e),
                    r = tt(e),
                    o = nt(e);
                return a = t || a > 0 ? "".concat(a, ":") : "", "".concat(n && e > 0 ? "-" : "").concat(a).concat(i(r), ":").concat(i(o))
            }
            var at = {
                getIconUrl: function() {
                    var e = new URL(this.config.iconUrl, window.location).host !== window.location.host || le.isIE && !window.svg4everybody;
                    return {
                        url: this.config.iconUrl,
                        cors: e
                    }
                },
                findElements: function() {
                    try {
                        return this.elements.controls = Ae.call(this, this.config.selectors.controls.wrapper), this.elements.buttons = {
                            play: Ce.call(this, this.config.selectors.buttons.play),
                            pause: Ae.call(this, this.config.selectors.buttons.pause),
                            restart: Ae.call(this, this.config.selectors.buttons.restart),
                            rewind: Ae.call(this, this.config.selectors.buttons.rewind),
                            fastForward: Ae.call(this, this.config.selectors.buttons.fastForward),
                            mute: Ae.call(this, this.config.selectors.buttons.mute),
                            pip: Ae.call(this, this.config.selectors.buttons.pip),
                            airplay: Ae.call(this, this.config.selectors.buttons.airplay),
                            settings: Ae.call(this, this.config.selectors.buttons.settings),
                            captions: Ae.call(this, this.config.selectors.buttons.captions),
                            fullscreen: Ae.call(this, this.config.selectors.buttons.fullscreen)
                        }, this.elements.progress = Ae.call(this, this.config.selectors.progress), this.elements.inputs = {
                            seek: Ae.call(this, this.config.selectors.inputs.seek),
                            volume: Ae.call(this, this.config.selectors.inputs.volume)
                        }, this.elements.display = {
                            buffer: Ae.call(this, this.config.selectors.display.buffer),
                            currentTime: Ae.call(this, this.config.selectors.display.currentTime),
                            duration: Ae.call(this, this.config.selectors.display.duration)
                        }, Z(this.elements.progress) && (this.elements.display.seekTooltip = this.elements.progress.querySelector(".".concat(this.config.classNames.tooltip))), !0
                    } catch (e) {
                        return this.debug.warn("It looks like there is a problem with your custom controls HTML", e), this.toggleNativeControls(!0), !1
                    }
                },
                createIcon: function(e, t) {
                    var n = "http://www.w3.org/2000/svg",
                        i = at.getIconUrl.call(this),
                        a = "".concat(i.cors ? "" : i.url, "#").concat(this.config.iconPrefix),
                        r = document.createElementNS(n, "svg");
                    he(r, ue(t, {
                        "aria-hidden": "true",
                        focusable: "false"
                    }));
                    var o = document.createElementNS(n, "use"),
                        s = "".concat(a, "-").concat(e);
                    return "href" in o && o.setAttributeNS("http://www.w3.org/1999/xlink", "href", s), o.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", s), r.appendChild(o), r
                },
                createLabel: function(e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                        n = $e(e, this.config);
                    return me("span", o(o({}, t), {}, {
                        class: [t.class, this.config.classNames.hidden].filter(Boolean).join(" ")
                    }), n)
                },
                createBadge: function(e) {
                    if (re(e)) return null;
                    var t = me("span", {
                        class: this.config.classNames.menu.value
                    });
                    return t.appendChild(me("span", {
                        class: this.config.classNames.menu.badge
                    }, e)), t
                },
                createButton: function(e, t) {
                    var n = this,
                        i = ue({}, t),
                        a = function() {
                            var e = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "").toString();
                            return (e = function() {
                                var t = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "").toString();
                                return t = ze(t, "-", " "), t = ze(t, "_", " "), t = Ke(t), ze(t, " ", "")
                            }(e)).charAt(0).toLowerCase() + e.slice(1)
                        }(e),
                        r = {
                            element: "button",
                            toggle: !1,
                            label: null,
                            icon: null,
                            labelPressed: null,
                            iconPressed: null
                        };
                    switch (["element", "icon", "label"].forEach(function(e) {
                            Object.keys(i).includes(e) && (r[e] = i[e], delete i[e])
                        }), "button" !== r.element || Object.keys(i).includes("type") || (i.type = "button"), Object.keys(i).includes("class") ? i.class.split(" ").some(function(e) {
                            return e === n.config.classNames.control
                        }) || ue(i, {
                            class: "".concat(i.class, " ").concat(this.config.classNames.control)
                        }) : i.class = this.config.classNames.control, e) {
                        case "play":
                            r.toggle = !0, r.label = "play", r.labelPressed = "pause", r.icon = "play", r.iconPressed = "pause";
                            break;
                        case "mute":
                            r.toggle = !0, r.label = "mute", r.labelPressed = "unmute", r.icon = "volume", r.iconPressed = "muted";
                            break;
                        case "captions":
                            r.toggle = !0, r.label = "enableCaptions", r.labelPressed = "disableCaptions", r.icon = "captions-off", r.iconPressed = "captions-on";
                            break;
                        case "fullscreen":
                            r.toggle = !0, r.label = "enterFullscreen", r.labelPressed = "exitFullscreen", r.icon = "enter-fullscreen", r.iconPressed = "exit-fullscreen";
                            break;
                        case "play-large":
                            i.class += " ".concat(this.config.classNames.control, "--overlaid"), a = "play", r.label = "play", r.icon = "play";
                            break;
                        default:
                            re(r.label) && (r.label = a), re(r.icon) && (r.icon = e)
                    }
                    var o = me(r.element);
                    return r.toggle ? (o.appendChild(at.createIcon.call(this, r.iconPressed, {
                        class: "icon--pressed"
                    })), o.appendChild(at.createIcon.call(this, r.icon, {
                        class: "icon--not-pressed"
                    })), o.appendChild(at.createLabel.call(this, r.labelPressed, {
                        class: "label--pressed"
                    })), o.appendChild(at.createLabel.call(this, r.label, {
                        class: "label--not-pressed"
                    }))) : (o.appendChild(at.createIcon.call(this, r.icon)), o.appendChild(at.createLabel.call(this, r.label))), ue(i, be(this.config.selectors.buttons[a], i)), he(o, i), "play" === a ? (J(this.elements.buttons[a]) || (this.elements.buttons[a] = []), this.elements.buttons[a].push(o)) : this.elements.buttons[a] = o, o
                },
                createRange: function(e, t) {
                    var n = me("input", ue(be(this.config.selectors.inputs[e]), {
                        type: "range",
                        min: 0,
                        max: 100,
                        step: .01,
                        value: 0,
                        autocomplete: "off",
                        role: "slider",
                        "aria-label": $e(e, this.config),
                        "aria-valuemin": 0,
                        "aria-valuemax": 100,
                        "aria-valuenow": 0
                    }, t));
                    return this.elements.inputs[e] = n, at.updateRangeFill.call(this, n), j.setup(n), n
                },
                createProgress: function(e, t) {
                    var n = me("progress", ue(be(this.config.selectors.display[e]), {
                        min: 0,
                        max: 100,
                        value: 0,
                        role: "progressbar",
                        "aria-hidden": !0
                    }, t));
                    if ("volume" !== e) {
                        n.appendChild(me("span", null, "0"));
                        var i = {
                                played: "played",
                                buffer: "buffered"
                            } [e],
                            a = i ? $e(i, this.config) : "";
                        n.innerText = "% ".concat(a.toLowerCase())
                    }
                    return this.elements.display[e] = n, n
                },
                createTime: function(e, t) {
                    var n = be(this.config.selectors.display[e], t),
                        i = me("div", ue(n, {
                            class: "".concat(n.class ? n.class : "", " ").concat(this.config.classNames.display.time, " ").trim(),
                            "aria-label": $e(e, this.config)
                        }), "00:00");
                    return this.elements.display[e] = i, i
                },
                bindMenuItemShortcuts: function(e, t) {
                    var n = this;
                    Ie.call(this, e, "keydown keyup", function(i) {
                        if ([32, 38, 39, 40].includes(i.which) && (i.preventDefault(), i.stopPropagation(), "keydown" !== i.type)) {
                            var a, r = Te(e, '[role="menuitemradio"]');
                            !r && [32, 39].includes(i.which) ? at.showMenuPanel.call(n, t, !0) : 32 !== i.which && (40 === i.which || r && 39 === i.which ? (a = e.nextElementSibling, Z(a) || (a = e.parentNode.firstElementChild)) : (a = e.previousElementSibling, Z(a) || (a = e.parentNode.lastElementChild)), Se.call(n, a, !0))
                        }
                    }, !1), Ie.call(this, e, "keyup", function(e) {
                        13 === e.which && at.focusFirstMenuItem.call(n, null, !0)
                    })
                },
                createMenuItem: function(e) {
                    var t = this,
                        n = e.value,
                        i = e.list,
                        a = e.type,
                        r = e.title,
                        o = e.badge,
                        s = void 0 === o ? null : o,
                        l = e.checked,
                        c = void 0 !== l && l,
                        u = be(this.config.selectors.inputs[a]),
                        d = me("button", ue(u, {
                            type: "button",
                            role: "menuitemradio",
                            class: "".concat(this.config.classNames.control, " ").concat(u.class ? u.class : "").trim(),
                            "aria-checked": c,
                            value: n
                        })),
                        h = me("span");
                    h.innerHTML = r, Z(s) && h.appendChild(s), d.appendChild(h), Object.defineProperty(d, "checked", {
                        enumerable: !0,
                        get: function() {
                            return "true" === d.getAttribute("aria-checked")
                        },
                        set: function(e) {
                            e && Array.from(d.parentNode.children).filter(function(e) {
                                return Te(e, '[role="menuitemradio"]')
                            }).forEach(function(e) {
                                return e.setAttribute("aria-checked", "false")
                            }), d.setAttribute("aria-checked", e ? "true" : "false")
                        }
                    }), this.listeners.bind(d, "click keyup", function(e) {
                        if (!te(e) || 32 === e.which) {
                            switch (e.preventDefault(), e.stopPropagation(), d.checked = !0, a) {
                                case "language":
                                    t.currentTrack = Number(n);
                                    break;
                                case "quality":
                                    t.quality = n;
                                    break;
                                case "speed":
                                    t.speed = parseFloat(n)
                            }
                            at.showMenuPanel.call(t, "home", te(e))
                        }
                    }, a, !1), at.bindMenuItemShortcuts.call(this, d, a), i.appendChild(d)
                },
                formatTime: function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                        t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    return Y(e) ? it(e, et(this.duration) > 0, t) : e
                },
                updateTimeDisplay: function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                        t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                        n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                    Z(e) && Y(t) && (e.innerText = at.formatTime(t, n))
                },
                updateVolume: function() {
                    this.supported.ui && (Z(this.elements.inputs.volume) && at.setRange.call(this, this.elements.inputs.volume, this.muted ? 0 : this.volume), Z(this.elements.buttons.mute) && (this.elements.buttons.mute.pressed = this.muted || 0 === this.volume))
                },
                setRange: function(e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                    Z(e) && (e.value = t, at.updateRangeFill.call(this, e))
                },
                updateProgress: function(e) {
                    var t = this;
                    if (this.supported.ui && ee(e)) {
                        var n, i, a = 0;
                        if (e) switch (e.type) {
                            case "timeupdate":
                            case "seeking":
                            case "seeked":
                                n = this.currentTime, i = this.duration, a = 0 === n || 0 === i || Number.isNaN(n) || Number.isNaN(i) ? 0 : (n / i * 100).toFixed(2), "timeupdate" === e.type && at.setRange.call(this, this.elements.inputs.seek, a);
                                break;
                            case "playing":
                            case "progress":
                                ! function(e, n) {
                                    var i = Y(n) ? n : 0,
                                        a = Z(e) ? e : t.elements.display.buffer;
                                    if (Z(a)) {
                                        a.value = i;
                                        var r = a.getElementsByTagName("span")[0];
                                        Z(r) && (r.childNodes[0].nodeValue = i)
                                    }
                                }(this.elements.display.buffer, 100 * this.buffered)
                        }
                    }
                },
                updateRangeFill: function(e) {
                    var t = ee(e) ? e.target : e;
                    if (Z(t) && "range" === t.getAttribute("type")) {
                        if (Te(t, this.config.selectors.inputs.seek)) {
                            t.setAttribute("aria-valuenow", this.currentTime);
                            var n = at.formatTime(this.currentTime),
                                i = at.formatTime(this.duration),
                                a = $e("seekLabel", this.config);
                            t.setAttribute("aria-valuetext", a.replace("{currentTime}", n).replace("{duration}", i))
                        } else if (Te(t, this.config.selectors.inputs.volume)) {
                            var r = 100 * t.value;
                            t.setAttribute("aria-valuenow", r), t.setAttribute("aria-valuetext", "".concat(r.toFixed(1), "%"))
                        } else t.setAttribute("aria-valuenow", t.value);
                        le.isWebkit && t.style.setProperty("--value", "".concat(t.value / t.max * 100, "%"))
                    }
                },
                updateSeekTooltip: function(e) {
                    var t = this;
                    if (this.config.tooltips.seek && Z(this.elements.inputs.seek) && Z(this.elements.display.seekTooltip) && 0 !== this.duration) {
                        var n = "".concat(this.config.classNames.tooltip, "--visible"),
                            i = function(e) {
                                return we(t.elements.display.seekTooltip, n, e)
                            };
                        if (this.touch) i(!1);
                        else {
                            var a = 0,
                                r = this.elements.progress.getBoundingClientRect();
                            if (ee(e)) a = 100 / r.width * (e.pageX - r.left);
                            else {
                                if (!ke(this.elements.display.seekTooltip, n)) return;
                                a = parseFloat(this.elements.display.seekTooltip.style.left, 10)
                            }
                            a < 0 ? a = 0 : a > 100 && (a = 100), at.updateTimeDisplay.call(this, this.elements.display.seekTooltip, this.duration / 100 * a), this.elements.display.seekTooltip.style.left = "".concat(a, "%"), ee(e) && ["mouseenter", "mouseleave"].includes(e.type) && i("mouseenter" === e.type)
                        }
                    }
                },
                timeUpdate: function(e) {
                    var t = !Z(this.elements.display.duration) && this.config.invertTime;
                    at.updateTimeDisplay.call(this, this.elements.display.currentTime, t ? this.duration - this.currentTime : this.currentTime, t), e && "timeupdate" === e.type && this.media.seeking || at.updateProgress.call(this, e)
                },
                durationUpdate: function() {
                    if (this.supported.ui && (this.config.invertTime || !this.currentTime)) {
                        if (this.duration >= Math.pow(2, 32)) return ve(this.elements.display.currentTime, !0), void ve(this.elements.progress, !0);
                        Z(this.elements.inputs.seek) && this.elements.inputs.seek.setAttribute("aria-valuemax", this.duration);
                        var e = Z(this.elements.display.duration);
                        !e && this.config.displayDuration && this.paused && at.updateTimeDisplay.call(this, this.elements.display.currentTime, this.duration), e && at.updateTimeDisplay.call(this, this.elements.display.duration, this.duration), at.updateSeekTooltip.call(this)
                    }
                },
                toggleMenuButton: function(e, t) {
                    ve(this.elements.settings.buttons[e], !t)
                },
                updateSetting: function(e, t, n) {
                    var i = this.elements.settings.panels[e],
                        a = null,
                        r = t;
                    if ("captions" === e) a = this.currentTrack;
                    else {
                        if (a = re(n) ? this[e] : n, re(a) && (a = this.config[e].default), !re(this.options[e]) && !this.options[e].includes(a)) return void this.debug.warn("Unsupported value of '".concat(a, "' for ").concat(e));
                        if (!this.config[e].options.includes(a)) return void this.debug.warn("Disabled value of '".concat(a, "' for ").concat(e))
                    }
                    if (Z(r) || (r = i && i.querySelector('[role="menu"]')), Z(r)) {
                        this.elements.settings.buttons[e].querySelector(".".concat(this.config.classNames.menu.value)).innerHTML = at.getLabel.call(this, e, a);
                        var o = r && r.querySelector('[value="'.concat(a, '"]'));
                        Z(o) && (o.checked = !0)
                    }
                },
                getLabel: function(e, t) {
                    switch (e) {
                        case "speed":
                            return 1 === t ? $e("normal", this.config) : "".concat(t, "&times;");
                        case "quality":
                            if (Y(t)) {
                                var n = $e("qualityLabel.".concat(t), this.config);
                                return n.length ? n : "".concat(t, "p")
                            }
                            return Ke(t);
                        case "captions":
                            return st.getLabel.call(this);
                        default:
                            return null
                    }
                },
                setQualityMenu: function(e) {
                    var t = this;
                    if (Z(this.elements.settings.panels.quality)) {
                        var n = "quality",
                            i = this.elements.settings.panels.quality.querySelector('[role="menu"]');
                        J(e) && (this.options.quality = Ue(e).filter(function(e) {
                            return t.config.quality.options.includes(e)
                        }));
                        var a = !re(this.options.quality) && this.options.quality.length > 1;
                        if (at.toggleMenuButton.call(this, n, a), ge(i), at.checkMenu.call(this), a) {
                            this.options.quality.sort(function(e, n) {
                                var i = t.config.quality.options;
                                return i.indexOf(e) > i.indexOf(n) ? 1 : -1
                            }).forEach(function(e) {
                                at.createMenuItem.call(t, {
                                    value: e,
                                    list: i,
                                    type: n,
                                    title: at.getLabel.call(t, "quality", e),
                                    badge: function(e) {
                                        var n = $e("qualityBadge.".concat(e), t.config);
                                        return n.length ? at.createBadge.call(t, n) : null
                                    }(e)
                                })
                            }), at.updateSetting.call(this, n, i)
                        }
                    }
                },
                setCaptionsMenu: function() {
                    var e = this;
                    if (Z(this.elements.settings.panels.captions)) {
                        var t = "captions",
                            n = this.elements.settings.panels.captions.querySelector('[role="menu"]'),
                            i = st.getTracks.call(this),
                            a = Boolean(i.length);
                        if (at.toggleMenuButton.call(this, t, a), ge(n), at.checkMenu.call(this), a) {
                            var r = i.map(function(t, i) {
                                return {
                                    value: i,
                                    checked: e.captions.toggled && e.currentTrack === i,
                                    title: st.getLabel.call(e, t),
                                    badge: t.language && at.createBadge.call(e, t.language.toUpperCase()),
                                    list: n,
                                    type: "language"
                                }
                            });
                            r.unshift({
                                value: -1,
                                checked: !this.captions.toggled,
                                title: $e("disabled", this.config),
                                list: n,
                                type: "language"
                            }), r.forEach(at.createMenuItem.bind(this)), at.updateSetting.call(this, t, n)
                        }
                    }
                },
                setSpeedMenu: function() {
                    var e = this;
                    if (Z(this.elements.settings.panels.speed)) {
                        var t = "speed",
                            n = this.elements.settings.panels.speed.querySelector('[role="menu"]');
                        this.options.speed = this.options.speed.filter(function(t) {
                            return t >= e.minimumSpeed && t <= e.maximumSpeed
                        });
                        var i = !re(this.options.speed) && this.options.speed.length > 1;
                        at.toggleMenuButton.call(this, t, i), ge(n), at.checkMenu.call(this), i && (this.options.speed.forEach(function(i) {
                            at.createMenuItem.call(e, {
                                value: i,
                                list: n,
                                type: t,
                                title: at.getLabel.call(e, "speed", i)
                            })
                        }), at.updateSetting.call(this, t, n))
                    }
                },
                checkMenu: function() {
                    var e = this.elements.settings.buttons,
                        t = !re(e) && Object.values(e).some(function(e) {
                            return !e.hidden
                        });
                    ve(this.elements.settings.menu, !t)
                },
                focusFirstMenuItem: function(e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    if (!this.elements.settings.popup.hidden) {
                        var n = e;
                        Z(n) || (n = Object.values(this.elements.settings.panels).find(function(e) {
                            return !e.hidden
                        }));
                        var i = n.querySelector('[role^="menuitem"]');
                        Se.call(this, i, t)
                    }
                },
                toggleMenu: function(e) {
                    var t = this.elements.settings.popup,
                        n = this.elements.buttons.settings;
                    if (Z(t) && Z(n)) {
                        var i = t.hidden,
                            a = i;
                        if (X(e)) a = e;
                        else if (te(e) && 27 === e.which) a = !1;
                        else if (ee(e)) {
                            var r = $(e.composedPath) ? e.composedPath()[0] : e.target,
                                o = t.contains(r);
                            if (o || !o && e.target !== n && a) return
                        }
                        n.setAttribute("aria-expanded", a), ve(t, !a), we(this.elements.container, this.config.classNames.menu.open, a), a && te(e) ? at.focusFirstMenuItem.call(this, null, !0) : a || i || Se.call(this, n, te(e))
                    }
                },
                getMenuSize: function(e) {
                    var t = e.cloneNode(!0);
                    t.style.position = "absolute", t.style.opacity = 0, t.removeAttribute("hidden"), e.parentNode.appendChild(t);
                    var n = t.scrollWidth,
                        i = t.scrollHeight;
                    return fe(t), {
                        width: n,
                        height: i
                    }
                },
                showMenuPanel: function() {
                    var e = this,
                        t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
                        n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                        i = this.elements.container.querySelector("#plyr-settings-".concat(this.id, "-").concat(t));
                    if (Z(i)) {
                        var a = i.parentNode,
                            r = Array.from(a.children).find(function(e) {
                                return !e.hidden
                            });
                        if (Ne.transitions && !Ne.reducedMotion) {
                            a.style.width = "".concat(r.scrollWidth, "px"), a.style.height = "".concat(r.scrollHeight, "px");
                            var o = at.getMenuSize.call(this, i);
                            Ie.call(this, a, oe, function t(n) {
                                n.target === a && ["width", "height"].includes(n.propertyName) && (a.style.width = "", a.style.height = "", Le.call(e, a, oe, t))
                            }), a.style.width = "".concat(o.width, "px"), a.style.height = "".concat(o.height, "px")
                        }
                        ve(r, !0), ve(i, !1), at.focusFirstMenuItem.call(this, i, n)
                    }
                },
                setDownloadUrl: function() {
                    var e = this.elements.buttons.download;
                    Z(e) && e.setAttribute("href", this.download)
                },
                create: function(e) {
                    var t = this,
                        n = at.bindMenuItemShortcuts,
                        i = at.createButton,
                        a = at.createProgress,
                        r = at.createRange,
                        o = at.createTime,
                        s = at.setQualityMenu,
                        l = at.setSpeedMenu,
                        c = at.showMenuPanel;
                    this.elements.controls = null, J(this.config.controls) && this.config.controls.includes("play-large") && this.elements.container.appendChild(i.call(this, "play-large"));
                    var u = me("div", be(this.config.selectors.controls.wrapper));
                    this.elements.controls = u;
                    var d = {
                        class: "plyr__controls__item"
                    };
                    return Ue(J(this.config.controls) ? this.config.controls : []).forEach(function(s) {
                        if ("restart" === s && u.appendChild(i.call(t, "restart", d)), "rewind" === s && u.appendChild(i.call(t, "rewind", d)), "play" === s && u.appendChild(i.call(t, "play", d)), "fast-forward" === s && u.appendChild(i.call(t, "fast-forward", d)), "progress" === s) {
                            var l = me("div", {
                                    class: "".concat(d.class, " plyr__progress__container")
                                }),
                                h = me("div", be(t.config.selectors.progress));
                            if (h.appendChild(r.call(t, "seek", {
                                    id: "plyr-seek-".concat(e.id)
                                })), h.appendChild(a.call(t, "buffer")), t.config.tooltips.seek) {
                                var m = me("span", {
                                    class: t.config.classNames.tooltip
                                }, "00:00");
                                h.appendChild(m), t.elements.display.seekTooltip = m
                            }
                            t.elements.progress = h, l.appendChild(t.elements.progress), u.appendChild(l)
                        }
                        if ("current-time" === s && u.appendChild(o.call(t, "currentTime", d)), "duration" === s && u.appendChild(o.call(t, "duration", d)), "mute" === s || "volume" === s) {
                            var p = t.elements.volume;
                            if (Z(p) && u.contains(p) || (p = me("div", ue({}, d, {
                                    class: "".concat(d.class, " plyr__volume").trim()
                                })), t.elements.volume = p, u.appendChild(p)), "mute" === s && p.appendChild(i.call(t, "mute")), "volume" === s && !le.isIos) {
                                var f = {
                                    max: 1,
                                    step: .05,
                                    value: t.config.volume
                                };
                                p.appendChild(r.call(t, "volume", ue(f, {
                                    id: "plyr-volume-".concat(e.id)
                                })))
                            }
                        }
                        if ("captions" === s && u.appendChild(i.call(t, "captions", d)), "settings" === s && !re(t.config.settings)) {
                            var g = me("div", ue({}, d, {
                                class: "".concat(d.class, " plyr__menu").trim(),
                                hidden: ""
                            }));
                            g.appendChild(i.call(t, "settings", {
                                "aria-haspopup": !0,
                                "aria-controls": "plyr-settings-".concat(e.id),
                                "aria-expanded": !1
                            }));
                            var y = me("div", {
                                    class: "plyr__menu__container",
                                    id: "plyr-settings-".concat(e.id),
                                    hidden: ""
                                }),
                                b = me("div"),
                                v = me("div", {
                                    id: "plyr-settings-".concat(e.id, "-home")
                                }),
                                w = me("div", {
                                    role: "menu"
                                });
                            v.appendChild(w), b.appendChild(v), t.elements.settings.panels.home = v, t.config.settings.forEach(function(i) {
                                var a = me("button", ue(be(t.config.selectors.buttons.settings), {
                                    type: "button",
                                    class: "".concat(t.config.classNames.control, " ").concat(t.config.classNames.control, "--forward"),
                                    role: "menuitem",
                                    "aria-haspopup": !0,
                                    hidden: ""
                                }));
                                n.call(t, a, i), Ie.call(t, a, "click", function() {
                                    c.call(t, i, !1)
                                });
                                var r = me("span", null, $e(i, t.config)),
                                    o = me("span", {
                                        class: t.config.classNames.menu.value
                                    });
                                o.innerHTML = e[i], r.appendChild(o), a.appendChild(r), w.appendChild(a);
                                var s = me("div", {
                                        id: "plyr-settings-".concat(e.id, "-").concat(i),
                                        hidden: ""
                                    }),
                                    l = me("button", {
                                        type: "button",
                                        class: "".concat(t.config.classNames.control, " ").concat(t.config.classNames.control, "--back")
                                    });
                                l.appendChild(me("span", {
                                    "aria-hidden": !0
                                }, $e(i, t.config))), l.appendChild(me("span", {
                                    class: t.config.classNames.hidden
                                }, $e("menuBack", t.config))), Ie.call(t, s, "keydown", function(e) {
                                    37 === e.which && (e.preventDefault(), e.stopPropagation(), c.call(t, "home", !0))
                                }, !1), Ie.call(t, l, "click", function() {
                                    c.call(t, "home", !1)
                                }), s.appendChild(l), s.appendChild(me("div", {
                                    role: "menu"
                                })), b.appendChild(s), t.elements.settings.buttons[i] = a, t.elements.settings.panels[i] = s
                            }), y.appendChild(b), g.appendChild(y), u.appendChild(g), t.elements.settings.popup = y, t.elements.settings.menu = g
                        }
                        if ("pip" === s && Ne.pip && u.appendChild(i.call(t, "pip", d)), "airplay" === s && Ne.airplay && u.appendChild(i.call(t, "airplay", d)), "download" === s) {
                            var k = ue({}, d, {
                                element: "a",
                                href: t.download,
                                target: "_blank"
                            });
                            t.isHTML5 && (k.download = "");
                            var T = t.config.urls.download;
                            !ae(T) && t.isEmbed && ue(k, {
                                icon: "logo-".concat(t.provider),
                                label: t.provider
                            }), u.appendChild(i.call(t, "download", k))
                        }
                        "fullscreen" === s && u.appendChild(i.call(t, "fullscreen", d))
                    }), this.isHTML5 && s.call(this, Be.getQualityOptions.call(this)), l.call(this), u
                },
                inject: function() {
                    var e = this;
                    if (this.config.loadSprite) {
                        var t = at.getIconUrl.call(this);
                        t.cors && Ze(t.url, "sprite-plyr")
                    }
                    this.id = Math.floor(1e4 * Math.random());
                    var n = null;
                    this.elements.controls = null;
                    var r, o, i = {
                            id: this.id,
                            seektime: this.config.seekTime,
                            title: this.config.title
                        },
                        a = !0;
                    if ($(this.config.controls) && (this.config.controls = this.config.controls.call(this, i)), this.config.controls || (this.config.controls = []), Z(this.config.controls) || Q(this.config.controls) ? n = this.config.controls : (n = at.create.call(this, {
                            id: this.id,
                            seektime: this.config.seekTime,
                            speed: this.speed,
                            quality: this.quality,
                            captions: st.getLabel.call(this)
                        }), a = !1), a && Q(this.config.controls) && (r = n, Object.entries(i).forEach(function(e) {
                            var t = l(e, 2),
                                n = t[0],
                                i = t[1];
                            r = ze(r, "{".concat(n, "}"), i)
                        }), n = r), Q(this.config.selectors.controls.container) && (o = document.querySelector(this.config.selectors.controls.container)), Z(o) || (o = this.elements.container), o[Z(n) ? "insertAdjacentElement" : "insertAdjacentHTML"]("afterbegin", n), Z(this.elements.controls) || at.findElements.call(this), !re(this.elements.buttons)) {
                        var s = function(t) {
                            var n = e.config.classNames.controlPressed;
                            Object.defineProperty(t, "pressed", {
                                enumerable: !0,
                                get: function() {
                                    return ke(t, n)
                                },
                                set: function() {
                                    var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                                    we(t, n, e)
                                }
                            })
                        };
                        Object.values(this.elements.buttons).filter(Boolean).forEach(function(e) {
                            J(e) || G(e) ? Array.from(e).filter(Boolean).forEach(s) : s(e)
                        })
                    }
                    if (le.isEdge && se(o), this.config.tooltips.controls) {
                        var c = this.config,
                            u = c.classNames,
                            d = c.selectors,
                            h = "".concat(d.controls.wrapper, " ").concat(d.labels, " .").concat(u.hidden),
                            m = Ce.call(this, h);
                        Array.from(m).forEach(function(t) {
                            we(t, e.config.classNames.hidden, !1), we(t, e.config.classNames.tooltip, !0)
                        })
                    }
                }
            };

            function rt(e) {
                var n = e;
                if (!(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]) {
                    var i = document.createElement("a");
                    i.href = n, n = i.href
                }
                try {
                    return new URL(n)
                } catch (e) {
                    return null
                }
            }

            function ot(e) {
                var t = new URLSearchParams;
                return K(e) && Object.entries(e).forEach(function(e) {
                    var n = l(e, 2),
                        i = n[0],
                        a = n[1];
                    t.set(i, a)
                }), t
            }
            var st = {
                    setup: function() {
                        if (this.supported.ui)
                            if (!this.isVideo || this.isYouTube || this.isHTML5 && !Ne.textTracks) J(this.config.controls) && this.config.controls.includes("settings") && this.config.settings.includes("captions") && at.setCaptionsMenu.call(this);
                            else {
                                if (Z(this.elements.captions) || (this.elements.captions = me("div", be(this.config.selectors.captions)), function(e, t) {
                                        Z(e) && Z(t) && t.parentNode.insertBefore(e, t.nextSibling)
                                    }(this.elements.captions, this.elements.wrapper)), le.isIE && window.URL) {
                                    var e = this.media.querySelectorAll("track");
                                    Array.from(e).forEach(function(e) {
                                        var t = e.getAttribute("src"),
                                            n = rt(t);
                                        null !== n && n.hostname !== window.location.href.hostname && ["http:", "https:"].includes(n.protocol) && Ge(t, "blob").then(function(t) {
                                            e.setAttribute("src", window.URL.createObjectURL(t))
                                        }).catch(function() {
                                            fe(e)
                                        })
                                    })
                                }
                                var t = Ue((navigator.languages || [navigator.language || navigator.userLanguage || "en"]).map(function(e) {
                                        return e.split("-")[0]
                                    })),
                                    n = (this.storage.get("language") || this.config.captions.language || "auto").toLowerCase();
                                "auto" === n && (n = l(t, 1)[0]);
                                var i = this.storage.get("captions");
                                if (X(i) || (i = this.config.captions.active), Object.assign(this.captions, {
                                        toggled: !1,
                                        active: i,
                                        language: n,
                                        languages: t
                                    }), this.isHTML5) {
                                    var a = this.config.captions.update ? "addtrack removetrack" : "removetrack";
                                    Ie.call(this, this.media.textTracks, a, st.update.bind(this))
                                }
                                setTimeout(st.update.bind(this), 0)
                            }
                    },
                    update: function() {
                        var e = this,
                            t = st.getTracks.call(this, !0),
                            n = this.captions,
                            i = n.active,
                            a = n.language,
                            r = n.meta,
                            o = n.currentTrackNode,
                            s = Boolean(t.find(function(e) {
                                return e.language === a
                            }));
                        this.isHTML5 && this.isVideo && t.filter(function(e) {
                            return !r.get(e)
                        }).forEach(function(t) {
                            e.debug.log("Track added", t), r.set(t, {
                                default: "showing" === t.mode
                            }), "showing" === t.mode && (t.mode = "hidden"), Ie.call(e, t, "cuechange", function() {
                                return st.updateCues.call(e)
                            })
                        }), (s && this.language !== a || !t.includes(o)) && (st.setLanguage.call(this, a), st.toggle.call(this, i && s)), we(this.elements.container, this.config.classNames.captions.enabled, !re(t)), J(this.config.controls) && this.config.controls.includes("settings") && this.config.settings.includes("captions") && at.setCaptionsMenu.call(this)
                    },
                    toggle: function(e) {
                        var t = this,
                            n = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                        if (this.supported.ui) {
                            var i = this.captions.toggled,
                                a = this.config.classNames.captions.active,
                                r = z(e) ? !i : e;
                            if (r !== i) {
                                if (n || (this.captions.active = r, this.storage.set({
                                        captions: r
                                    })), !this.language && r && !n) {
                                    var o = st.getTracks.call(this),
                                        s = st.findTrack.call(this, [this.captions.language].concat(c(this.captions.languages)), !0);
                                    return this.captions.language = s.language, void st.set.call(this, o.indexOf(s))
                                }
                                this.elements.buttons.captions && (this.elements.buttons.captions.pressed = r), we(this.elements.container, a, r), this.captions.toggled = r, at.updateSetting.call(this, "captions"), _e.call(this, this.media, r ? "captionsenabled" : "captionsdisabled")
                            }
                            setTimeout(function() {
                                r && t.captions.toggled && (t.captions.currentTrackNode.mode = "hidden")
                            })
                        }
                    },
                    set: function(e) {
                        var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                            n = st.getTracks.call(this);
                        if (-1 !== e)
                            if (Y(e))
                                if (e in n) {
                                    if (this.captions.currentTrack !== e) {
                                        this.captions.currentTrack = e;
                                        var i = n[e],
                                            r = (i || {}).language;
                                        this.captions.currentTrackNode = i, at.updateSetting.call(this, "captions"), t || (this.captions.language = r, this.storage.set({
                                            language: r
                                        })), this.isVimeo && this.embed.enableTextTrack(r), _e.call(this, this.media, "languagechange")
                                    }
                                    st.toggle.call(this, !0, t), this.isHTML5 && this.isVideo && st.updateCues.call(this)
                                } else this.debug.warn("Track not found", e);
                        else this.debug.warn("Invalid caption argument", e);
                        else st.toggle.call(this, !1, t)
                    },
                    setLanguage: function(e) {
                        var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                        if (Q(e)) {
                            var n = e.toLowerCase();
                            this.captions.language = n;
                            var i = st.getTracks.call(this),
                                a = st.findTrack.call(this, [n]);
                            st.set.call(this, i.indexOf(a), t)
                        } else this.debug.warn("Invalid language argument", e)
                    },
                    getTracks: function() {
                        var e = this,
                            t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                        return Array.from((this.media || {}).textTracks || []).filter(function(n) {
                            return !e.isHTML5 || t || e.captions.meta.has(n)
                        }).filter(function(e) {
                            return ["captions", "subtitles"].includes(e.kind)
                        })
                    },
                    findTrack: function(e) {
                        var t, n = this,
                            i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                            a = st.getTracks.call(this),
                            r = function(e) {
                                return Number((n.captions.meta.get(e) || {}).default)
                            },
                            o = Array.from(a).sort(function(e, t) {
                                return r(t) - r(e)
                            });
                        return e.every(function(e) {
                            return !(t = o.find(function(t) {
                                return t.language === e
                            }))
                        }), t || (i ? o[0] : void 0)
                    },
                    getCurrentTrack: function() {
                        return st.getTracks.call(this)[this.currentTrack]
                    },
                    getLabel: function(e) {
                        var t = e;
                        return !ne(t) && Ne.textTracks && this.captions.toggled && (t = st.getCurrentTrack.call(this)), ne(t) ? re(t.label) ? re(t.language) ? $e("enabled", this.config) : e.language.toUpperCase() : t.label : $e("disabled", this.config)
                    },
                    updateCues: function(e) {
                        if (this.supported.ui)
                            if (Z(this.elements.captions))
                                if (z(e) || Array.isArray(e)) {
                                    var t = e;
                                    if (!t) {
                                        var n = st.getCurrentTrack.call(this);
                                        t = Array.from((n || {}).activeCues || []).map(function(e) {
                                            return e.getCueAsHTML()
                                        }).map(Qe)
                                    }
                                    var i = t.map(function(e) {
                                        return e.trim()
                                    }).join("\n");
                                    if (i !== this.elements.captions.innerHTML) {
                                        ge(this.elements.captions);
                                        var a = me("span", be(this.config.selectors.caption));
                                        a.innerHTML = i, this.elements.captions.appendChild(a), _e.call(this, this.media, "cuechange")
                                    }
                                } else this.debug.warn("updateCues: Invalid input", e);
                        else this.debug.warn("No captions element to render to")
                    }
                },
                lt = {
                    enabled: !0,
                    title: "",
                    debug: !1,
                    autoplay: !1,
                    autopause: !0,
                    playsinline: !0,
                    seekTime: 10,
                    volume: 1,
                    muted: !1,
                    duration: null,
                    displayDuration: !0,
                    invertTime: !0,
                    toggleInvert: !0,
                    ratio: null,
                    clickToPlay: !0,
                    hideControls: !0,
                    resetOnEnd: !1,
                    disableContextMenu: !0,
                    loadSprite: !0,
                    iconPrefix: "plyr",
                    iconUrl: "https://cdn.plyr.io/3.6.4/plyr.svg",
                    blankVideo: "https://cdn.plyr.io/static/blank.mp4",
                    quality: {
                        default: 576,
                        options: [4320, 2880, 2160, 1440, 1080, 720, 576, 480, 360, 240],
                        forced: !1,
                        onChange: null
                    },
                    loop: {
                        active: !1
                    },
                    speed: {
                        selected: 1,
                        options: [.5, .75, 1, 1.25, 1.5, 1.75, 2, 4]
                    },
                    keyboard: {
                        focused: !0,
                        global: !1
                    },
                    tooltips: {
                        controls: !1,
                        seek: !0
                    },
                    captions: {
                        active: !1,
                        language: "auto",
                        update: !1
                    },
                    fullscreen: {
                        enabled: !0,
                        fallback: !0,
                        iosNative: !1
                    },
                    storage: {
                        enabled: !0,
                        key: "plyr"
                    },
                    controls: ["play-large", "play", "progress", "current-time", "mute", "volume", "captions", "settings", "pip", "airplay", "fullscreen"],
                    settings: ["captions", "quality", "speed"],
                    i18n: {
                        restart: "Restart",
                        rewind: "Rewind {seektime}s",
                        play: "Play",
                        pause: "Pause",
                        fastForward: "Forward {seektime}s",
                        seek: "Seek",
                        seekLabel: "{currentTime} of {duration}",
                        played: "Played",
                        buffered: "Buffered",
                        currentTime: "Current time",
                        duration: "Duration",
                        volume: "Volume",
                        mute: "Mute",
                        unmute: "Unmute",
                        enableCaptions: "Enable captions",
                        disableCaptions: "Disable captions",
                        download: "Download",
                        enterFullscreen: "Enter fullscreen",
                        exitFullscreen: "Exit fullscreen",
                        frameTitle: "Player for {title}",
                        captions: "Captions",
                        settings: "Settings",
                        pip: "PIP",
                        menuBack: "Go back to previous menu",
                        speed: "Speed",
                        normal: "Normal",
                        quality: "Quality",
                        loop: "Loop",
                        start: "Start",
                        end: "End",
                        all: "All",
                        reset: "Reset",
                        disabled: "Disabled",
                        enabled: "Enabled",
                        advertisement: "Ad",
                        qualityBadge: {
                            2160: "4K",
                            1440: "HD",
                            1080: "HD",
                            720: "HD",
                            576: "SD",
                            480: "SD"
                        }
                    },
                    urls: {
                        download: null,
                        vimeo: {
                            sdk: "https://player.vimeo.com/api/player.js",
                            iframe: "https://player.vimeo.com/video/{0}?{1}",
                            api: "https://vimeo.com/api/oembed.json?url={0}"
                        },
                        youtube: {
                            sdk: "https://www.youtube.com/iframe_api",
                            api: "https://noembed.com/embed?url=https://www.youtube.com/watch?v={0}"
                        },
                        googleIMA: {
                            sdk: "https://imasdk.googleapis.com/js/sdkloader/ima3.js"
                        }
                    },
                    listeners: {
                        seek: null,
                        play: null,
                        pause: null,
                        restart: null,
                        rewind: null,
                        fastForward: null,
                        mute: null,
                        volume: null,
                        captions: null,
                        download: null,
                        fullscreen: null,
                        pip: null,
                        airplay: null,
                        speed: null,
                        quality: null,
                        loop: null,
                        language: null
                    },
                    events: ["ended", "progress", "stalled", "playing", "waiting", "canplay", "canplaythrough", "loadstart", "loadeddata", "loadedmetadata", "timeupdate", "volumechange", "play", "pause", "error", "seeking", "seeked", "emptied", "ratechange", "cuechange", "download", "enterfullscreen", "exitfullscreen", "captionsenabled", "captionsdisabled", "languagechange", "controlshidden", "controlsshown", "ready", "statechange", "qualitychange", "adsloaded", "adscontentpause", "adscontentresume", "adstarted", "adsmidpoint", "adscomplete", "adsallcomplete", "adsimpression", "adsclick"],
                    selectors: {
                        editable: "input, textarea, select, [contenteditable]",
                        container: ".plyr",
                        controls: {
                            container: null,
                            wrapper: ".plyr__controls"
                        },
                        labels: "[data-plyr]",
                        buttons: {
                            play: '[data-plyr="play"]',
                            pause: '[data-plyr="pause"]',
                            restart: '[data-plyr="restart"]',
                            rewind: '[data-plyr="rewind"]',
                            fastForward: '[data-plyr="fast-forward"]',
                            mute: '[data-plyr="mute"]',
                            captions: '[data-plyr="captions"]',
                            download: '[data-plyr="download"]',
                            fullscreen: '[data-plyr="fullscreen"]',
                            pip: '[data-plyr="pip"]',
                            airplay: '[data-plyr="airplay"]',
                            settings: '[data-plyr="settings"]',
                            loop: '[data-plyr="loop"]'
                        },
                        inputs: {
                            seek: '[data-plyr="seek"]',
                            volume: '[data-plyr="volume"]',
                            speed: '[data-plyr="speed"]',
                            language: '[data-plyr="language"]',
                            quality: '[data-plyr="quality"]'
                        },
                        display: {
                            currentTime: ".plyr__time--current",
                            duration: ".plyr__time--duration",
                            buffer: ".plyr__progress__buffer",
                            loop: ".plyr__progress__loop",
                            volume: ".plyr__volume--display"
                        },
                        progress: ".plyr__progress",
                        captions: ".plyr__captions",
                        caption: ".plyr__caption"
                    },
                    classNames: {
                        type: "plyr--{0}",
                        provider: "plyr--{0}",
                        video: "plyr__video-wrapper",
                        embed: "plyr__video-embed",
                        videoFixedRatio: "plyr__video-wrapper--fixed-ratio",
                        embedContainer: "plyr__video-embed__container",
                        poster: "plyr__poster",
                        posterEnabled: "plyr__poster-enabled",
                        ads: "plyr__ads",
                        control: "plyr__control",
                        controlPressed: "plyr__control--pressed",
                        playing: "plyr--playing",
                        paused: "plyr--paused",
                        stopped: "plyr--stopped",
                        loading: "plyr--loading",
                        hover: "plyr--hover",
                        tooltip: "plyr__tooltip",
                        cues: "plyr__cues",
                        hidden: "plyr__sr-only",
                        hideControls: "plyr--hide-controls",
                        isIos: "plyr--is-ios",
                        isTouch: "plyr--is-touch",
                        uiSupported: "plyr--full-ui",
                        noTransition: "plyr--no-transition",
                        display: {
                            time: "plyr__time"
                        },
                        menu: {
                            value: "plyr__menu__value",
                            badge: "plyr__badge",
                            open: "plyr--menu-open"
                        },
                        captions: {
                            enabled: "plyr--captions-enabled",
                            active: "plyr--captions-active"
                        },
                        fullscreen: {
                            enabled: "plyr--fullscreen-enabled",
                            fallback: "plyr--fullscreen-fallback"
                        },
                        pip: {
                            supported: "plyr--pip-supported",
                            active: "plyr--pip-active"
                        },
                        airplay: {
                            supported: "plyr--airplay-supported",
                            active: "plyr--airplay-active"
                        },
                        tabFocus: "plyr__tab-focus",
                        previewThumbnails: {
                            thumbContainer: "plyr__preview-thumb",
                            thumbContainerShown: "plyr__preview-thumb--is-shown",
                            imageContainer: "plyr__preview-thumb__image-container",
                            timeContainer: "plyr__preview-thumb__time-container",
                            scrubbingContainer: "plyr__preview-scrubbing",
                            scrubbingContainerShown: "plyr__preview-scrubbing--is-shown"
                        }
                    },
                    attributes: {
                        embed: {
                            provider: "data-plyr-provider",
                            id: "data-plyr-embed-id"
                        }
                    },
                    ads: {
                        enabled: !1,
                        publisherId: "",
                        tagUrl: ""
                    },
                    previewThumbnails: {
                        enabled: !1,
                        src: ""
                    },
                    vimeo: {
                        byline: !1,
                        portrait: !1,
                        title: !1,
                        speed: !0,
                        transparent: !1,
                        customControls: !0,
                        referrerPolicy: null,
                        premium: !1
                    },
                    youtube: {
                        rel: 0,
                        showinfo: 0,
                        iv_load_policy: 3,
                        modestbranding: 1,
                        customControls: !0,
                        noCookie: !1
                    }
                },
                ct = "picture-in-picture",
                dt = {
                    html5: "html5",
                    youtube: "youtube",
                    vimeo: "vimeo"
                },
                mt = "video",
                pt = function() {},
                ft = function() {
                    function e() {
                        var n = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                        t(this, e), this.enabled = window.console && n, this.enabled && this.log("Debugging enabled")
                    }
                    return i(e, [{
                        key: "log",
                        get: function() {
                            return this.enabled ? Function.prototype.bind.call(console.log, console) : pt
                        }
                    }, {
                        key: "warn",
                        get: function() {
                            return this.enabled ? Function.prototype.bind.call(console.warn, console) : pt
                        }
                    }, {
                        key: "error",
                        get: function() {
                            return this.enabled ? Function.prototype.bind.call(console.error, console) : pt
                        }
                    }]), e
                }(),
                gt = function() {
                    function e(n) {
                        var i = this;
                        t(this, e), a(this, "onChange", function() {
                            if (i.enabled) {
                                var e = i.player.elements.buttons.fullscreen;
                                Z(e) && (e.pressed = i.active);
                                var t = i.target === i.player.media ? i.target : i.player.elements.container;
                                _e.call(i.player, t, i.active ? "enterfullscreen" : "exitfullscreen", !0)
                            }
                        }), a(this, "toggleFallback", function() {
                            var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                            if (e ? i.scrollPosition = {
                                    x: window.scrollX || 0,
                                    y: window.scrollY || 0
                                } : window.scrollTo(i.scrollPosition.x, i.scrollPosition.y), document.body.style.overflow = e ? "hidden" : "", we(i.target, i.player.config.classNames.fullscreen.fallback, e), le.isIos) {
                                var t = document.head.querySelector('meta[name="viewport"]'),
                                    n = "viewport-fit=cover";
                                t || (t = document.createElement("meta")).setAttribute("name", "viewport");
                                var a = Q(t.content) && t.content.includes(n);
                                e ? (i.cleanupViewport = !a, a || (t.content += ",".concat(n))) : i.cleanupViewport && (t.content = t.content.split(",").filter(function(e) {
                                    return e.trim() !== n
                                }).join(","))
                            }
                            i.onChange()
                        }), a(this, "trapFocus", function(e) {
                            if (!le.isIos && i.active && "Tab" === e.key && 9 === e.keyCode) {
                                var t = document.activeElement,
                                    n = Ce.call(i.player, "a[href], button:not(:disabled), input:not(:disabled), [tabindex]"),
                                    a = l(n, 1)[0],
                                    r = n[n.length - 1];
                                t !== r || e.shiftKey ? t === a && e.shiftKey && (r.focus(), e.preventDefault()) : (a.focus(), e.preventDefault())
                            }
                        }), a(this, "update", function() {
                            var t;
                            i.enabled ? (t = i.forceFallback ? "Fallback (forced)" : e.native ? "Native" : "Fallback", i.player.debug.log("".concat(t, " fullscreen enabled"))) : i.player.debug.log("Fullscreen not supported and fallback disabled"), we(i.player.elements.container, i.player.config.classNames.fullscreen.enabled, i.enabled)
                        }), a(this, "enter", function() {
                            i.enabled && (le.isIos && i.player.config.fullscreen.iosNative ? i.player.isVimeo ? i.player.embed.requestFullscreen() : i.target.webkitEnterFullscreen() : !e.native || i.forceFallback ? i.toggleFallback(!0) : i.prefix ? re(i.prefix) || i.target["".concat(i.prefix, "Request").concat(i.property)]() : i.target.requestFullscreen({
                                navigationUI: "hide"
                            }))
                        }), a(this, "exit", function() {
                            if (i.enabled)
                                if (le.isIos && i.player.config.fullscreen.iosNative) i.target.webkitExitFullscreen(), qe(i.player.play());
                                else if (!e.native || i.forceFallback) i.toggleFallback(!1);
                            else if (i.prefix) {
                                if (!re(i.prefix)) {
                                    var t = "moz" === i.prefix ? "Cancel" : "Exit";
                                    document["".concat(i.prefix).concat(t).concat(i.property)]()
                                }
                            } else(document.cancelFullScreen || document.exitFullscreen).call(document)
                        }), a(this, "toggle", function() {
                            i.active ? i.exit() : i.enter()
                        }), this.player = n, this.prefix = e.prefix, this.property = e.property, this.scrollPosition = {
                            x: 0,
                            y: 0
                        }, this.forceFallback = "force" === n.config.fullscreen.fallback, this.player.elements.fullscreen = n.config.fullscreen.container && function(e, t) {
                            return (Element.prototype.closest || function() {
                                var e = this;
                                do {
                                    if (Te.matches(e, t)) return e;
                                    e = e.parentElement || e.parentNode
                                } while (null !== e && 1 === e.nodeType);
                                return null
                            }).call(e, t)
                        }(this.player.elements.container, n.config.fullscreen.container), Ie.call(this.player, document, "ms" === this.prefix ? "MSFullscreenChange" : "".concat(this.prefix, "fullscreenchange"), function() {
                            i.onChange()
                        }), Ie.call(this.player, this.player.elements.container, "dblclick", function(e) {
                            Z(i.player.elements.controls) && i.player.elements.controls.contains(e.target) || i.player.listeners.proxy(e, i.toggle, "fullscreen")
                        }), Ie.call(this, this.player.elements.container, "keydown", function(e) {
                            return i.trapFocus(e)
                        }), this.update()
                    }
                    return i(e, [{
                        key: "usingNative",
                        get: function() {
                            return e.native && !this.forceFallback
                        }
                    }, {
                        key: "enabled",
                        get: function() {
                            return (e.native || this.player.config.fullscreen.fallback) && this.player.config.fullscreen.enabled && this.player.supported.ui && this.player.isVideo
                        }
                    }, {
                        key: "active",
                        get: function() {
                            if (!this.enabled) return !1;
                            if (!e.native || this.forceFallback) return ke(this.target, this.player.config.classNames.fullscreen.fallback);
                            var t = this.prefix ? document["".concat(this.prefix).concat(this.property, "Element")] : document.fullscreenElement;
                            return t && t.shadowRoot ? t === this.target.getRootNode().host : t === this.target
                        }
                    }, {
                        key: "target",
                        get: function() {
                            return le.isIos && this.player.config.fullscreen.iosNative ? this.player.media : this.player.elements.fullscreen || this.player.elements.container
                        }
                    }], [{
                        key: "native",
                        get: function() {
                            return !!(document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled)
                        }
                    }, {
                        key: "prefix",
                        get: function() {
                            if ($(document.exitFullscreen)) return "";
                            var e = "";
                            return ["webkit", "moz", "ms"].some(function(t) {
                                return !(!$(document["".concat(t, "ExitFullscreen")]) && !$(document["".concat(t, "CancelFullScreen")]) || (e = t, 0))
                            }), e
                        }
                    }, {
                        key: "property",
                        get: function() {
                            return "moz" === this.prefix ? "FullScreen" : "Fullscreen"
                        }
                    }]), e
                }();

            function yt(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                return new Promise(function(n, i) {
                    var a = new Image,
                        r = function() {
                            delete a.onload, delete a.onerror, (a.naturalWidth >= t ? n : i)(a)
                        };
                    Object.assign(a, {
                        onload: r,
                        onerror: r,
                        src: e
                    })
                })
            }
            var bt = {
                    addStyleHook: function() {
                        we(this.elements.container, this.config.selectors.container.replace(".", ""), !0), we(this.elements.container, this.config.classNames.uiSupported, this.supported.ui)
                    },
                    toggleNativeControls: function() {
                        arguments.length > 0 && void 0 !== arguments[0] && arguments[0] && this.isHTML5 ? this.media.setAttribute("controls", "") : this.media.removeAttribute("controls")
                    },
                    build: function() {
                        var e = this;
                        if (this.listeners.media(), !this.supported.ui) return this.debug.warn("Basic support only for ".concat(this.provider, " ").concat(this.type)), void bt.toggleNativeControls.call(this, !0);
                        Z(this.elements.controls) || (at.inject.call(this), this.listeners.controls()), bt.toggleNativeControls.call(this), this.isHTML5 && st.setup.call(this), this.volume = null, this.muted = null, this.loop = null, this.quality = null, this.speed = null, at.updateVolume.call(this), at.timeUpdate.call(this), bt.checkPlaying.call(this), we(this.elements.container, this.config.classNames.pip.supported, Ne.pip && this.isHTML5 && this.isVideo), we(this.elements.container, this.config.classNames.airplay.supported, Ne.airplay && this.isHTML5), we(this.elements.container, this.config.classNames.isIos, le.isIos), we(this.elements.container, this.config.classNames.isTouch, this.touch), this.ready = !0, setTimeout(function() {
                            _e.call(e, e.media, "ready")
                        }, 0), bt.setTitle.call(this), this.poster && bt.setPoster.call(this, this.poster, !1).catch(function() {}), this.config.duration && at.durationUpdate.call(this)
                    },
                    setTitle: function() {
                        var e = $e("play", this.config);
                        if (Q(this.config.title) && !re(this.config.title) && (e += ", ".concat(this.config.title)), Array.from(this.elements.buttons.play || []).forEach(function(t) {
                                t.setAttribute("aria-label", e)
                            }), this.isEmbed) {
                            var t = Ae.call(this, "iframe");
                            if (!Z(t)) return;
                            var n = re(this.config.title) ? "video" : this.config.title,
                                i = $e("frameTitle", this.config);
                            t.setAttribute("title", i.replace("{title}", n))
                        }
                    },
                    togglePoster: function(e) {
                        we(this.elements.container, this.config.classNames.posterEnabled, e)
                    },
                    setPoster: function(e) {
                        var t = this;
                        return (!(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]) && this.poster ? Promise.reject(new Error("Poster already set")) : (this.media.setAttribute("data-poster", e), this.elements.poster.removeAttribute("hidden"), function() {
                            var e = this;
                            return new Promise(function(t) {
                                return e.ready ? setTimeout(t, 0) : Ie.call(e, e.elements.container, "ready", t)
                            }).then(function() {})
                        }.call(this).then(function() {
                            return yt(e)
                        }).catch(function(n) {
                            throw e === t.poster && bt.togglePoster.call(t, !1), n
                        }).then(function() {
                            if (e !== t.poster) throw new Error("setPoster cancelled by later call to setPoster")
                        }).then(function() {
                            return Object.assign(t.elements.poster.style, {
                                backgroundImage: "url('".concat(e, "')"),
                                backgroundSize: ""
                            }), bt.togglePoster.call(t, !0), e
                        }))
                    },
                    checkPlaying: function(e) {
                        var t = this;
                        we(this.elements.container, this.config.classNames.playing, this.playing), we(this.elements.container, this.config.classNames.paused, this.paused), we(this.elements.container, this.config.classNames.stopped, this.stopped), Array.from(this.elements.buttons.play || []).forEach(function(e) {
                            Object.assign(e, {
                                pressed: t.playing
                            }), e.setAttribute("aria-label", $e(t.playing ? "pause" : "play", t.config))
                        }), ee(e) && "timeupdate" === e.type || bt.toggleControls.call(this)
                    },
                    checkLoading: function(e) {
                        var t = this;
                        this.loading = ["stalled", "waiting"].includes(e.type), clearTimeout(this.timers.loading), this.timers.loading = setTimeout(function() {
                            we(t.elements.container, t.config.classNames.loading, t.loading), bt.toggleControls.call(t)
                        }, this.loading ? 250 : 0)
                    },
                    toggleControls: function(e) {
                        var t = this.elements.controls;
                        if (t && this.config.hideControls) {
                            var n = this.touch && this.lastSeekTime + 2e3 > Date.now();
                            this.toggleControls(Boolean(e || this.loading || this.paused || t.pressed || t.hover || n))
                        }
                    },
                    migrateStyles: function() {
                        var e = this;
                        Object.values(o({}, this.media.style)).filter(function(e) {
                            return !re(e) && Q(e) && e.startsWith("--plyr")
                        }).forEach(function(t) {
                            e.elements.container.style.setProperty(t, e.media.style.getPropertyValue(t)), e.media.style.removeProperty(t)
                        }), re(this.media.style) && this.media.removeAttribute("style")
                    }
                },
                vt = function() {
                    function e(n) {
                        var i = this;
                        t(this, e), a(this, "firstTouch", function() {
                            var e = i.player,
                                t = e.elements;
                            e.touch = !0, we(t.container, e.config.classNames.isTouch, !0)
                        }), a(this, "setTabFocus", function(e) {
                            var t = i.player,
                                n = t.elements;
                            if (clearTimeout(i.focusTimer), "keydown" !== e.type || 9 === e.which) {
                                "keydown" === e.type && (i.lastKeyDown = e.timeStamp);
                                var a, r = e.timeStamp - i.lastKeyDown <= 20;
                                ("focus" !== e.type || r) && (a = t.config.classNames.tabFocus, we(Ce.call(t, ".".concat(a)), a, !1), "focusout" !== e.type && (i.focusTimer = setTimeout(function() {
                                    var e = document.activeElement;
                                    n.container.contains(e) && we(document.activeElement, t.config.classNames.tabFocus, !0)
                                }, 10)))
                            }
                        }), a(this, "global", function() {
                            var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
                                t = i.player;
                            t.config.keyboard.global && xe.call(t, window, "keydown keyup", i.handleKey, e, !1), xe.call(t, document.body, "click", i.toggleMenu, e), Oe.call(t, document.body, "touchstart", i.firstTouch), xe.call(t, document.body, "keydown focus blur focusout", i.setTabFocus, e, !1, !0)
                        }), a(this, "container", function() {
                            var e = i.player,
                                t = e.config,
                                n = e.elements,
                                a = e.timers;
                            !t.keyboard.global && t.keyboard.focused && Ie.call(e, n.container, "keydown keyup", i.handleKey, !1), Ie.call(e, n.container, "mousemove mouseleave touchstart touchmove enterfullscreen exitfullscreen", function(t) {
                                var i = n.controls;
                                i && "enterfullscreen" === t.type && (i.pressed = !1, i.hover = !1);
                                var r = 0;
                                ["touchstart", "touchmove", "mousemove"].includes(t.type) && (bt.toggleControls.call(e, !0), r = e.touch ? 3e3 : 2e3), clearTimeout(a.controls), a.controls = setTimeout(function() {
                                    return bt.toggleControls.call(e, !1)
                                }, r)
                            });
                            var r = function(t) {
                                    if (!t) return Ve.call(e);
                                    var i = n.container.getBoundingClientRect(),
                                        a = i.width,
                                        r = i.height;
                                    return Ve.call(e, "".concat(a, ":").concat(r))
                                },
                                o = function() {
                                    clearTimeout(a.resized), a.resized = setTimeout(r, 50)
                                };
                            Ie.call(e, n.container, "enterfullscreen exitfullscreen", function(t) {
                                var i = e.fullscreen,
                                    a = i.target,
                                    s = i.usingNative;
                                if (a === n.container && (e.isEmbed || !re(e.config.ratio))) {
                                    var c = "enterfullscreen" === t.type,
                                        u = r(c);
                                    u.padding, ! function(t, n, i) {
                                        if (e.isVimeo && !e.config.vimeo.premium) {
                                            var a = e.elements.wrapper.firstChild,
                                                r = l(t, 2)[1],
                                                o = l(Re.call(e), 2),
                                                s = o[0],
                                                c = o[1];
                                            a.style.maxWidth = i ? "".concat(r / c * s, "px") : null, a.style.margin = i ? "0 auto" : null
                                        }
                                    }(u.ratio, 0, c), c && setTimeout(function() {
                                        return se(n.container)
                                    }, 100), s || (c ? Ie.call(e, window, "resize", o) : Le.call(e, window, "resize", o))
                                }
                            })
                        }), a(this, "media", function() {
                            var e = i.player,
                                t = e.elements;
                            if (Ie.call(e, e.media, "timeupdate seeking seeked", function(t) {
                                    return at.timeUpdate.call(e, t)
                                }), Ie.call(e, e.media, "durationchange loadeddata loadedmetadata", function(t) {
                                    return at.durationUpdate.call(e, t)
                                }), Ie.call(e, e.media, "ended", function() {
                                    e.isHTML5 && e.isVideo && e.config.resetOnEnd && (e.restart(), e.pause())
                                }), Ie.call(e, e.media, "progress playing seeking seeked", function(t) {
                                    return at.updateProgress.call(e, t)
                                }), Ie.call(e, e.media, "volumechange", function(t) {
                                    return at.updateVolume.call(e, t)
                                }), Ie.call(e, e.media, "playing play pause ended emptied timeupdate", function(t) {
                                    return bt.checkPlaying.call(e, t)
                                }), Ie.call(e, e.media, "waiting canplay seeked playing", function(t) {
                                    return bt.checkLoading.call(e, t)
                                }), e.supported.ui && e.config.clickToPlay && !e.isAudio) {
                                var n = Ae.call(e, ".".concat(e.config.classNames.video));
                                if (!Z(n)) return;
                                Ie.call(e, t.container, "click", function(a) {
                                    ([t.container, n].includes(a.target) || n.contains(a.target)) && (e.touch && e.config.hideControls || (e.ended ? (i.proxy(a, e.restart, "restart"), i.proxy(a, function() {
                                        qe(e.play())
                                    }, "play")) : i.proxy(a, function() {
                                        qe(e.togglePlay())
                                    }, "play")))
                                })
                            }
                            e.supported.ui && e.config.disableContextMenu && Ie.call(e, t.wrapper, "contextmenu", function(e) {
                                e.preventDefault()
                            }, !1), Ie.call(e, e.media, "volumechange", function() {
                                e.storage.set({
                                    volume: e.volume,
                                    muted: e.muted
                                })
                            }), Ie.call(e, e.media, "ratechange", function() {
                                at.updateSetting.call(e, "speed"), e.storage.set({
                                    speed: e.speed
                                })
                            }), Ie.call(e, e.media, "qualitychange", function(t) {
                                at.updateSetting.call(e, "quality", null, t.detail.quality)
                            }), Ie.call(e, e.media, "ready qualitychange", function() {
                                at.setDownloadUrl.call(e)
                            });
                            var a = e.config.events.concat(["keyup", "keydown"]).join(" ");
                            Ie.call(e, e.media, a, function(n) {
                                var i = n.detail,
                                    a = void 0 === i ? {} : i;
                                "error" === n.type && (a = e.media.error), _e.call(e, t.container, n.type, !0, a)
                            })
                        }), a(this, "proxy", function(e, t, n) {
                            var a = i.player,
                                r = a.config.listeners[n],
                                o = !0;
                            $(r) && (o = r.call(a, e)), !1 !== o && $(t) && t.call(a, e)
                        }), a(this, "bind", function(e, t, n, a) {
                            var r = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4],
                                o = i.player,
                                s = o.config.listeners[a],
                                l = $(s);
                            Ie.call(o, e, t, function(e) {
                                return i.proxy(e, n, a)
                            }, r && !l)
                        }), a(this, "controls", function() {
                            var e = i.player,
                                t = e.elements,
                                n = le.isIE ? "change" : "input";
                            if (t.buttons.play && Array.from(t.buttons.play).forEach(function(t) {
                                    i.bind(t, "click", function() {
                                        qe(e.togglePlay())
                                    }, "play")
                                }), i.bind(t.buttons.restart, "click", e.restart, "restart"), i.bind(t.buttons.rewind, "click", function() {
                                    e.lastSeekTime = Date.now(), e.rewind()
                                }, "rewind"), i.bind(t.buttons.fastForward, "click", function() {
                                    e.lastSeekTime = Date.now(), e.forward()
                                }, "fastForward"), i.bind(t.buttons.mute, "click", function() {
                                    e.muted = !e.muted
                                }, "mute"), i.bind(t.buttons.captions, "click", function() {
                                    return e.toggleCaptions()
                                }), i.bind(t.buttons.download, "click", function() {
                                    _e.call(e, e.media, "download")
                                }, "download"), i.bind(t.buttons.fullscreen, "click", function() {
                                    e.fullscreen.toggle()
                                }, "fullscreen"), i.bind(t.buttons.pip, "click", function() {
                                    e.pip = "toggle"
                                }, "pip"), i.bind(t.buttons.airplay, "click", e.airplay, "airplay"), i.bind(t.buttons.settings, "click", function(t) {
                                    t.stopPropagation(), t.preventDefault(), at.toggleMenu.call(e, t)
                                }, null, !1), i.bind(t.buttons.settings, "keyup", function(t) {
                                    var n = t.which;
                                    [13, 32].includes(n) && (13 !== n ? (t.preventDefault(), t.stopPropagation(), at.toggleMenu.call(e, t)) : at.focusFirstMenuItem.call(e, null, !0))
                                }, null, !1), i.bind(t.settings.menu, "keydown", function(t) {
                                    27 === t.which && at.toggleMenu.call(e, t)
                                }), i.bind(t.inputs.seek, "mousedown mousemove", function(e) {
                                    var n = t.progress.getBoundingClientRect(),
                                        i = 100 / n.width * (e.pageX - n.left);
                                    e.currentTarget.setAttribute("seek-value", i)
                                }), i.bind(t.inputs.seek, "mousedown mouseup keydown keyup touchstart touchend", function(t) {
                                    var n = t.currentTarget,
                                        i = t.keyCode ? t.keyCode : t.which,
                                        a = "play-on-seeked";
                                    if (!te(t) || 39 === i || 37 === i) {
                                        e.lastSeekTime = Date.now();
                                        var r = n.hasAttribute(a),
                                            o = ["mouseup", "touchend", "keyup"].includes(t.type);
                                        r && o ? (n.removeAttribute(a), qe(e.play())) : !o && e.playing && (n.setAttribute(a, ""), e.pause())
                                    }
                                }), le.isIos) {
                                var a = Ce.call(e, 'input[type="range"]');
                                Array.from(a).forEach(function(e) {
                                    return i.bind(e, n, function(e) {
                                        return se(e.target)
                                    })
                                })
                            }
                            i.bind(t.inputs.seek, n, function(t) {
                                var n = t.currentTarget,
                                    i = n.getAttribute("seek-value");
                                re(i) && (i = n.value), n.removeAttribute("seek-value"), e.currentTime = i / n.max * e.duration
                            }, "seek"), i.bind(t.progress, "mouseenter mouseleave mousemove", function(t) {
                                return at.updateSeekTooltip.call(e, t)
                            }), i.bind(t.progress, "mousemove touchmove", function(t) {
                                var n = e.previewThumbnails;
                                n && n.loaded && n.startMove(t)
                            }), i.bind(t.progress, "mouseleave touchend click", function() {
                                var t = e.previewThumbnails;
                                t && t.loaded && t.endMove(!1, !0)
                            }), i.bind(t.progress, "mousedown touchstart", function(t) {
                                var n = e.previewThumbnails;
                                n && n.loaded && n.startScrubbing(t)
                            }), i.bind(t.progress, "mouseup touchend", function(t) {
                                var n = e.previewThumbnails;
                                n && n.loaded && n.endScrubbing(t)
                            }), le.isWebkit && Array.from(Ce.call(e, 'input[type="range"]')).forEach(function(t) {
                                i.bind(t, "input", function(t) {
                                    return at.updateRangeFill.call(e, t.target)
                                })
                            }), e.config.toggleInvert && !Z(t.display.duration) && i.bind(t.display.currentTime, "click", function() {
                                0 !== e.currentTime && (e.config.invertTime = !e.config.invertTime, at.timeUpdate.call(e))
                            }), i.bind(t.inputs.volume, n, function(t) {
                                e.volume = t.target.value
                            }, "volume"), i.bind(t.controls, "mouseenter mouseleave", function(n) {
                                t.controls.hover = !e.touch && "mouseenter" === n.type
                            }), t.fullscreen && Array.from(t.fullscreen.children).filter(function(e) {
                                return !e.contains(t.container)
                            }).forEach(function(n) {
                                i.bind(n, "mouseenter mouseleave", function(n) {
                                    t.controls.hover = !e.touch && "mouseenter" === n.type
                                })
                            }), i.bind(t.controls, "mousedown mouseup touchstart touchend touchcancel", function(e) {
                                t.controls.pressed = ["mousedown", "touchstart"].includes(e.type)
                            }), i.bind(t.controls, "focusin", function() {
                                var n = e.config,
                                    a = e.timers;
                                we(t.controls, n.classNames.noTransition, !0), bt.toggleControls.call(e, !0), setTimeout(function() {
                                    we(t.controls, n.classNames.noTransition, !1)
                                }, 0);
                                var r = i.touch ? 3e3 : 4e3;
                                clearTimeout(a.controls), a.controls = setTimeout(function() {
                                    return bt.toggleControls.call(e, !1)
                                }, r)
                            }), i.bind(t.inputs.volume, "wheel", function(t) {
                                var n = t.webkitDirectionInvertedFromDevice,
                                    i = l([t.deltaX, -t.deltaY].map(function(e) {
                                        return n ? -e : e
                                    }), 2),
                                    a = i[0],
                                    r = i[1],
                                    o = Math.sign(Math.abs(a) > Math.abs(r) ? a : r);
                                e.increaseVolume(o / 50);
                                var s = e.media.volume;
                                (1 === o && s < 1 || -1 === o && s > 0) && t.preventDefault()
                            }, "volume", !1)
                        }), this.player = n, this.lastKey = null, this.focusTimer = null, this.lastKeyDown = null, this.handleKey = this.handleKey.bind(this), this.toggleMenu = this.toggleMenu.bind(this), this.setTabFocus = this.setTabFocus.bind(this), this.firstTouch = this.firstTouch.bind(this)
                    }
                    return i(e, [{
                        key: "handleKey",
                        value: function(e) {
                            var t = this.player,
                                n = t.elements,
                                i = e.keyCode ? e.keyCode : e.which,
                                a = "keydown" === e.type,
                                r = a && i === this.lastKey;
                            if (!(e.altKey || e.ctrlKey || e.metaKey || e.shiftKey) && Y(i))
                                if (a) {
                                    var o = document.activeElement;
                                    if (Z(o)) {
                                        var s = t.config.selectors.editable;
                                        if (o !== n.inputs.seek && Te(o, s)) return;
                                        if (32 === e.which && Te(o, 'button, [role^="menuitem"]')) return
                                    }
                                    switch ([32, 37, 38, 39, 40, 48, 49, 50, 51, 52, 53, 54, 56, 57, 67, 70, 73, 75, 76, 77, 79].includes(i) && (e.preventDefault(), e.stopPropagation()), i) {
                                        case 48:
                                        case 49:
                                        case 50:
                                        case 51:
                                        case 52:
                                        case 53:
                                        case 54:
                                        case 55:
                                        case 56:
                                        case 57:
                                            r || (t.currentTime = t.duration / 10 * (i - 48));
                                            break;
                                        case 32:
                                        case 75:
                                            r || qe(t.togglePlay());
                                            break;
                                        case 38:
                                            t.increaseVolume(.1);
                                            break;
                                        case 40:
                                            t.decreaseVolume(.1);
                                            break;
                                        case 77:
                                            r || (t.muted = !t.muted);
                                            break;
                                        case 39:
                                            t.forward();
                                            break;
                                        case 37:
                                            t.rewind();
                                            break;
                                        case 70:
                                            t.fullscreen.toggle();
                                            break;
                                        case 67:
                                            r || t.toggleCaptions();
                                            break;
                                        case 76:
                                            t.loop = !t.loop
                                    }
                                    27 === i && !t.fullscreen.usingNative && t.fullscreen.active && t.fullscreen.toggle(), this.lastKey = i
                                } else this.lastKey = null
                        }
                    }, {
                        key: "toggleMenu",
                        value: function(e) {
                            at.toggleMenu.call(this.player, e)
                        }
                    }]), e
                }();
            "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0 !== global || "undefined" != typeof self && self;
            var wt = function(e, t) {
                return function(e, t) {
                    e.exports = function() {
                        var e = function() {},
                            t = {},
                            n = {},
                            i = {};

                        function r(e, t) {
                            if (e) {
                                var a = i[e];
                                if (n[e] = t, a)
                                    for (; a.length;) a[0](e, t), a.splice(0, 1)
                            }
                        }

                        function o(t, n) {
                            t.call && (t = {
                                success: t
                            }), n.length ? (t.error || e)(n) : (t.success || e)(t)
                        }

                        function s(t, n, i, a) {
                            var r, o, l = document,
                                c = i.async,
                                u = (i.numRetries || 0) + 1,
                                d = i.before || e,
                                h = t.replace(/[\?|#].*$/, ""),
                                m = t.replace(/^(css|img)!/, "");
                            a = a || 0, /(^css!|\.css$)/.test(h) ? ((o = l.createElement("link")).rel = "stylesheet", o.href = m, (r = "hideFocus" in o) && o.relList && (r = 0, o.rel = "preload", o.as = "style")) : /(^img!|\.(png|gif|jpg|svg|webp)$)/.test(h) ? (o = l.createElement("img")).src = m : ((o = l.createElement("script")).src = t, o.async = void 0 === c || c), o.onload = o.onerror = o.onbeforeload = function(e) {
                                var l = e.type[0];
                                if (r) try {
                                    o.sheet.cssText.length || (l = "e")
                                } catch (e) {
                                    18 != e.code && (l = "e")
                                }
                                if ("e" == l) {
                                    if ((a += 1) < u) return s(t, n, i, a)
                                } else if ("preload" == o.rel && "style" == o.as) return o.rel = "stylesheet";
                                n(t, l, e.defaultPrevented)
                            }, !1 !== d(t, o) && l.head.appendChild(o)
                        }

                        function l(e, t, n) {
                            var i, a, r = (e = e.push ? e : [e]).length,
                                o = r,
                                l = [];
                            for (i = function(e, n, i) {
                                    if ("e" == n && l.push(e), "b" == n) {
                                        if (!i) return;
                                        l.push(e)
                                    }--r || t(l)
                                }, a = 0; a < o; a++) s(e[a], i, n)
                        }

                        function c(e, n, i) {
                            var a, s;
                            if (n && n.trim && (a = n), s = (a ? i : n) || {}, a) {
                                if (a in t) throw "LoadJS";
                                t[a] = !0
                            }

                            function c(t, n) {
                                l(e, function(e) {
                                    o(s, e), t && o({
                                        success: t,
                                        error: n
                                    }, e), r(a, e)
                                }, s)
                            }
                            if (s.returnPromise) return new Promise(c);
                            c()
                        }
                        return c.ready = function(e, t) {
                            return function(e, t) {
                                var a, r, o, s = [],
                                    l = (e = e.push ? e : [e]).length,
                                    c = l;
                                for (a = function(e, n) {
                                        n.length && s.push(e), --c || t(s)
                                    }; l--;) r = e[l], (o = n[r]) ? a(r, o) : (i[r] = i[r] || []).push(a)
                            }(e, function(e) {
                                o(t, e)
                            }), c
                        }, c.done = function(e) {
                            r(e, [])
                        }, c.reset = function() {
                            t = {}, n = {}, i = {}
                        }, c.isDefined = function(e) {
                            return e in t
                        }, c
                    }()
                }(t = {
                    exports: {}
                }), t.exports
            }();

            function kt(e) {
                return new Promise(function(t, n) {
                    wt(e, {
                        success: t,
                        error: n
                    })
                })
            }

            function Tt(e) {
                e && !this.embed.hasPlayed && (this.embed.hasPlayed = !0), this.media.paused === e && (this.media.paused = !e, _e.call(this, this.media, e ? "play" : "pause"))
            }
            var Ct = {
                setup: function() {
                    var e = this;
                    we(e.elements.wrapper, e.config.classNames.embed, !0), e.options.speed = e.config.speed.options, Ve.call(e), K(window.Vimeo) ? Ct.ready.call(e) : kt(e.config.urls.vimeo.sdk).then(function() {
                        Ct.ready.call(e)
                    }).catch(function(t) {
                        e.debug.warn("Vimeo SDK (player.js) failed to load", t)
                    })
                },
                ready: function() {
                    var e = this,
                        t = this,
                        n = t.config.vimeo,
                        i = n.premium,
                        a = n.referrerPolicy,
                        r = function(e, t) {
                            if (null == e) return {};
                            var n, i, a = function(e, t) {
                                if (null == e) return {};
                                var n, i, a = {},
                                    r = Object.keys(e);
                                for (i = 0; i < r.length; i++) n = r[i], t.indexOf(n) >= 0 || (a[n] = e[n]);
                                return a
                            }(e, t);
                            if (Object.getOwnPropertySymbols) {
                                var r = Object.getOwnPropertySymbols(e);
                                for (i = 0; i < r.length; i++) n = r[i], t.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(e, n) && (a[n] = e[n])
                            }
                            return a
                        }(n, ["premium", "referrerPolicy"]);
                    i && Object.assign(r, {
                        controls: !1,
                        sidedock: !1
                    });
                    var c = ot(o({
                            loop: t.config.loop.active,
                            autoplay: t.autoplay,
                            muted: t.muted,
                            gesture: "media",
                            playsinline: !this.config.fullscreen.iosNative
                        }, r)),
                        u = t.media.getAttribute("src");
                    re(u) && (u = t.media.getAttribute(t.config.attributes.embed.id));
                    var d, h = re(d = u) ? null : Y(Number(d)) ? d : d.match(/^.*(vimeo.com\/|video\/)(\d+).*/) ? RegExp.$2 : d,
                        m = me("iframe"),
                        p = We(t.config.urls.vimeo.iframe, h, c);
                    if (m.setAttribute("src", p), m.setAttribute("allowfullscreen", ""), m.setAttribute("allow", ["autoplay", "fullscreen", "picture-in-picture"].join("; ")), re(a) || m.setAttribute("referrerPolicy", a), i || !n.customControls) m.setAttribute("data-poster", t.poster), t.media = ye(m, t.media);
                    else {
                        var f = me("div", {
                            class: t.config.classNames.embedContainer,
                            "data-poster": t.poster
                        });
                        f.appendChild(m), t.media = ye(f, t.media)
                    }
                    n.customControls || Ge(We(t.config.urls.vimeo.api, p)).then(function(e) {
                        !re(e) && e.thumbnail_url && bt.setPoster.call(t, e.thumbnail_url).catch(function() {})
                    }), t.embed = new window.Vimeo.Player(m, {
                        autopause: t.config.autopause,
                        muted: t.muted
                    }), t.media.paused = !0, t.media.currentTime = 0, t.supported.ui && t.embed.disableTextTrack(), t.media.play = function() {
                        return Tt.call(t, !0), t.embed.play()
                    }, t.media.pause = function() {
                        return Tt.call(t, !1), t.embed.pause()
                    }, t.media.stop = function() {
                        t.pause(), t.currentTime = 0
                    };
                    var g = t.media.currentTime;
                    Object.defineProperty(t.media, "currentTime", {
                        get: function() {
                            return g
                        },
                        set: function(e) {
                            var n = t.embed,
                                i = t.media,
                                a = t.paused,
                                r = t.volume,
                                o = a && !n.hasPlayed;
                            i.seeking = !0, _e.call(t, i, "seeking"), Promise.resolve(o && n.setVolume(0)).then(function() {
                                return n.setCurrentTime(e)
                            }).then(function() {
                                return o && n.pause()
                            }).then(function() {
                                return o && n.setVolume(r)
                            }).catch(function() {})
                        }
                    });
                    var y = t.config.speed.selected;
                    Object.defineProperty(t.media, "playbackRate", {
                        get: function() {
                            return y
                        },
                        set: function(e) {
                            t.embed.setPlaybackRate(e).then(function() {
                                y = e, _e.call(t, t.media, "ratechange")
                            }).catch(function() {
                                t.options.speed = [1]
                            })
                        }
                    });
                    var b = t.config.volume;
                    Object.defineProperty(t.media, "volume", {
                        get: function() {
                            return b
                        },
                        set: function(e) {
                            t.embed.setVolume(e).then(function() {
                                b = e, _e.call(t, t.media, "volumechange")
                            })
                        }
                    });
                    var v = t.config.muted;
                    Object.defineProperty(t.media, "muted", {
                        get: function() {
                            return v
                        },
                        set: function(e) {
                            var n = !!X(e) && e;
                            t.embed.setVolume(n ? 0 : t.config.volume).then(function() {
                                v = n, _e.call(t, t.media, "volumechange")
                            })
                        }
                    });
                    var w, k = t.config.loop;
                    Object.defineProperty(t.media, "loop", {
                        get: function() {
                            return k
                        },
                        set: function(e) {
                            var n = X(e) ? e : t.config.loop.active;
                            t.embed.setLoop(n).then(function() {
                                k = n
                            })
                        }
                    }), t.embed.getVideoUrl().then(function(e) {
                        w = e, at.setDownloadUrl.call(t)
                    }).catch(function(t) {
                        e.debug.warn(t)
                    }), Object.defineProperty(t.media, "currentSrc", {
                        get: function() {
                            return w
                        }
                    }), Object.defineProperty(t.media, "ended", {
                        get: function() {
                            return t.currentTime === t.duration
                        }
                    }), Promise.all([t.embed.getVideoWidth(), t.embed.getVideoHeight()]).then(function(n) {
                        var i = l(n, 2),
                            a = i[0],
                            r = i[1];
                        t.embed.ratio = [a, r], Ve.call(e)
                    }), t.embed.setAutopause(t.config.autopause).then(function(e) {
                        t.config.autopause = e
                    }), t.embed.getVideoTitle().then(function(n) {
                        t.config.title = n, bt.setTitle.call(e)
                    }), t.embed.getCurrentTime().then(function(e) {
                        g = e, _e.call(t, t.media, "timeupdate")
                    }), t.embed.getDuration().then(function(e) {
                        t.media.duration = e, _e.call(t, t.media, "durationchange")
                    }), t.embed.getTextTracks().then(function(e) {
                        t.media.textTracks = e, st.setup.call(t)
                    }), t.embed.on("cuechange", function(e) {
                        var n = e.cues,
                            i = (void 0 === n ? [] : n).map(function(e) {
                                return function(e) {
                                    var t = document.createDocumentFragment(),
                                        n = document.createElement("div");
                                    return t.appendChild(n), n.innerHTML = e, t.firstChild.innerText
                                }(e.text)
                            });
                        st.updateCues.call(t, i)
                    }), t.embed.on("loaded", function() {
                        t.embed.getPaused().then(function(e) {
                            Tt.call(t, !e), e || _e.call(t, t.media, "playing")
                        }), Z(t.embed.element) && t.supported.ui && t.embed.element.setAttribute("tabindex", -1)
                    }), t.embed.on("bufferstart", function() {
                        _e.call(t, t.media, "waiting")
                    }), t.embed.on("bufferend", function() {
                        _e.call(t, t.media, "playing")
                    }), t.embed.on("play", function() {
                        Tt.call(t, !0), _e.call(t, t.media, "playing")
                    }), t.embed.on("pause", function() {
                        Tt.call(t, !1)
                    }), t.embed.on("timeupdate", function(e) {
                        t.media.seeking = !1, g = e.seconds, _e.call(t, t.media, "timeupdate")
                    }), t.embed.on("progress", function(e) {
                        t.media.buffered = e.percent, _e.call(t, t.media, "progress"), 1 === parseInt(e.percent, 10) && _e.call(t, t.media, "canplaythrough"), t.embed.getDuration().then(function(e) {
                            e !== t.media.duration && (t.media.duration = e, _e.call(t, t.media, "durationchange"))
                        })
                    }), t.embed.on("seeked", function() {
                        t.media.seeking = !1, _e.call(t, t.media, "seeked")
                    }), t.embed.on("ended", function() {
                        t.media.paused = !0, _e.call(t, t.media, "ended")
                    }), t.embed.on("error", function(e) {
                        t.media.error = e, _e.call(t, t.media, "error")
                    }), n.customControls && setTimeout(function() {
                        return bt.build.call(t)
                    }, 0)
                }
            };

            function At(e) {
                e && !this.embed.hasPlayed && (this.embed.hasPlayed = !0), this.media.paused === e && (this.media.paused = !e, _e.call(this, this.media, e ? "play" : "pause"))
            }
            var Lt, Pt = {
                    setup: function() {
                        var e = this;
                        if (we(this.elements.wrapper, this.config.classNames.embed, !0), K(window.YT) && $(window.YT.Player)) Pt.ready.call(this);
                        else {
                            var t = window.onYouTubeIframeAPIReady;
                            window.onYouTubeIframeAPIReady = function() {
                                $(t) && t(), Pt.ready.call(e)
                            }, kt(this.config.urls.youtube.sdk).catch(function(t) {
                                e.debug.warn("YouTube API failed to load", t)
                            })
                        }
                    },
                    getTitle: function(e) {
                        var t = this;
                        Ge(We(this.config.urls.youtube.api, e)).then(function(e) {
                            if (K(e)) {
                                var n = e.title,
                                    i = e.height,
                                    a = e.width;
                                t.config.title = n, bt.setTitle.call(t), t.embed.ratio = [a, i]
                            }
                            Ve.call(t)
                        }).catch(function() {
                            Ve.call(t)
                        })
                    },
                    ready: function() {
                        var e = this,
                            t = e.config.youtube,
                            n = e.media && e.media.getAttribute("id");
                        if (re(n) || !n.startsWith("youtube-")) {
                            var i = e.media.getAttribute("src");
                            re(i) && (i = e.media.getAttribute(this.config.attributes.embed.id));
                            var a, r, o = re(a = i) ? null : a.match(/^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/) ? RegExp.$2 : a,
                                s = me("div", {
                                    id: (r = e.provider, "".concat(r, "-").concat(Math.floor(1e4 * Math.random()))),
                                    "data-poster": t.customControls ? e.poster : void 0
                                });
                            if (e.media = ye(s, e.media), t.customControls) {
                                var l = function(e) {
                                    return "https://i.ytimg.com/vi/".concat(o, "/").concat(e, "default.jpg")
                                };
                                yt(l("maxres"), 121).catch(function() {
                                    return yt(l("sd"), 121)
                                }).catch(function() {
                                    return yt(l("hq"))
                                }).then(function(t) {
                                    return bt.setPoster.call(e, t.src)
                                }).then(function(t) {
                                    t.includes("maxres") || (e.elements.poster.style.backgroundSize = "cover")
                                }).catch(function() {})
                            }
                            e.embed = new window.YT.Player(e.media, {
                                videoId: o,
                                host: function(e) {
                                    return e.noCookie ? "https://www.youtube-nocookie.com" : "http:" === window.location.protocol ? "http://www.youtube.com" : void 0
                                }(t),
                                playerVars: ue({}, {
                                    autoplay: e.config.autoplay ? 1 : 0,
                                    hl: e.config.hl,
                                    controls: e.supported.ui && t.customControls ? 0 : 1,
                                    disablekb: 1,
                                    playsinline: e.config.fullscreen.iosNative ? 0 : 1,
                                    cc_load_policy: e.captions.active ? 1 : 0,
                                    cc_lang_pref: e.config.captions.language,
                                    widget_referrer: window ? window.location.href : null
                                }, t),
                                events: {
                                    onError: function(t) {
                                        if (!e.media.error) {
                                            var n = t.data,
                                                i = {
                                                    2: "The request contains an invalid parameter value. For example, this error occurs if you specify a video ID that does not have 11 characters, or if the video ID contains invalid characters, such as exclamation points or asterisks.",
                                                    5: "The requested content cannot be played in an HTML5 player or another error related to the HTML5 player has occurred.",
                                                    100: "The video requested was not found. This error occurs when a video has been removed (for any reason) or has been marked as private.",
                                                    101: "The owner of the requested video does not allow it to be played in embedded players.",
                                                    150: "The owner of the requested video does not allow it to be played in embedded players."
                                                } [n] || "An unknown error occured";
                                            e.media.error = {
                                                code: n,
                                                message: i
                                            }, _e.call(e, e.media, "error")
                                        }
                                    },
                                    onPlaybackRateChange: function(t) {
                                        var n = t.target;
                                        e.media.playbackRate = n.getPlaybackRate(), _e.call(e, e.media, "ratechange")
                                    },
                                    onReady: function(n) {
                                        if (!$(e.media.play)) {
                                            var i = n.target;
                                            Pt.getTitle.call(e, o), e.media.play = function() {
                                                At.call(e, !0), i.playVideo()
                                            }, e.media.pause = function() {
                                                At.call(e, !1), i.pauseVideo()
                                            }, e.media.stop = function() {
                                                i.stopVideo()
                                            }, e.media.duration = i.getDuration(), e.media.paused = !0, e.media.currentTime = 0, Object.defineProperty(e.media, "currentTime", {
                                                get: function() {
                                                    return Number(i.getCurrentTime())
                                                },
                                                set: function(t) {
                                                    e.paused && !e.embed.hasPlayed && e.embed.mute(), e.media.seeking = !0, _e.call(e, e.media, "seeking"), i.seekTo(t)
                                                }
                                            }), Object.defineProperty(e.media, "playbackRate", {
                                                get: function() {
                                                    return i.getPlaybackRate()
                                                },
                                                set: function(e) {
                                                    i.setPlaybackRate(e)
                                                }
                                            });
                                            var a = e.config.volume;
                                            Object.defineProperty(e.media, "volume", {
                                                get: function() {
                                                    return a
                                                },
                                                set: function(t) {
                                                    a = t, i.setVolume(100 * a), _e.call(e, e.media, "volumechange")
                                                }
                                            });
                                            var r = e.config.muted;
                                            Object.defineProperty(e.media, "muted", {
                                                get: function() {
                                                    return r
                                                },
                                                set: function(t) {
                                                    var n = X(t) ? t : r;
                                                    r = n, i[n ? "mute" : "unMute"](), i.setVolume(100 * a), _e.call(e, e.media, "volumechange")
                                                }
                                            }), Object.defineProperty(e.media, "currentSrc", {
                                                get: function() {
                                                    return i.getVideoUrl()
                                                }
                                            }), Object.defineProperty(e.media, "ended", {
                                                get: function() {
                                                    return e.currentTime === e.duration
                                                }
                                            });
                                            var s = i.getAvailablePlaybackRates();
                                            e.options.speed = s.filter(function(t) {
                                                return e.config.speed.options.includes(t)
                                            }), e.supported.ui && t.customControls && e.media.setAttribute("tabindex", -1), _e.call(e, e.media, "timeupdate"), _e.call(e, e.media, "durationchange"), clearInterval(e.timers.buffering), e.timers.buffering = setInterval(function() {
                                                e.media.buffered = i.getVideoLoadedFraction(), (null === e.media.lastBuffered || e.media.lastBuffered < e.media.buffered) && _e.call(e, e.media, "progress"), e.media.lastBuffered = e.media.buffered, 1 === e.media.buffered && (clearInterval(e.timers.buffering), _e.call(e, e.media, "canplaythrough"))
                                            }, 200), t.customControls && setTimeout(function() {
                                                return bt.build.call(e)
                                            }, 50)
                                        }
                                    },
                                    onStateChange: function(n) {
                                        var i = n.target;
                                        switch (clearInterval(e.timers.playing), e.media.seeking && [1, 2].includes(n.data) && (e.media.seeking = !1, _e.call(e, e.media, "seeked")), n.data) {
                                            case -1:
                                                _e.call(e, e.media, "timeupdate"), e.media.buffered = i.getVideoLoadedFraction(), _e.call(e, e.media, "progress");
                                                break;
                                            case 0:
                                                At.call(e, !1), e.media.loop ? (i.stopVideo(), i.playVideo()) : _e.call(e, e.media, "ended");
                                                break;
                                            case 1:
                                                t.customControls && !e.config.autoplay && e.media.paused && !e.embed.hasPlayed ? e.media.pause() : (At.call(e, !0), _e.call(e, e.media, "playing"), e.timers.playing = setInterval(function() {
                                                    _e.call(e, e.media, "timeupdate")
                                                }, 50), e.media.duration !== i.getDuration() && (e.media.duration = i.getDuration(), _e.call(e, e.media, "durationchange")));
                                                break;
                                            case 2:
                                                e.muted || e.embed.unMute(), At.call(e, !1);
                                                break;
                                            case 3:
                                                _e.call(e, e.media, "waiting")
                                        }
                                        _e.call(e, e.elements.container, "statechange", !1, {
                                            code: n.data
                                        })
                                    }
                                }
                            })
                        }
                    }
                },
                Et = {
                    setup: function() {
                        this.media ? (we(this.elements.container, this.config.classNames.type.replace("{0}", this.type), !0), we(this.elements.container, this.config.classNames.provider.replace("{0}", this.provider), !0), this.isEmbed && we(this.elements.container, this.config.classNames.type.replace("{0}", "video"), !0), this.isVideo && (this.elements.wrapper = me("div", {
                            class: this.config.classNames.video
                        }), de(this.media, this.elements.wrapper), this.elements.poster = me("div", {
                            class: this.config.classNames.poster,
                            hidden: ""
                        }), this.elements.wrapper.appendChild(this.elements.poster)), this.isHTML5 ? Be.setup.call(this) : this.isYouTube ? Pt.setup.call(this) : this.isVimeo && Ct.setup.call(this)) : this.debug.warn("No media element found!")
                    }
                },
                Nt = function() {
                    function e(n) {
                        var i = this;
                        t(this, e), a(this, "load", function() {
                            i.enabled && (K(window.google) && K(window.google.ima) ? i.ready() : kt(i.player.config.urls.googleIMA.sdk).then(function() {
                                i.ready()
                            }).catch(function() {
                                i.trigger("error", new Error("Google IMA SDK failed to load"))
                            }))
                        }), a(this, "ready", function() {
                            var e;
                            i.enabled || ((e = i).manager && e.manager.destroy(), e.elements.displayContainer && e.elements.displayContainer.destroy(), e.elements.container.remove()), i.startSafetyTimer(12e3, "ready()"), i.managerPromise.then(function() {
                                i.clearSafetyTimer("onAdsManagerLoaded()")
                            }), i.listeners(), i.setupIMA()
                        }), a(this, "setupIMA", function() {
                            i.elements.container = me("div", {
                                class: i.player.config.classNames.ads
                            }), i.player.elements.container.appendChild(i.elements.container), google.ima.settings.setVpaidMode(google.ima.ImaSdkSettings.VpaidMode.ENABLED), google.ima.settings.setLocale(i.player.config.ads.language), google.ima.settings.setDisableCustomPlaybackForIOS10Plus(i.player.config.playsinline), i.elements.displayContainer = new google.ima.AdDisplayContainer(i.elements.container, i.player.media), i.loader = new google.ima.AdsLoader(i.elements.displayContainer), i.loader.addEventListener(google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED, function(e) {
                                return i.onAdsManagerLoaded(e)
                            }, !1), i.loader.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, function(e) {
                                return i.onAdError(e)
                            }, !1), i.requestAds()
                        }), a(this, "requestAds", function() {
                            var e = i.player.elements.container;
                            try {
                                var t = new google.ima.AdsRequest;
                                t.adTagUrl = i.tagUrl, t.linearAdSlotWidth = e.offsetWidth, t.linearAdSlotHeight = e.offsetHeight, t.nonLinearAdSlotWidth = e.offsetWidth, t.nonLinearAdSlotHeight = e.offsetHeight, t.forceNonLinearFullSlot = !1, t.setAdWillPlayMuted(!i.player.muted), i.loader.requestAds(t)
                            } catch (e) {
                                i.onAdError(e)
                            }
                        }), a(this, "pollCountdown", function() {
                            if (!(arguments.length > 0 && void 0 !== arguments[0] && arguments[0])) return clearInterval(i.countdownTimer), void i.elements.container.removeAttribute("data-badge-text");
                            i.countdownTimer = setInterval(function() {
                                var e = it(Math.max(i.manager.getRemainingTime(), 0)),
                                    t = "".concat($e("advertisement", i.player.config), " - ").concat(e);
                                i.elements.container.setAttribute("data-badge-text", t)
                            }, 100)
                        }), a(this, "onAdsManagerLoaded", function(e) {
                            if (i.enabled) {
                                var t = new google.ima.AdsRenderingSettings;
                                t.restoreCustomPlaybackStateOnAdBreakComplete = !0, t.enablePreloading = !0, i.manager = e.getAdsManager(i.player, t), i.cuePoints = i.manager.getCuePoints(), i.manager.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, function(e) {
                                    return i.onAdError(e)
                                }), Object.keys(google.ima.AdEvent.Type).forEach(function(e) {
                                    i.manager.addEventListener(google.ima.AdEvent.Type[e], function(e) {
                                        return i.onAdEvent(e)
                                    })
                                }), i.trigger("loaded")
                            }
                        }), a(this, "addCuePoints", function() {
                            re(i.cuePoints) || i.cuePoints.forEach(function(e) {
                                if (0 !== e && -1 !== e && e < i.player.duration) {
                                    var t = i.player.elements.progress;
                                    if (Z(t)) {
                                        var n = 100 / i.player.duration * e,
                                            a = me("span", {
                                                class: i.player.config.classNames.cues
                                            });
                                        a.style.left = "".concat(n.toString(), "%"), t.appendChild(a)
                                    }
                                }
                            })
                        }), a(this, "onAdEvent", function(e) {
                            var t = i.player.elements.container,
                                n = e.getAd(),
                                a = e.getAdData();
                            switch (function(e) {
                                    _e.call(i.player, i.player.media, "ads".concat(e.replace(/_/g, "").toLowerCase()))
                                }(e.type), e.type) {
                                case google.ima.AdEvent.Type.LOADED:
                                    i.trigger("loaded"), i.pollCountdown(!0), n.isLinear() || (n.width = t.offsetWidth, n.height = t.offsetHeight);
                                    break;
                                case google.ima.AdEvent.Type.STARTED:
                                    i.manager.setVolume(i.player.volume);
                                    break;
                                case google.ima.AdEvent.Type.ALL_ADS_COMPLETED:
                                    i.player.ended ? i.loadAds() : i.loader.contentComplete();
                                    break;
                                case google.ima.AdEvent.Type.CONTENT_PAUSE_REQUESTED:
                                    i.pauseContent();
                                    break;
                                case google.ima.AdEvent.Type.CONTENT_RESUME_REQUESTED:
                                    i.pollCountdown(), i.resumeContent();
                                    break;
                                case google.ima.AdEvent.Type.LOG:
                                    a.adError && i.player.debug.warn("Non-fatal ad error: ".concat(a.adError.getMessage()))
                            }
                        }), a(this, "onAdError", function(e) {
                            i.cancel(), i.player.debug.warn("Ads error", e)
                        }), a(this, "listeners", function() {
                            var e, t = i.player.elements.container;
                            i.player.on("canplay", function() {
                                i.addCuePoints()
                            }), i.player.on("ended", function() {
                                i.loader.contentComplete()
                            }), i.player.on("timeupdate", function() {
                                e = i.player.currentTime
                            }), i.player.on("seeked", function() {
                                var t = i.player.currentTime;
                                re(i.cuePoints) || i.cuePoints.forEach(function(n, a) {
                                    e < n && n < t && (i.manager.discardAdBreak(), i.cuePoints.splice(a, 1))
                                })
                            }), window.addEventListener("resize", function() {
                                i.manager && i.manager.resize(t.offsetWidth, t.offsetHeight, google.ima.ViewMode.NORMAL)
                            })
                        }), a(this, "play", function() {
                            var e = i.player.elements.container;
                            i.managerPromise || i.resumeContent(), i.managerPromise.then(function() {
                                i.manager.setVolume(i.player.volume), i.elements.displayContainer.initialize();
                                try {
                                    i.initialized || (i.manager.init(e.offsetWidth, e.offsetHeight, google.ima.ViewMode.NORMAL), i.manager.start()), i.initialized = !0
                                } catch (e) {
                                    i.onAdError(e)
                                }
                            }).catch(function() {})
                        }), a(this, "resumeContent", function() {
                            i.elements.container.style.zIndex = "", i.playing = !1, qe(i.player.media.play())
                        }), a(this, "pauseContent", function() {
                            i.elements.container.style.zIndex = 3, i.playing = !0, i.player.media.pause()
                        }), a(this, "cancel", function() {
                            i.initialized && i.resumeContent(), i.trigger("error"), i.loadAds()
                        }), a(this, "loadAds", function() {
                            i.managerPromise.then(function() {
                                i.manager && i.manager.destroy(), i.managerPromise = new Promise(function(e) {
                                    i.on("loaded", e), i.player.debug.log(i.manager)
                                }), i.initialized = !1, i.requestAds()
                            }).catch(function() {})
                        }), a(this, "trigger", function(e) {
                            for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), a = 1; a < t; a++) n[a - 1] = arguments[a];
                            var r = i.events[e];
                            J(r) && r.forEach(function(e) {
                                $(e) && e.apply(i, n)
                            })
                        }), a(this, "on", function(e, t) {
                            return J(i.events[e]) || (i.events[e] = []), i.events[e].push(t), i
                        }), a(this, "startSafetyTimer", function(e, t) {
                            i.player.debug.log("Safety timer invoked from: ".concat(t)), i.safetyTimer = setTimeout(function() {
                                i.cancel(), i.clearSafetyTimer("startSafetyTimer()")
                            }, e)
                        }), a(this, "clearSafetyTimer", function(e) {
                            z(i.safetyTimer) || (i.player.debug.log("Safety timer cleared from: ".concat(e)), clearTimeout(i.safetyTimer), i.safetyTimer = null)
                        }), this.player = n, this.config = n.config.ads, this.playing = !1, this.initialized = !1, this.elements = {
                            container: null,
                            displayContainer: null
                        }, this.manager = null, this.loader = null, this.cuePoints = null, this.events = {}, this.safetyTimer = null, this.countdownTimer = null, this.managerPromise = new Promise(function(e, t) {
                            i.on("loaded", e), i.on("error", t)
                        }), this.load()
                    }
                    return i(e, [{
                        key: "enabled",
                        get: function() {
                            var e = this.config;
                            return this.player.isHTML5 && this.player.isVideo && e.enabled && (!re(e.publisherId) || ae(e.tagUrl))
                        }
                    }, {
                        key: "tagUrl",
                        get: function() {
                            var e = this.config;
                            if (ae(e.tagUrl)) return e.tagUrl;
                            var t = {
                                AV_PUBLISHERID: "58c25bb0073ef448b1087ad6",
                                AV_CHANNELID: "5a0458dc28a06145e4519d21",
                                AV_URL: window.location.hostname,
                                cb: Date.now(),
                                AV_WIDTH: 640,
                                AV_HEIGHT: 480,
                                AV_CDIM2: e.publisherId
                            };
                            return "".concat("https://go.aniview.com/api/adserver6/vast/", "?").concat(ot(t))
                        }
                    }]), e
                }(),
                Mt = function(e, t) {
                    var n = {};
                    return e > t.width / t.height ? (n.width = t.width, n.height = 1 / e * t.width) : (n.height = t.height, n.width = e * t.height), n
                },
                xt = function() {
                    function e(n) {
                        var i = this;
                        t(this, e), a(this, "load", function() {
                            i.player.elements.display.seekTooltip && (i.player.elements.display.seekTooltip.hidden = i.enabled), i.enabled && i.getThumbnails().then(function() {
                                i.enabled && (i.render(), i.determineContainerAutoSizing(), i.loaded = !0)
                            })
                        }), a(this, "getThumbnails", function() {
                            return new Promise(function(e) {
                                var t = i.player.config.previewThumbnails.src;
                                if (re(t)) throw new Error("Missing previewThumbnails.src config attribute");
                                var n = function() {
                                    i.thumbnails.sort(function(e, t) {
                                        return e.height - t.height
                                    }), i.player.debug.log("Preview thumbnails", i.thumbnails), e()
                                };
                                if ($(t)) t(function(e) {
                                    i.thumbnails = e, n()
                                });
                                else {
                                    var a = (Q(t) ? [t] : t).map(function(e) {
                                        return i.getThumbnail(e)
                                    });
                                    Promise.all(a).then(n)
                                }
                            })
                        }), a(this, "getThumbnail", function(e) {
                            return new Promise(function(t) {
                                Ge(e).then(function(n) {
                                    var a, r, o = {
                                        frames: (a = n, r = [], a.split(/\r\n\r\n|\n\n|\r\r/).forEach(function(e) {
                                            var t = {};
                                            e.split(/\r\n|\n|\r/).forEach(function(e) {
                                                if (Y(t.startTime)) {
                                                    if (!re(e.trim()) && re(t.text)) {
                                                        var n = e.trim().split("#xywh="),
                                                            i = l(n, 1);
                                                        if (t.text = i[0], n[1]) {
                                                            var a = l(n[1].split(","), 4);
                                                            t.x = a[0], t.y = a[1], t.w = a[2], t.h = a[3]
                                                        }
                                                    }
                                                } else {
                                                    var r = e.match(/([0-9]{2})?:?([0-9]{2}):([0-9]{2}).([0-9]{2,3})( ?--> ?)([0-9]{2})?:?([0-9]{2}):([0-9]{2}).([0-9]{2,3})/);
                                                    r && (t.startTime = 60 * Number(r[1] || 0) * 60 + 60 * Number(r[2]) + Number(r[3]) + Number("0.".concat(r[4])), t.endTime = 60 * Number(r[6] || 0) * 60 + 60 * Number(r[7]) + Number(r[8]) + Number("0.".concat(r[9])))
                                                }
                                            }), t.text && r.push(t)
                                        }), r),
                                        height: null,
                                        urlPrefix: ""
                                    };
                                    o.frames[0].text.startsWith("/") || o.frames[0].text.startsWith("http://") || o.frames[0].text.startsWith("https://") || (o.urlPrefix = e.substring(0, e.lastIndexOf("/") + 1));
                                    var s = new Image;
                                    s.onload = function() {
                                        o.height = s.naturalHeight, o.width = s.naturalWidth, i.thumbnails.push(o), t()
                                    }, s.src = o.urlPrefix + o.frames[0].text
                                })
                            })
                        }), a(this, "startMove", function(e) {
                            if (i.loaded && ee(e) && ["touchmove", "mousemove"].includes(e.type) && i.player.media.duration) {
                                if ("touchmove" === e.type) i.seekTime = i.player.media.duration * (i.player.elements.inputs.seek.value / 100);
                                else {
                                    var t = i.player.elements.progress.getBoundingClientRect(),
                                        n = 100 / t.width * (e.pageX - t.left);
                                    i.seekTime = i.player.media.duration * (n / 100), i.seekTime < 0 && (i.seekTime = 0), i.seekTime > i.player.media.duration - 1 && (i.seekTime = i.player.media.duration - 1), i.mousePosX = e.pageX, i.elements.thumb.time.innerText = it(i.seekTime)
                                }
                                i.showImageAtCurrentTime()
                            }
                        }), a(this, "endMove", function() {
                            i.toggleThumbContainer(!1, !0)
                        }), a(this, "startScrubbing", function(e) {
                            (z(e.button) || !1 === e.button || 0 === e.button) && (i.mouseDown = !0, i.player.media.duration && (i.toggleScrubbingContainer(!0), i.toggleThumbContainer(!1, !0), i.showImageAtCurrentTime()))
                        }), a(this, "endScrubbing", function() {
                            i.mouseDown = !1, Math.ceil(i.lastTime) === Math.ceil(i.player.media.currentTime) ? i.toggleScrubbingContainer(!1) : Oe.call(i.player, i.player.media, "timeupdate", function() {
                                i.mouseDown || i.toggleScrubbingContainer(!1)
                            })
                        }), a(this, "listeners", function() {
                            i.player.on("play", function() {
                                i.toggleThumbContainer(!1, !0)
                            }), i.player.on("seeked", function() {
                                i.toggleThumbContainer(!1)
                            }), i.player.on("timeupdate", function() {
                                i.lastTime = i.player.media.currentTime
                            })
                        }), a(this, "render", function() {
                            i.elements.thumb.container = me("div", {
                                class: i.player.config.classNames.previewThumbnails.thumbContainer
                            }), i.elements.thumb.imageContainer = me("div", {
                                class: i.player.config.classNames.previewThumbnails.imageContainer
                            }), i.elements.thumb.container.appendChild(i.elements.thumb.imageContainer);
                            var e = me("div", {
                                class: i.player.config.classNames.previewThumbnails.timeContainer
                            });
                            i.elements.thumb.time = me("span", {}, "00:00"), e.appendChild(i.elements.thumb.time), i.elements.thumb.container.appendChild(e), Z(i.player.elements.progress) && i.player.elements.progress.appendChild(i.elements.thumb.container), i.elements.scrubbing.container = me("div", {
                                class: i.player.config.classNames.previewThumbnails.scrubbingContainer
                            }), i.player.elements.wrapper.appendChild(i.elements.scrubbing.container)
                        }), a(this, "destroy", function() {
                            i.elements.thumb.container && i.elements.thumb.container.remove(), i.elements.scrubbing.container && i.elements.scrubbing.container.remove()
                        }), a(this, "showImageAtCurrentTime", function() {
                            i.mouseDown ? i.setScrubbingContainerSize() : i.setThumbContainerSizeAndPos();
                            var e = i.thumbnails[0].frames.findIndex(function(e) {
                                    return i.seekTime >= e.startTime && i.seekTime <= e.endTime
                                }),
                                t = e >= 0,
                                n = 0;
                            i.mouseDown || i.toggleThumbContainer(t), t && (i.thumbnails.forEach(function(t, a) {
                                i.loadedImages.includes(t.frames[e].text) && (n = a)
                            }), e !== i.showingThumb && (i.showingThumb = e, i.loadImage(n)))
                        }), a(this, "loadImage", function() {
                            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                                t = i.showingThumb,
                                n = i.thumbnails[e],
                                a = n.urlPrefix,
                                r = n.frames[t],
                                o = n.frames[t].text,
                                s = a + o;
                            if (i.currentImageElement && i.currentImageElement.dataset.filename === o) i.showImage(i.currentImageElement, r, e, t, o, !1), i.currentImageElement.dataset.index = t, i.removeOldImages(i.currentImageElement);
                            else {
                                i.loadingImage && i.usingSprites && (i.loadingImage.onload = null);
                                var l = new Image;
                                l.src = s, l.dataset.index = t, l.dataset.filename = o, i.showingThumbFilename = o, i.player.debug.log("Loading image: ".concat(s)), l.onload = function() {
                                    return i.showImage(l, r, e, t, o, !0)
                                }, i.loadingImage = l, i.removeOldImages(l)
                            }
                        }), a(this, "showImage", function(e, t, n, a, r) {
                            var o = !(arguments.length > 5 && void 0 !== arguments[5]) || arguments[5];
                            i.player.debug.log("Showing thumb: ".concat(r, ". num: ").concat(a, ". qual: ").concat(n, ". newimg: ").concat(o)), i.setImageSizeAndOffset(e, t), o && (i.currentImageContainer.appendChild(e), i.currentImageElement = e, i.loadedImages.includes(r) || i.loadedImages.push(r)), i.preloadNearby(a, !0).then(i.preloadNearby(a, !1)).then(i.getHigherQuality(n, e, t, r))
                        }), a(this, "removeOldImages", function(e) {
                            Array.from(i.currentImageContainer.children).forEach(function(t) {
                                if ("img" === t.tagName.toLowerCase()) {
                                    var n = i.usingSprites ? 500 : 1e3;
                                    if (t.dataset.index !== e.dataset.index && !t.dataset.deleting) {
                                        t.dataset.deleting = !0;
                                        var a = i.currentImageContainer;
                                        setTimeout(function() {
                                            a.removeChild(t), i.player.debug.log("Removing thumb: ".concat(t.dataset.filename))
                                        }, n)
                                    }
                                }
                            })
                        }), a(this, "preloadNearby", function(e) {
                            var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                            return new Promise(function(n) {
                                setTimeout(function() {
                                    var a = i.thumbnails[0].frames[e].text;
                                    if (i.showingThumbFilename === a) {
                                        var o = !1;
                                        (t ? i.thumbnails[0].frames.slice(e) : i.thumbnails[0].frames.slice(0, e).reverse()).forEach(function(e) {
                                            var t = e.text;
                                            if (t !== a && !i.loadedImages.includes(t)) {
                                                o = !0, i.player.debug.log("Preloading thumb filename: ".concat(t));
                                                var r = i.thumbnails[0].urlPrefix + t,
                                                    s = new Image;
                                                s.src = r, s.onload = function() {
                                                    i.player.debug.log("Preloaded thumb filename: ".concat(t)), i.loadedImages.includes(t) || i.loadedImages.push(t), n()
                                                }
                                            }
                                        }), o || n()
                                    }
                                }, 300)
                            })
                        }), a(this, "getHigherQuality", function(e, t, n, a) {
                            if (e < i.thumbnails.length - 1) {
                                var r = t.naturalHeight;
                                i.usingSprites && (r = n.h), r < i.thumbContainerHeight && setTimeout(function() {
                                    i.showingThumbFilename === a && (i.player.debug.log("Showing higher quality thumb for: ".concat(a)), i.loadImage(e + 1))
                                }, 300)
                            }
                        }), a(this, "toggleThumbContainer", function() {
                            var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
                                t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                                n = i.player.config.classNames.previewThumbnails.thumbContainerShown;
                            i.elements.thumb.container.classList.toggle(n, e), !e && t && (i.showingThumb = null, i.showingThumbFilename = null)
                        }), a(this, "toggleScrubbingContainer", function() {
                            var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
                                t = i.player.config.classNames.previewThumbnails.scrubbingContainerShown;
                            i.elements.scrubbing.container.classList.toggle(t, e), e || (i.showingThumb = null, i.showingThumbFilename = null)
                        }), a(this, "determineContainerAutoSizing", function() {
                            (i.elements.thumb.imageContainer.clientHeight > 20 || i.elements.thumb.imageContainer.clientWidth > 20) && (i.sizeSpecifiedInCSS = !0)
                        }), a(this, "setThumbContainerSizeAndPos", function() {
                            if (i.sizeSpecifiedInCSS) {
                                if (i.elements.thumb.imageContainer.clientHeight > 20 && i.elements.thumb.imageContainer.clientWidth < 20) {
                                    var e = Math.floor(i.elements.thumb.imageContainer.clientHeight * i.thumbAspectRatio);
                                    i.elements.thumb.imageContainer.style.width = "".concat(e, "px")
                                } else if (i.elements.thumb.imageContainer.clientHeight < 20 && i.elements.thumb.imageContainer.clientWidth > 20) {
                                    var t = Math.floor(i.elements.thumb.imageContainer.clientWidth / i.thumbAspectRatio);
                                    i.elements.thumb.imageContainer.style.height = "".concat(t, "px")
                                }
                            } else {
                                var n = Math.floor(i.thumbContainerHeight * i.thumbAspectRatio);
                                i.elements.thumb.imageContainer.style.height = "".concat(i.thumbContainerHeight, "px"), i.elements.thumb.imageContainer.style.width = "".concat(n, "px")
                            }
                            i.setThumbContainerPos()
                        }), a(this, "setThumbContainerPos", function() {
                            var e = i.player.elements.progress.getBoundingClientRect(),
                                t = i.player.elements.container.getBoundingClientRect(),
                                n = i.elements.thumb.container,
                                a = t.left - e.left + 10,
                                r = t.right - e.left - n.clientWidth - 10,
                                o = i.mousePosX - e.left - n.clientWidth / 2;
                            o < a && (o = a), o > r && (o = r), n.style.left = "".concat(o, "px")
                        }), a(this, "setScrubbingContainerSize", function() {
                            var e = Mt(i.thumbAspectRatio, {
                                    width: i.player.media.clientWidth,
                                    height: i.player.media.clientHeight
                                }),
                                t = e.width,
                                n = e.height;
                            i.elements.scrubbing.container.style.width = "".concat(t, "px"), i.elements.scrubbing.container.style.height = "".concat(n, "px")
                        }), a(this, "setImageSizeAndOffset", function(e, t) {
                            if (i.usingSprites) {
                                var n = i.thumbContainerHeight / t.h;
                                e.style.height = "".concat(e.naturalHeight * n, "px"), e.style.width = "".concat(e.naturalWidth * n, "px"), e.style.left = "-".concat(t.x * n, "px"), e.style.top = "-".concat(t.y * n, "px")
                            }
                        }), this.player = n, this.thumbnails = [], this.loaded = !1, this.lastMouseMoveTime = Date.now(), this.mouseDown = !1, this.loadedImages = [], this.elements = {
                            thumb: {},
                            scrubbing: {}
                        }, this.load()
                    }
                    return i(e, [{
                        key: "enabled",
                        get: function() {
                            return this.player.isHTML5 && this.player.isVideo && this.player.config.previewThumbnails.enabled
                        }
                    }, {
                        key: "currentImageContainer",
                        get: function() {
                            return this.mouseDown ? this.elements.scrubbing.container : this.elements.thumb.imageContainer
                        }
                    }, {
                        key: "usingSprites",
                        get: function() {
                            return Object.keys(this.thumbnails[0].frames[0]).includes("w")
                        }
                    }, {
                        key: "thumbAspectRatio",
                        get: function() {
                            return this.usingSprites ? this.thumbnails[0].frames[0].w / this.thumbnails[0].frames[0].h : this.thumbnails[0].width / this.thumbnails[0].height
                        }
                    }, {
                        key: "thumbContainerHeight",
                        get: function() {
                            return this.mouseDown ? Mt(this.thumbAspectRatio, {
                                width: this.player.media.clientWidth,
                                height: this.player.media.clientHeight
                            }).height : this.sizeSpecifiedInCSS ? this.elements.thumb.imageContainer.clientHeight : Math.floor(this.player.media.clientWidth / this.thumbAspectRatio / 4)
                        }
                    }, {
                        key: "currentImageElement",
                        get: function() {
                            return this.mouseDown ? this.currentScrubbingImageElement : this.currentThumbnailImageElement
                        },
                        set: function(e) {
                            this.mouseDown ? this.currentScrubbingImageElement = e : this.currentThumbnailImageElement = e
                        }
                    }]), e
                }(),
                It = {
                    insertElements: function(e, t) {
                        var n = this;
                        Q(t) ? pe(e, this.media, {
                            src: t
                        }) : J(t) && t.forEach(function(t) {
                            pe(e, n.media, t)
                        })
                    },
                    change: function(e) {
                        var t = this;
                        ce(e, "sources.length") ? (Be.cancelRequests.call(this), this.destroy.call(this, function() {
                            t.options.quality = [], fe(t.media), t.media = null, Z(t.elements.container) && t.elements.container.removeAttribute("class");
                            var n = e.sources,
                                i = e.type,
                                a = l(n, 1)[0],
                                r = a.provider,
                                o = void 0 === r ? dt.html5 : r,
                                s = a.src,
                                c = "html5" === o ? i : "div",
                                u = "html5" === o ? {} : {
                                    src: s
                                };
                            Object.assign(t, {
                                provider: o,
                                type: i,
                                supported: Ne.check(i, o, t.config.playsinline),
                                media: me(c, u)
                            }), t.elements.container.appendChild(t.media), X(e.autoplay) && (t.config.autoplay = e.autoplay), t.isHTML5 && (t.config.crossorigin && t.media.setAttribute("crossorigin", ""), t.config.autoplay && t.media.setAttribute("autoplay", ""), re(e.poster) || (t.poster = e.poster), t.config.loop.active && t.media.setAttribute("loop", ""), t.config.muted && t.media.setAttribute("muted", ""), t.config.playsinline && t.media.setAttribute("playsinline", "")), bt.addStyleHook.call(t), t.isHTML5 && It.insertElements.call(t, "source", n), t.config.title = e.title, Et.setup.call(t), t.isHTML5 && Object.keys(e).includes("tracks") && It.insertElements.call(t, "track", e.tracks), (t.isHTML5 || t.isEmbed && !t.supported.ui) && bt.build.call(t), t.isHTML5 && t.media.load(), re(e.previewThumbnails) || (Object.assign(t.config.previewThumbnails, e.previewThumbnails), t.previewThumbnails && t.previewThumbnails.loaded && (t.previewThumbnails.destroy(), t.previewThumbnails = null), t.config.previewThumbnails.enabled && (t.previewThumbnails = new xt(t))), t.fullscreen.update()
                        }, !0)) : this.debug.warn("Invalid source format")
                    }
                },
                Ot = function() {
                    function e(n, i) {
                        var r = this;
                        if (t(this, e), a(this, "play", function() {
                                return $(r.media.play) ? (r.ads && r.ads.enabled && r.ads.managerPromise.then(function() {
                                    return r.ads.play()
                                }).catch(function() {
                                    return qe(r.media.play())
                                }), r.media.play()) : null
                            }), a(this, "pause", function() {
                                return r.playing && $(r.media.pause) ? r.media.pause() : null
                            }), a(this, "togglePlay", function(e) {
                                return (X(e) ? e : !r.playing) ? r.play() : r.pause()
                            }), a(this, "stop", function() {
                                r.isHTML5 ? (r.pause(), r.restart()) : $(r.media.stop) && r.media.stop()
                            }), a(this, "restart", function() {
                                r.currentTime = 0
                            }), a(this, "rewind", function(e) {
                                r.currentTime -= Y(e) ? e : r.config.seekTime
                            }), a(this, "forward", function(e) {
                                r.currentTime += Y(e) ? e : r.config.seekTime
                            }), a(this, "increaseVolume", function(e) {
                                var t = r.media.muted ? 0 : r.volume;
                                r.volume = t + (Y(e) ? e : 0)
                            }), a(this, "decreaseVolume", function(e) {
                                r.increaseVolume(-e)
                            }), a(this, "airplay", function() {
                                Ne.airplay && r.media.webkitShowPlaybackTargetPicker()
                            }), a(this, "toggleControls", function(e) {
                                if (r.supported.ui && !r.isAudio) {
                                    var t = ke(r.elements.container, r.config.classNames.hideControls),
                                        n = void 0 === e ? void 0 : !e,
                                        i = we(r.elements.container, r.config.classNames.hideControls, n);
                                    if (i && J(r.config.controls) && r.config.controls.includes("settings") && !re(r.config.settings) && at.toggleMenu.call(r, !1), i !== t) {
                                        var a = i ? "controlshidden" : "controlsshown";
                                        _e.call(r, r.media, a)
                                    }
                                    return !i
                                }
                                return !1
                            }), a(this, "on", function(e, t) {
                                Ie.call(r, r.elements.container, e, t)
                            }), a(this, "once", function(e, t) {
                                Oe.call(r, r.elements.container, e, t)
                            }), a(this, "off", function(e, t) {
                                Le(r.elements.container, e, t)
                            }), a(this, "destroy", function(e) {
                                var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                                if (r.ready) {
                                    var n = function() {
                                        document.body.style.overflow = "", r.embed = null, t ? (Object.keys(r.elements).length && (fe(r.elements.buttons.play), fe(r.elements.captions), fe(r.elements.controls), fe(r.elements.wrapper), r.elements.buttons.play = null, r.elements.captions = null, r.elements.controls = null, r.elements.wrapper = null), $(e) && e()) : (function() {
                                            this && this.eventListeners && (this.eventListeners.forEach(function(e) {
                                                var t = e.element,
                                                    n = e.type,
                                                    i = e.callback,
                                                    a = e.options;
                                                t.removeEventListener(n, i, a)
                                            }), this.eventListeners = [])
                                        }.call(r), Be.cancelRequests.call(r), ye(r.elements.original, r.elements.container), _e.call(r, r.elements.original, "destroyed", !0), $(e) && e.call(r.elements.original), r.ready = !1, setTimeout(function() {
                                            r.elements = null, r.media = null
                                        }, 200))
                                    };
                                    r.stop(), clearTimeout(r.timers.loading), clearTimeout(r.timers.controls), clearTimeout(r.timers.resized), r.isHTML5 ? (bt.toggleNativeControls.call(r, !0), n()) : r.isYouTube ? (clearInterval(r.timers.buffering), clearInterval(r.timers.playing), null !== r.embed && $(r.embed.destroy) && r.embed.destroy(), n()) : r.isVimeo && (null !== r.embed && r.embed.unload().then(n), setTimeout(n, 200))
                                }
                            }), a(this, "supports", function(e) {
                                return Ne.mime.call(r, e)
                            }), this.timers = {}, this.ready = !1, this.loading = !1, this.failed = !1, this.touch = Ne.touch, this.media = n, Q(this.media) && (this.media = document.querySelectorAll(this.media)), (window.jQuery && this.media instanceof jQuery || G(this.media) || J(this.media)) && (this.media = this.media[0]), this.config = ue({}, lt, e.defaults, i || {}, function() {
                                try {
                                    return JSON.parse(r.media.getAttribute("data-plyr-config"))
                                } catch (e) {
                                    return {}
                                }
                            }()), this.elements = {
                                container: null,
                                fullscreen: null,
                                captions: null,
                                buttons: {},
                                display: {},
                                progress: {},
                                inputs: {},
                                settings: {
                                    popup: null,
                                    menu: null,
                                    panels: {},
                                    buttons: {}
                                }
                            }, this.captions = {
                                active: null,
                                currentTrack: -1,
                                meta: new WeakMap
                            }, this.fullscreen = {
                                active: !1
                            }, this.options = {
                                speed: [],
                                quality: []
                            }, this.debug = new ft(this.config.debug), this.debug.log("Config", this.config), this.debug.log("Support", Ne), !z(this.media) && Z(this.media))
                            if (this.media.plyr) this.debug.warn("Target already setup");
                            else if (this.config.enabled)
                            if (Ne.check().api) {
                                var o = this.media.cloneNode(!0);
                                o.autoplay = !1, this.elements.original = o;
                                var s = this.media.tagName.toLowerCase(),
                                    l = null,
                                    c = null;
                                switch (s) {
                                    case "div":
                                        if (l = this.media.querySelector("iframe"), Z(l)) {
                                            if (c = rt(l.getAttribute("src")), this.provider = function(e) {
                                                    return /^(https?:\/\/)?(www\.)?(youtube\.com|youtube-nocookie\.com|youtu\.?be)\/.+$/.test(e) ? dt.youtube : /^https?:\/\/player.vimeo.com\/video\/\d{0,9}(?=\b|\/)/.test(e) ? dt.vimeo : null
                                                }(c.toString()), this.elements.container = this.media, this.media = l, this.elements.container.className = "", c.search.length) {
                                                var u = ["1", "true"];
                                                u.includes(c.searchParams.get("autoplay")) && (this.config.autoplay = !0), u.includes(c.searchParams.get("loop")) && (this.config.loop.active = !0), this.isYouTube ? (this.config.playsinline = u.includes(c.searchParams.get("playsinline")), this.config.youtube.hl = c.searchParams.get("hl")) : this.config.playsinline = !0
                                            }
                                        } else this.provider = this.media.getAttribute(this.config.attributes.embed.provider), this.media.removeAttribute(this.config.attributes.embed.provider);
                                        if (re(this.provider) || !Object.values(dt).includes(this.provider)) return void this.debug.error("Setup failed: Invalid provider");
                                        this.type = mt;
                                        break;
                                    case "video":
                                    case "audio":
                                        this.type = s, this.provider = dt.html5, this.media.hasAttribute("crossorigin") && (this.config.crossorigin = !0), this.media.hasAttribute("autoplay") && (this.config.autoplay = !0), (this.media.hasAttribute("playsinline") || this.media.hasAttribute("webkit-playsinline")) && (this.config.playsinline = !0), this.media.hasAttribute("muted") && (this.config.muted = !0), this.media.hasAttribute("loop") && (this.config.loop.active = !0);
                                        break;
                                    default:
                                        return void this.debug.error("Setup failed: unsupported type")
                                }
                                this.supported = Ne.check(this.type, this.provider, this.config.playsinline), this.supported.api ? (this.eventListeners = [], this.listeners = new vt(this), this.storage = new Je(this), this.media.plyr = this, Z(this.elements.container) || (this.elements.container = me("div", {
                                    tabindex: 0
                                }), de(this.media, this.elements.container)), bt.migrateStyles.call(this), bt.addStyleHook.call(this), Et.setup.call(this), this.config.debug && Ie.call(this, this.elements.container, this.config.events.join(" "), function(e) {
                                    r.debug.log("event: ".concat(e.type))
                                }), this.fullscreen = new gt(this), (this.isHTML5 || this.isEmbed && !this.supported.ui) && bt.build.call(this), this.listeners.container(), this.listeners.global(), this.config.ads.enabled && (this.ads = new Nt(this)), this.isHTML5 && this.config.autoplay && this.once("canplay", function() {
                                    return qe(r.play())
                                }), this.lastSeekTime = 0, this.config.previewThumbnails.enabled && (this.previewThumbnails = new xt(this))) : this.debug.error("Setup failed: no support")
                            } else this.debug.error("Setup failed: no support");
                        else this.debug.error("Setup failed: disabled by config");
                        else this.debug.error("Setup failed: no suitable element passed")
                    }
                    return i(e, [{
                        key: "toggleCaptions",
                        value: function(e) {
                            st.toggle.call(this, e, !1)
                        }
                    }, {
                        key: "isHTML5",
                        get: function() {
                            return this.provider === dt.html5
                        }
                    }, {
                        key: "isEmbed",
                        get: function() {
                            return this.isYouTube || this.isVimeo
                        }
                    }, {
                        key: "isYouTube",
                        get: function() {
                            return this.provider === dt.youtube
                        }
                    }, {
                        key: "isVimeo",
                        get: function() {
                            return this.provider === dt.vimeo
                        }
                    }, {
                        key: "isVideo",
                        get: function() {
                            return this.type === mt
                        }
                    }, {
                        key: "isAudio",
                        get: function() {
                            return "audio" === this.type
                        }
                    }, {
                        key: "playing",
                        get: function() {
                            return Boolean(this.ready && !this.paused && !this.ended)
                        }
                    }, {
                        key: "paused",
                        get: function() {
                            return Boolean(this.media.paused)
                        }
                    }, {
                        key: "stopped",
                        get: function() {
                            return Boolean(this.paused && 0 === this.currentTime)
                        }
                    }, {
                        key: "ended",
                        get: function() {
                            return Boolean(this.media.ended)
                        }
                    }, {
                        key: "currentTime",
                        set: function(e) {
                            if (this.duration) {
                                var t = Y(e) && e > 0;
                                this.media.currentTime = t ? Math.min(e, this.duration) : 0, this.debug.log("Seeking to ".concat(this.currentTime, " seconds"))
                            }
                        },
                        get: function() {
                            return Number(this.media.currentTime)
                        }
                    }, {
                        key: "buffered",
                        get: function() {
                            var e = this.media.buffered;
                            return Y(e) ? e : e && e.length && this.duration > 0 ? e.end(0) / this.duration : 0
                        }
                    }, {
                        key: "seeking",
                        get: function() {
                            return Boolean(this.media.seeking)
                        }
                    }, {
                        key: "duration",
                        get: function() {
                            var e = parseFloat(this.config.duration),
                                t = (this.media || {}).duration,
                                n = Y(t) && t !== 1 / 0 ? t : 0;
                            return e || n
                        }
                    }, {
                        key: "volume",
                        set: function(e) {
                            var t = e;
                            Q(t) && (t = Number(t)), Y(t) || (t = this.storage.get("volume")), Y(t) || (t = this.config.volume), t > 1 && (t = 1), t < 0 && (t = 0), this.config.volume = t, this.media.volume = t, !re(e) && this.muted && t > 0 && (this.muted = !1)
                        },
                        get: function() {
                            return Number(this.media.volume)
                        }
                    }, {
                        key: "muted",
                        set: function(e) {
                            var t = e;
                            X(t) || (t = this.storage.get("muted")), X(t) || (t = this.config.muted), this.config.muted = t, this.media.muted = t
                        },
                        get: function() {
                            return Boolean(this.media.muted)
                        }
                    }, {
                        key: "hasAudio",
                        get: function() {
                            return !this.isHTML5 || !!this.isAudio || Boolean(this.media.mozHasAudio) || Boolean(this.media.webkitAudioDecodedByteCount) || Boolean(this.media.audioTracks && this.media.audioTracks.length)
                        }
                    }, {
                        key: "speed",
                        set: function(e) {
                            var t = this,
                                n = null;
                            Y(e) && (n = e), Y(n) || (n = this.storage.get("speed")), Y(n) || (n = this.config.speed.selected);
                            var i = this.minimumSpeed,
                                a = this.maximumSpeed;
                            n = function() {
                                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 255;
                                return Math.min(Math.max(e, t), n)
                            }(n, i, a), this.config.speed.selected = n, setTimeout(function() {
                                t.media.playbackRate = n
                            }, 0)
                        },
                        get: function() {
                            return Number(this.media.playbackRate)
                        }
                    }, {
                        key: "minimumSpeed",
                        get: function() {
                            return this.isYouTube ? Math.min.apply(Math, c(this.options.speed)) : this.isVimeo ? .5 : .0625
                        }
                    }, {
                        key: "maximumSpeed",
                        get: function() {
                            return this.isYouTube ? Math.max.apply(Math, c(this.options.speed)) : this.isVimeo ? 2 : 16
                        }
                    }, {
                        key: "quality",
                        set: function(e) {
                            var t = this.config.quality,
                                n = this.options.quality;
                            if (n.length) {
                                var i = [!re(e) && Number(e), this.storage.get("quality"), t.selected, t.default].find(Y),
                                    a = !0;
                                if (!n.includes(i)) {
                                    var r = function(e, t) {
                                        return J(e) && e.length ? e.reduce(function(e, n) {
                                            return Math.abs(n - t) < Math.abs(e - t) ? n : e
                                        }) : null
                                    }(n, i);
                                    this.debug.warn("Unsupported quality option: ".concat(i, ", using ").concat(r, " instead")), i = r, a = !1
                                }
                                t.selected = i, this.media.quality = i, a && this.storage.set({
                                    quality: i
                                })
                            }
                        },
                        get: function() {
                            return this.media.quality
                        }
                    }, {
                        key: "loop",
                        set: function(e) {
                            var t = X(e) ? e : this.config.loop.active;
                            this.config.loop.active = t, this.media.loop = t
                        },
                        get: function() {
                            return Boolean(this.media.loop)
                        }
                    }, {
                        key: "source",
                        set: function(e) {
                            It.change.call(this, e)
                        },
                        get: function() {
                            return this.media.currentSrc
                        }
                    }, {
                        key: "download",
                        get: function() {
                            var e = this.config.urls.download;
                            return ae(e) ? e : this.source
                        },
                        set: function(e) {
                            ae(e) && (this.config.urls.download = e, at.setDownloadUrl.call(this))
                        }
                    }, {
                        key: "poster",
                        set: function(e) {
                            this.isVideo ? bt.setPoster.call(this, e, !1).catch(function() {}) : this.debug.warn("Poster can only be set for video")
                        },
                        get: function() {
                            return this.isVideo ? this.media.getAttribute("poster") || this.media.getAttribute("data-poster") : null
                        }
                    }, {
                        key: "ratio",
                        get: function() {
                            if (!this.isVideo) return null;
                            var e = Fe(Re.call(this));
                            return J(e) ? e.join(":") : e
                        },
                        set: function(e) {
                            this.isVideo ? Q(e) && He(e) ? (this.config.ratio = e, Ve.call(this)) : this.debug.error("Invalid aspect ratio specified (".concat(e, ")")) : this.debug.warn("Aspect ratio can only be set for video")
                        }
                    }, {
                        key: "autoplay",
                        set: function(e) {
                            var t = X(e) ? e : this.config.autoplay;
                            this.config.autoplay = t
                        },
                        get: function() {
                            return Boolean(this.config.autoplay)
                        }
                    }, {
                        key: "currentTrack",
                        set: function(e) {
                            st.set.call(this, e, !1)
                        },
                        get: function() {
                            var e = this.captions,
                                t = e.toggled,
                                n = e.currentTrack;
                            return t ? n : -1
                        }
                    }, {
                        key: "language",
                        set: function(e) {
                            st.setLanguage.call(this, e, !1)
                        },
                        get: function() {
                            return (st.getCurrentTrack.call(this) || {}).language
                        }
                    }, {
                        key: "pip",
                        set: function(e) {
                            if (Ne.pip) {
                                var t = X(e) ? e : !this.pip;
                                $(this.media.webkitSetPresentationMode) && this.media.webkitSetPresentationMode(t ? ct : "inline"), $(this.media.requestPictureInPicture) && (!this.pip && t ? this.media.requestPictureInPicture() : this.pip && !t && document.exitPictureInPicture())
                            }
                        },
                        get: function() {
                            return Ne.pip ? re(this.media.webkitPresentationMode) ? this.media === document.pictureInPictureElement : this.media.webkitPresentationMode === ct : null
                        }
                    }], [{
                        key: "supported",
                        value: function(e, t, n) {
                            return Ne.check(e, t, n)
                        }
                    }, {
                        key: "loadSprite",
                        value: function(e, t) {
                            return Ze(e, t)
                        }
                    }, {
                        key: "setup",
                        value: function(t) {
                            var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                                i = null;
                            return Q(t) ? i = Array.from(document.querySelectorAll(t)) : G(t) ? i = Array.from(t) : J(t) && (i = t.filter(Z)), re(i) ? null : i.map(function(t) {
                                return new e(t, n)
                            })
                        }
                    }]), e
                }();
            return Ot.defaults = (Lt = lt, JSON.parse(JSON.stringify(Lt))), Ot
        }, module.exports = t())
    }).call(exports, __webpack_require__(54))
}, function(module, exports) {}, function(module, exports) {
    module.exports = {
        name: "@marketing-campaigns/thanksgiving",
        description: "",
        version: "0.53.0",
        repository: {
            type: "git",
            url: "git@code.devops.fds.com:polaris/campaign/thanksgiving.git"
        },
        config: {
            environment: [{
                name: "key1",
                local: {
                    mcom: "value1",
                    bcom: "value2"
                },
                prod: {
                    mcom: "__VALUE3__",
                    bcom: "__VALUE4__"
                }
            }, {
                name: "XAPI_HOST",
                local: {
                    mcom: "https://mcom.xapi.com",
                    bcom: "https://bcom.xapi.com"
                },
                prod: {
                    mcom: "__VALUE5__",
                    bcom: "__VALUE6__"
                }
            }],
            pages: [{
                path: "/",
                template: "main",
                autoHeader: !1,
                autoFooter: !1,
                quickview: !0,
                tags: {
                    description: "Make 2021 the best Thanksgiving ever and host an unforgettable celebration with this deliciously decadent but deceptively easy guide from Bloomingdale's.",
                    canonical: "https://www.bloomingdales.com/c/thanksgiving/",
                    robots: "index, follow",
                    title: "How to Host the Best Thanksgiving Ever - Bloomingdale's"
                },
                coremetrics: {
                    pageType: "",
                    pageId: "",
                    categoryID: ""
                },
                apiCall: {
                    method: "GET",
                    path: "https://cdn.contentful.com/spaces/m3h9iuk14rnq/environments/master/entries/4vkk5pDNPPWpZCpOOInBSh?access_token=867b911445d5af9f570b8d1ebe34769a136084ce6deb7f212ac1d34938579bc4"
                }
            }],
            macysCliVersion: "1.403.34"
        },
        engines: {
            node: "8.x",
            npm: "5.x"
        },
        main: "src/thanksgiving.js",
        devDependencies: {
            "@core/dev-server": "^1.0.0",
            "@core/lib": "^1.0.0",
            "@core/server": "^1.0.0",
            lodash: "^4.17.4"
        },
        dependencies: {
            plyr: "3.6.4",
            swiper: "7.0.6"
        }
    }
}], [134]);
//# sourceMappingURL=thanksgiving.app.js.map